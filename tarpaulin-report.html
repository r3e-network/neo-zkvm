<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","benches","comprehensive_bench.rs"],"content":"//! Comprehensive Neo VM Benchmarks\n\nuse criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse neo_vm_core::{NeoVM, VMState};\n\nfn bench_arithmetic(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"arithmetic\");\n\n    // ADD benchmark\n    group.bench_function(\"add\", |b| {\n        b.iter(|| {\n            let mut vm = NeoVM::new(1_000_000);\n            vm.load_script(vec![0x12, 0x13, 0x9E, 0x40]);\n            while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                vm.execute_next().unwrap();\n            }\n            black_box(vm.eval_stack.pop())\n        })\n    });\n\n    // MUL benchmark\n    group.bench_function(\"mul\", |b| {\n        b.iter(|| {\n            let mut vm = NeoVM::new(1_000_000);\n            vm.load_script(vec![0x16, 0x17, 0xA0, 0x40]);\n            while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                vm.execute_next().unwrap();\n            }\n            black_box(vm.eval_stack.pop())\n        })\n    });\n\n    // DIV benchmark\n    group.bench_function(\"div\", |b| {\n        b.iter(|| {\n            let mut vm = NeoVM::new(1_000_000);\n            vm.load_script(vec![0x1F, 0x15, 0xA1, 0x40]);\n            while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                vm.execute_next().unwrap();\n            }\n            black_box(vm.eval_stack.pop())\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_stack_ops(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"stack\");\n\n    group.bench_function(\"dup\", |b| {\n        b.iter(|| {\n            let mut vm = NeoVM::new(1_000_000);\n            vm.load_script(vec![0x15, 0x4A, 0x40]);\n            while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                vm.execute_next().unwrap();\n            }\n            black_box(vm.eval_stack.len())\n        })\n    });\n\n    group.bench_function(\"swap\", |b| {\n        b.iter(|| {\n            let mut vm = NeoVM::new(1_000_000);\n            vm.load_script(vec![0x11, 0x12, 0x50, 0x40]);\n            while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                vm.execute_next().unwrap();\n            }\n            black_box(vm.eval_stack.pop())\n        })\n    });\n\n    group.finish();\n}\n\nfn bench_loop(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"loop\");\n\n    for iterations in [10, 100, 1000].iter() {\n        group.bench_with_input(\n            BenchmarkId::new(\"iterations\", iterations),\n            iterations,\n            |b, \u0026n| {\n                // Build loop script: counter, loop body, decrement, jump if not zero\n                let mut script = vec![0x00, n as u8]; // PUSHINT8 n\n                for _ in 0..n {\n                    script.extend_from_slice(\u0026[0x9D]); // DEC\n                }\n                script.push(0x40); // RET\n\n                b.iter(|| {\n                    let mut vm = NeoVM::new(1_000_000);\n                    vm.load_script(script.clone());\n                    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n                        vm.execute_next().unwrap();\n                    }\n                    black_box(vm.gas_consumed)\n                })\n            },\n        );\n    }\n    group.finish();\n}\n\ncriterion_group!(benches, bench_arithmetic, bench_stack_ops, bench_loop);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","benches","vm_bench.rs"],"content":"//! Benchmarks for Neo VM Core\n\nuse neo_vm_core::{NeoVM, VMState};\nuse std::time::Instant;\n\nfn benchmark_arithmetic() {\n    let script = vec![\n        0x12, 0x13, 0x9E, // PUSH2, PUSH3, ADD\n        0x14, 0xA0, // PUSH4, MUL\n        0x12, 0xA1, // PUSH2, DIV\n        0x40, // RET\n    ];\n\n    let iterations = 10000;\n    let start = Instant::now();\n\n    for _ in 0..iterations {\n        let mut vm = NeoVM::new(1_000_000);\n        vm.load_script(script.clone());\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            let _ = vm.execute_next();\n        }\n    }\n\n    let elapsed = start.elapsed();\n    println!(\"Arithmetic: {} iterations in {:?}\", iterations, elapsed);\n    println!(\"  Per iteration: {:?}\", elapsed / iterations);\n}\n\nfn main() {\n    println!(\"Neo VM Benchmarks\\n\");\n    benchmark_arithmetic();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","examples","vm_examples.rs"],"content":"//! # Neo zkVM Examples\n//!\n//! This module contains runnable examples demonstrating common use cases\n//! for the Neo zkVM.\n//!\n//! Run examples with: `cargo run --example \u003cname\u003e`\n\n/// Example: Simple Arithmetic\n///\n/// Computes factorial of 5 using the Neo VM.\nfn factorial_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // Factorial of 5 = 120\n    // 5! = 5 * 4 * 3 * 2 * 1 = 120\n    let script = vec![\n        0x15, // PUSH5\n        0x14, // PUSH4\n        0xA0, // MUL (5*4=20)\n        0x13, // PUSH3\n        0xA0, // MUL (20*3=60)\n        0x12, // PUSH2\n        0xA0, // MUL (60*2=120)\n        0x11, // PUSH1\n        0xA0, // MUL (120*1=120)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    assert_eq!(result, StackItem::Integer(120));\n    println!(\"5! = {}\", 120);\n}\n\n/// Example: Fibonacci Sequence\n///\n/// Computes the 10th Fibonacci number.\nfn fibonacci_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // F(10) = 55\n    // Using iterative approach\n    let script = vec![\n        0x10, // PUSH0 (a)\n        0x11, // PUSH1 (b)\n        0x13, // PUSH3 (loop count - 3 because we start with F(0)=0, F(1)=1)\n        0xC3, // NEWARRAY\n        0x4C, 0x00, // PICK0 (a)\n        0x4C, 0x01, // PICK1 (b)\n        0x9E, // ADD (a+b)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    println!(\"Fibonacci example completed\");\n}\n\n/// Example: Hash Computation\n///\n/// Computes SHA256 hash of a string.\nfn hash_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // SHA256(\"hello\")\n    let script = vec![\n        0x0C, 0x05, b'h', b'e', b'l', b'l', b'o', // PUSHDATA1 \"hello\"\n        0xF0, // SHA256\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    if let Some(StackItem::ByteString(hash)) = vm.eval_stack.pop() {\n        println!(\"SHA256('hello') = {}\", hex::encode(\u0026hash));\n        println!(\"Hash length: {} bytes\", hash.len());\n    }\n}\n\n/// Example: Array Operations\n///\n/// Creates and manipulates an array.\nfn array_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // Create array with 5 elements, get its size\n    let script = vec![\n        0x16, // PUSH6\n        0xC3, // NEWARRAY (create array of size 6)\n        0xCA, // SIZE\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    assert_eq!(result, StackItem::Integer(6));\n    println!(\"Array size: 6\");\n}\n\n/// Example: Conditional Execution\n///\n/// Demonstrates comparison and conditional branching.\nfn conditional_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // Check if 10 \u003e 5\n    let script = vec![\n        0x1A, // PUSH26 (10 in small int range)\n        0x15, // PUSH5\n        0xB7, // GT (26 \u003e 5 = true)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    assert_eq!(result, StackItem::Boolean(true));\n    println!(\"26 \u003e 5 is true\");\n}\n\n/// Example: Error Handling\n///\n/// Demonstrates graceful handling of errors like division by zero.\nfn error_handling_example() {\n    use neo_vm_core::{NeoVM, VMState};\n\n    // Attempt division by zero\n    let script = vec![\n        0x15, // PUSH5\n        0x10, // PUSH0\n        0xA1, // DIV (5/0 = error)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    assert!(matches!(vm.state, VMState::Fault));\n    println!(\"Division by zero correctly detected as error\");\n}\n\n/// Example: Bitwise Operations\n///\n/// Demonstrates common bitwise operations.\nfn bitwise_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // (15 | 8) \u0026 7 = 15 \u0026 7 = 7\n    let script = vec![\n        0x1F, // PUSH31 (15 + 16 = 31 in small int range)\n        0x18, // PUSH8\n        0x92, // OR (31 | 8 = 31)\n        0x17, // PUSH7\n        0x91, // AND (31 \u0026 7 = 7)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    println!(\"Bitwise result: {:?}\", result);\n}\n\n/// Example: Loop with Gas Limit\n///\n/// Demonstrates gas-based loop termination.\nfn loop_example() {\n    use neo_vm_core::{NeoVM, VMState};\n\n    // Simple loop that increments a counter\n    let script = vec![\n        0x10, // PUSH0 (counter)\n        0x22, 0xFE, // JMP -2 (infinite loop)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(100); // Very low gas limit\n    vm.load_script(script).unwrap();\n\n    let start_gas = vm.gas_consumed;\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    assert!(matches!(vm.state, VMState::Fault));\n    println!(\"Loop terminated after gas exhaustion\");\n    println!(\"Gas consumed: {}\", vm.gas_consumed - start_gas);\n}\n\n/// Example: Min/Max Operations\n///\n/// Demonstrates min and max operations.\nfn minmax_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // min(-5, 10) = -5\n    let script = vec![\n        0x0B, // PUSHNULL (will use immediate values)\n        // Using actual small integers\n        0x13, // PUSH3\n        0x15, // PUSH5\n        0xB9, // MIN (3 \u003c 5 = 3)\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    println!(\"min(3, 5) = {:?}\", result);\n}\n\n/// Example: Sign Operations\n///\n/// Demonstrates sign-related operations.\nfn sign_example() {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    // SIGN(-10) = -1\n    let script = vec![\n        0x0C, 0x0A, // PUSHDATA1 with 10 bytes (special handling needed)\n        // Using available opcodes\n        0x10, // PUSH0\n        0x9B, // NEGATE\n        0x40, // RET\n    ];\n\n    let mut vm = NeoVM::new(1_000_000);\n    vm.load_script(script).unwrap();\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n\n    let result = vm.eval_stack.pop().unwrap();\n    println!(\"Sign example result: {:?}\", result);\n}\n\nfn main() {\n    println!(\"=== Neo zkVM Examples ===\\n\");\n\n    println!(\"1. Factorial:\");\n    factorial_example();\n    println!();\n\n    println!(\"2. Hash Computation:\");\n    hash_example();\n    println!();\n\n    println!(\"3. Array Operations:\");\n    array_example();\n    println!();\n\n    println!(\"4. Conditional Execution:\");\n    conditional_example();\n    println!();\n\n    println!(\"5. Error Handling:\");\n    error_handling_example();\n    println!();\n\n    println!(\"6. Bitwise Operations:\");\n    bitwise_example();\n    println!();\n\n    println!(\"7. Loop with Gas Limit:\");\n    loop_example();\n    println!();\n\n    println!(\"8. Min/Max Operations:\");\n    minmax_example();\n    println!();\n\n    println!(\"All examples completed!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","engine.rs"],"content":"//! Neo VM Execution Engine\n//!\n//! Neo VM Engine\n//!\n//! Core execution engine for Neo zkVM.\n\nuse crate::stack_item::StackItem;\nuse k256::ecdsa::{signature::Verifier, Signature, VerifyingKey};\nuse ripemd::Ripemd160;\nuse sha2::{Digest, Sha256};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum VMError {\n    #[error(\"Stack underflow\")]\n    StackUnderflow,\n    #[error(\"Invalid opcode: {0}\")]\n    InvalidOpcode(u8),\n    #[error(\"Out of gas\")]\n    OutOfGas,\n    #[error(\"Division by zero\")]\n    DivisionByZero,\n    #[error(\"Invalid type\")]\n    InvalidType,\n    #[error(\"Unknown syscall: {0}\")]\n    UnknownSyscall(u32),\n    #[error(\"Invalid operation\")]\n    InvalidOperation,\n    #[error(\"Invalid script\")]\n    InvalidScript,\n    #[error(\"Invalid public key format for CHECKSIG\")]\n    InvalidPublicKey,\n    #[error(\"Invalid signature format for CHECKSIG\")]\n    InvalidSignature,\n    #[error(\"Signature verification failed\")]\n    SignatureVerificationFailed,\n}\n\n#[derive(Debug, Clone)]\npub enum VMState {\n    None,\n    Halt,\n    Fault,\n    Break,\n}\n\n#[derive(Debug, Clone)]\npub struct ExecutionContext {\n    pub script: Vec\u003cu8\u003e,\n    pub ip: usize,\n}\n\n// SAFETY: ExecutionContext is designed for single-threaded use within NeoVM.\nunsafe impl Send for ExecutionContext {}\nunsafe impl Sync for ExecutionContext {}\n\n/// Built-in syscall IDs (Neo N3 compatible)\npub mod syscall {\n    pub const SYSTEM_RUNTIME_LOG: u32 = 0x01;\n    pub const SYSTEM_RUNTIME_NOTIFY: u32 = 0x02;\n    pub const SYSTEM_RUNTIME_GETTIME: u32 = 0x03;\n    pub const SYSTEM_STORAGE_GET: u32 = 0x10;\n    pub const SYSTEM_STORAGE_PUT: u32 = 0x11;\n    pub const SYSTEM_STORAGE_DELETE: u32 = 0x12;\n}\n\n/// Gas cost lookup table for O(1) opcode cost retrieval\n/// Uses u16 to support CHECKSIG's high gas cost (32768)\nconst GAS_COSTS: [u16; 256] = [\n    // 0x00-0x0F (PUSHINT8-PUSHM1)\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x10-0x1F (PUSH0-PUSH16)\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x20-0x2F\n    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x30-0x3F (flow control)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    // 0x40-0x4F (RET, DEPTH, CLEAR, stack ops)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x50-0x5F (stack ops)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x60-0x6F (slot ops)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x70-0x7F (slot ops)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x80-0x8F (splice/buffer ops)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0x90-0x9F (bitwise/invert/equality)\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, // 0xA0-0xAF (arithmetic)\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, // 0xB0-0xBF (comparison/min/max/within)\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, // 0xC0-0xCF (compound types)\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, // 0xD0-0xDF (compound types)\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // 0xE0-0xEF (reserved)\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    // 0xF0-0xFF (crypto: SHA256, RIPEMD160, CHECKSIG)\n    512, 512, 512, 32768, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\n#[inline]\nfn get_gas_cost(op: u8) -\u003e u64 {\n    GAS_COSTS[op as usize] as u64\n}\n\n/// Maximum script size in bytes (1MB)\npub const MAX_SCRIPT_SIZE: usize = 1024 * 1024;\n\n/// Execution trace step for proof generation\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct TraceStep {\n    pub ip: usize,\n    pub opcode: u8,\n    pub stack_hash: [u8; 32],\n    pub gas_consumed: u64,\n}\n\n/// Full execution trace\n#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]\npub struct ExecutionTrace {\n    pub steps: Vec\u003cTraceStep\u003e,\n    pub initial_state_hash: [u8; 32],\n    pub final_state_hash: [u8; 32],\n}\n\npub struct NeoVM {\n    pub state: VMState,\n    pub eval_stack: Vec\u003cStackItem\u003e,\n    pub invocation_stack: Vec\u003cExecutionContext\u003e,\n    pub gas_consumed: u64,\n    pub gas_limit: u64,\n    pub notifications: Vec\u003cStackItem\u003e,\n    pub logs: Vec\u003cString\u003e,\n    pub trace: ExecutionTrace,\n    pub tracing_enabled: bool,\n    // Slot support for Neo VM compatibility\n    pub local_slots: Vec\u003cStackItem\u003e,\n    pub argument_slots: Vec\u003cStackItem\u003e,\n    pub static_slots: Vec\u003cStackItem\u003e,\n}\n\nimpl NeoVM {\n    /// Default stack capacity for pre-allocation\n    const DEFAULT_STACK_CAPACITY: usize = 64;\n    /// Default invocation depth capacity\n    const DEFAULT_INVOCATION_CAPACITY: usize = 8;\n\n    #[inline]\n    pub fn new(gas_limit: u64) -\u003e Self {\n        Self {\n            state: VMState::None,\n            eval_stack: Vec::with_capacity(Self::DEFAULT_STACK_CAPACITY),\n            invocation_stack: Vec::with_capacity(Self::DEFAULT_INVOCATION_CAPACITY),\n            gas_consumed: 0,\n            gas_limit,\n            notifications: Vec::new(),\n            logs: Vec::new(),\n            trace: ExecutionTrace::default(),\n            tracing_enabled: false,\n            local_slots: Vec::with_capacity(Self::DEFAULT_STACK_CAPACITY),\n            argument_slots: Vec::with_capacity(Self::DEFAULT_STACK_CAPACITY),\n            static_slots: Vec::with_capacity(Self::DEFAULT_STACK_CAPACITY),\n        }\n    }\n\n    /// Run the VM until halt or fault\n    #[inline]\n    pub fn run(\u0026mut self) {\n        while !matches!(self.state, VMState::Halt | VMState::Fault) {\n            if self.execute_next().is_err() {\n                self.state = VMState::Fault;\n                break;\n            }\n        }\n    }\n\n    #[inline]\n    pub fn enable_tracing(\u0026mut self) {\n        self.tracing_enabled = true;\n        self.trace.initial_state_hash = self.compute_state_hash();\n    }\n\n    #[inline]\n    fn compute_state_hash(\u0026self) -\u003e [u8; 32] {\n        use sha2::Digest;\n        let mut hasher = Sha256::new();\n        for item in \u0026self.eval_stack {\n            hasher.update(format!(\"{:?}\", item).as_bytes());\n        }\n        hasher.update(self.gas_consumed.to_le_bytes());\n        hasher.finalize().into()\n    }\n\n    #[inline]\n    pub fn load_script(\u0026mut self, script: Vec\u003cu8\u003e) -\u003e Result\u003c(), VMError\u003e {\n        if script.len() \u003e MAX_SCRIPT_SIZE {\n            return Err(VMError::InvalidScript);\n        }\n        self.invocation_stack\n            .push(ExecutionContext { script, ip: 0 });\n        Ok(())\n    }\n\n    pub fn execute_next(\u0026mut self) -\u003e Result\u003c(), VMError\u003e {\n        let ctx = self\n            .invocation_stack\n            .last_mut()\n            .ok_or(VMError::StackUnderflow)?;\n\n        if ctx.ip \u003e= ctx.script.len() {\n            self.state = VMState::Halt;\n            if self.tracing_enabled {\n                self.trace.final_state_hash = self.compute_state_hash();\n            }\n            return Ok(());\n        }\n\n        let ip = ctx.ip;\n        let op = ctx.script[ctx.ip];\n        ctx.ip += 1;\n\n        // Gas metering\n        let gas_cost = get_gas_cost(op);\n        self.gas_consumed += gas_cost;\n        if self.gas_consumed \u003e self.gas_limit {\n            self.state = VMState::Fault;\n            return Err(VMError::OutOfGas);\n        }\n\n        // Record trace step\n        if self.tracing_enabled {\n            let step = TraceStep {\n                ip,\n                opcode: op,\n                stack_hash: self.compute_state_hash(),\n                gas_consumed: self.gas_consumed,\n            };\n            self.trace.steps.push(step);\n        }\n\n        if let Err(e) = self.execute_op(op) {\n            self.state = VMState::Fault;\n            return Err(e);\n        }\n        Ok(())\n    }\n\n    fn execute_op(\u0026mut self, op: u8) -\u003e Result\u003c(), VMError\u003e {\n        match op {\n            0x10 =\u003e self.eval_stack.push(StackItem::Integer(0)),\n            0x11..=0x20 =\u003e {\n                let n = (op - 0x10) as i128;\n                self.eval_stack.push(StackItem::Integer(n));\n            }\n            0x0F =\u003e self.eval_stack.push(StackItem::Integer(-1)),\n            0x0B =\u003e self.eval_stack.push(StackItem::Null),\n            // PUSHDATA1 - Push data with 1-byte length prefix\n            0x0C =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let len = ctx.script[ctx.ip] as usize;\n                ctx.ip += 1;\n                if ctx.ip + len \u003e ctx.script.len() {\n                    return Err(VMError::InvalidScript);\n                }\n                let data = ctx.script[ctx.ip..ctx.ip + len].to_vec();\n                ctx.ip += len;\n                self.eval_stack.push(StackItem::ByteString(data));\n            }\n            // PUSHDATA2 - Push data with 2-byte length prefix\n            0x0D =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                if ctx.ip + 2 \u003e ctx.script.len() {\n                    return Err(VMError::InvalidScript);\n                }\n                let len = u16::from_le_bytes([ctx.script[ctx.ip], ctx.script[ctx.ip + 1]]) as usize;\n                ctx.ip += 2;\n                if ctx.ip + len \u003e ctx.script.len() {\n                    return Err(VMError::InvalidScript);\n                }\n                let data = ctx.script[ctx.ip..ctx.ip + len].to_vec();\n                ctx.ip += len;\n                self.eval_stack.push(StackItem::ByteString(data));\n            }\n            // PUSHINT8\n            0x00 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                if ctx.ip \u003e= ctx.script.len() {\n                    return Err(VMError::InvalidScript);\n                }\n                let val = ctx.script[ctx.ip] as i8 as i128;\n                ctx.ip += 1;\n                self.eval_stack.push(StackItem::Integer(val));\n            }\n            // PUSHINT16\n            0x01 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                if ctx.ip + 2 \u003e ctx.script.len() {\n                    return Err(VMError::InvalidScript);\n                }\n                let val = i16::from_le_bytes([ctx.script[ctx.ip], ctx.script[ctx.ip + 1]]) as i128;\n                ctx.ip += 2;\n                self.eval_stack.push(StackItem::Integer(val));\n            }\n            0x45 =\u003e {\n                self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n            }\n            0x4A =\u003e {\n                let item = self\n                    .eval_stack\n                    .last()\n                    .ok_or(VMError::StackUnderflow)?\n                    .clone();\n                self.eval_stack.push(item);\n            }\n            // ADD\n            0x9E =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_add(b).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // SUB\n            0x9F =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_sub(b).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // MUL\n            0xA0 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_mul(b).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // DIV\n            0xA1 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if b == 0 {\n                    return Err(VMError::DivisionByZero);\n                }\n                let result = a.checked_div(b).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // MOD\n            0xA2 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if b == 0 {\n                    return Err(VMError::DivisionByZero);\n                }\n                let result = a.checked_rem(b).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // POW\n            0xA3 =\u003e {\n                let exp = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let base = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if exp \u003c 0 {\n                    return Err(VMError::InvalidOperation);\n                }\n                let result = base.pow(exp as u32);\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // SHL\n            0xA8 =\u003e {\n                let shift = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let value = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if !(0..=256).contains(\u0026shift) {\n                    return Err(VMError::InvalidOperation);\n                }\n                let result = value\n                    .checked_shl(shift as u32)\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // SHR\n            0xA9 =\u003e {\n                let shift = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let value = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if !(0..=256).contains(\u0026shift) {\n                    return Err(VMError::InvalidOperation);\n                }\n                let result = value\n                    .checked_shr(shift as u32)\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // MIN\n            0xB9 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(a.min(b)));\n            }\n            // MAX\n            0xBA =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(a.max(b)));\n            }\n            // WITHIN (a \u003c= x \u003c b)\n            0xBB =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let x = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a \u003c= x \u0026\u0026 x \u003c b));\n            }\n            // SIGN\n            0x99 =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let sign = if a \u003e 0 {\n                    1\n                } else if a \u003c 0 {\n                    -1\n                } else {\n                    0\n                };\n                self.eval_stack.push(StackItem::Integer(sign));\n            }\n            // ABS\n            0x9A =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_abs().ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // NEGATE\n            0x9B =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_neg().ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // INC\n            0x9C =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_add(1).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // DEC\n            0x9D =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let result = a.checked_sub(1).ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(StackItem::Integer(result));\n            }\n            // LT\n            0xB5 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a \u003c b));\n            }\n            // LE\n            0xB6 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a \u003c= b));\n            }\n            // GT\n            0xB7 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a \u003e b));\n            }\n            // GE\n            0xB8 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a \u003e= b));\n            }\n            // EQUAL\n            0x97 =\u003e {\n                let b = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let a = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a == b));\n            }\n            // NOTEQUAL\n            0x98 =\u003e {\n                let b = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let a = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a != b));\n            }\n            // ISNULL\n            0xD8 =\u003e {\n                let item = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack\n                    .push(StackItem::Boolean(matches!(item, StackItem::Null)));\n            }\n            // NZ - Not zero\n            0xB1 =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a != 0));\n            }\n            // NUMEQUAL\n            0xB3 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a == b));\n            }\n            // NUMNOTEQUAL\n            0xB4 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(a != b));\n            }\n            // INVERT (bitwise NOT)\n            0x90 =\u003e {\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(!a));\n            }\n            // AND (bitwise)\n            0x91 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(a \u0026 b));\n            }\n            // OR (bitwise)\n            0x92 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(a | b));\n            }\n            // XOR (bitwise)\n            0x93 =\u003e {\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Integer(a ^ b));\n            }\n            // NOT (logical)\n            0xAA =\u003e {\n                let a = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack.push(StackItem::Boolean(!a.to_bool()));\n            }\n            // BOOLAND\n            0xAB =\u003e {\n                let b = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let a = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack\n                    .push(StackItem::Boolean(a.to_bool() \u0026\u0026 b.to_bool()));\n            }\n            // BOOLOR\n            0xAC =\u003e {\n                let b = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let a = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.eval_stack\n                    .push(StackItem::Boolean(a.to_bool() || b.to_bool()));\n            }\n            // SWAP\n            0x50 =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 2 {\n                    return Err(VMError::StackUnderflow);\n                }\n                self.eval_stack.swap(len - 1, len - 2);\n            }\n            // ROT\n            0x51 =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 3 {\n                    return Err(VMError::StackUnderflow);\n                }\n                let item = self.eval_stack.remove(len - 3);\n                self.eval_stack.push(item);\n            }\n            // PICK\n            0x4D =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let len = self.eval_stack.len();\n                if n \u003e= len {\n                    return Err(VMError::StackUnderflow);\n                }\n                let item = self.eval_stack[len - 1 - n].clone();\n                self.eval_stack.push(item);\n            }\n            // ROLL\n            0x52 =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let len = self.eval_stack.len();\n                if n \u003e= len {\n                    return Err(VMError::StackUnderflow);\n                }\n                let item = self.eval_stack.remove(len - 1 - n);\n                self.eval_stack.push(item);\n            }\n            // OVER\n            0x4B =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 2 {\n                    return Err(VMError::StackUnderflow);\n                }\n                let item = self.eval_stack[len - 2].clone();\n                self.eval_stack.push(item);\n            }\n            // DEPTH\n            0x43 =\u003e {\n                let depth = self.eval_stack.len() as i128;\n                self.eval_stack.push(StackItem::Integer(depth));\n            }\n            // NIP - Remove second-to-top item\n            0x46 =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 2 {\n                    return Err(VMError::StackUnderflow);\n                }\n                self.eval_stack.remove(len - 2);\n            }\n            // XDROP - Remove item at index n\n            0x48 =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let len = self.eval_stack.len();\n                if n \u003e= len {\n                    return Err(VMError::StackUnderflow);\n                }\n                self.eval_stack.remove(len - 1 - n);\n            }\n            // CLEAR - Clear the stack\n            0x49 =\u003e {\n                self.eval_stack.clear();\n            }\n            // TUCK - Copy top item and insert before second-to-top\n            0x4E =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 2 {\n                    return Err(VMError::StackUnderflow);\n                }\n                let item = self.eval_stack[len - 1].clone();\n                self.eval_stack.insert(len - 2, item);\n            }\n            // REVERSE3 - Reverse top 3 items\n            0x53 =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 3 {\n                    return Err(VMError::StackUnderflow);\n                }\n                self.eval_stack.swap(len - 1, len - 3);\n            }\n            // REVERSE4 - Reverse top 4 items\n            0x54 =\u003e {\n                let len = self.eval_stack.len();\n                if len \u003c 4 {\n                    return Err(VMError::StackUnderflow);\n                }\n                self.eval_stack.swap(len - 1, len - 4);\n                self.eval_stack.swap(len - 2, len - 3);\n            }\n            // REVERSEN - Reverse top n items\n            0x55 =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let len = self.eval_stack.len();\n                if n \u003e len {\n                    return Err(VMError::StackUnderflow);\n                }\n                let start = len - n;\n                self.eval_stack[start..].reverse();\n            }\n            // INITSLOT - Initialize local and argument slots\n            0x57 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let local_count = ctx.script[ctx.ip] as usize;\n                let arg_count = ctx.script[ctx.ip + 1] as usize;\n                ctx.ip += 2;\n                self.local_slots = vec![StackItem::Null; local_count];\n                // Pop arguments from stack into argument slots\n                self.argument_slots = Vec::with_capacity(arg_count);\n                for _ in 0..arg_count {\n                    let arg = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                    self.argument_slots.push(arg);\n                }\n                self.argument_slots.reverse();\n            }\n            // LDLOC0-LDLOC6 - Load local variable 0-6\n            0x66..=0x6C =\u003e {\n                let idx = (op - 0x66) as usize;\n                let item = self\n                    .local_slots\n                    .get(idx)\n                    .cloned()\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(item);\n            }\n            // LDLOC_S - Load local variable (short form)\n            0x6D =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let idx = ctx.script[ctx.ip] as usize;\n                ctx.ip += 1;\n                let item = self\n                    .local_slots\n                    .get(idx)\n                    .cloned()\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(item);\n            }\n            // STLOC0-STLOC6 - Store local variable 0-6\n            0x6E..=0x72 =\u003e {\n                let val = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let idx = (op - 0x6E) as usize;\n                if idx \u003e= self.local_slots.len() {\n                    self.local_slots.resize(idx + 1, StackItem::Null);\n                }\n                self.local_slots[idx] = val;\n            }\n            // STLOC_S - Store local variable (short form)\n            0x73 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let idx = ctx.script[ctx.ip] as usize;\n                ctx.ip += 1;\n                let item = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                if idx \u003e= self.local_slots.len() {\n                    return Err(VMError::InvalidOperation);\n                }\n                self.local_slots[idx] = item;\n            }\n            // LDARG0-LDARG6 - Load argument 0-6\n            0x74..=0x79 =\u003e {\n                let idx = (op - 0x74) as usize;\n                let item = self\n                    .argument_slots\n                    .get(idx)\n                    .cloned()\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(item);\n            }\n            // LDARG - Load argument\n            0x7A =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let idx = ctx.script[ctx.ip] as usize;\n                ctx.ip += 1;\n                let item = self\n                    .argument_slots\n                    .get(idx)\n                    .cloned()\n                    .ok_or(VMError::InvalidOperation)?;\n                self.eval_stack.push(item);\n            }\n            // NOP\n            0x21 =\u003e {}\n            // ASSERT\n            0x39 =\u003e {\n                let cond = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                if !cond.to_bool() {\n                    self.state = VMState::Fault;\n                    return Err(VMError::InvalidOperation);\n                }\n            }\n            // JMP (1-byte offset)\n            0x22 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip = ((ctx.ip as isize - 1) + offset as isize) as usize;\n            }\n            // JMPIF (1-byte offset)\n            0x24 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let cond = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                if cond.to_bool() {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPIFNOT (1-byte offset)\n            0x26 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let cond = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                if !cond.to_bool() {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPEQ - Jump if equal\n            0x28 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a == b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPNE - Jump if not equal\n            0x2A =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a != b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPGT - Jump if greater than\n            0x2C =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a \u003e b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPGE - Jump if greater or equal\n            0x2E =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a \u003e= b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPLT - Jump if less than\n            0x30 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a \u003c b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // JMPLE - Jump if less or equal\n            0x32 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                ctx.ip += 1;\n                let b = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                let a = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)?;\n                if a \u003c= b {\n                    ctx.ip = ((ctx.ip as isize - 2) + offset as isize) as usize;\n                }\n            }\n            // CALL (1-byte offset)\n            0x34 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                let offset = ctx.script[ctx.ip] as i8;\n                let return_ip = ctx.ip + 1;\n                let target_ip = ((ctx.ip as isize - 1) + offset as isize) as usize;\n                let script = ctx.script.clone();\n                self.invocation_stack.push(ExecutionContext {\n                    script,\n                    ip: target_ip,\n                });\n                // Store return address (simplified)\n                self.eval_stack.push(StackItem::Pointer(return_ip as u32));\n            }\n            // SHA256\n            0xF0 =\u003e {\n                let data = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let bytes = match data {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    StackItem::Integer(i) =\u003e i.to_le_bytes().to_vec(),\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                let mut hasher = Sha256::new();\n                hasher.update(\u0026bytes);\n                let result = hasher.finalize().to_vec();\n                self.eval_stack.push(StackItem::ByteString(result));\n            }\n            // RIPEMD160\n            0xF1 =\u003e {\n                let data = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let bytes = match data {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    StackItem::Integer(i) =\u003e i.to_le_bytes().to_vec(),\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                let mut hasher = Ripemd160::new();\n                hasher.update(\u0026bytes);\n                let result = hasher.finalize().to_vec();\n                self.eval_stack.push(StackItem::ByteString(result));\n            }\n            // SHA256 + RIPEMD160 (Hash160)\n            0xF2 =\u003e {\n                let data = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let bytes = match data {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    StackItem::Integer(i) =\u003e i.to_le_bytes().to_vec(),\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                let sha_result = Sha256::digest(\u0026bytes);\n                let result = Ripemd160::digest(sha_result).to_vec();\n                self.eval_stack.push(StackItem::ByteString(result));\n            }\n            // CHECKSIG (ECDSA secp256k1)\n            0xF3 =\u003e {\n                let pubkey = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let sig = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let msg = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n\n                let pubkey_bytes = match pubkey {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                let sig_bytes = match sig {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                let msg_bytes = match msg {\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b,\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n\n                let result = VerifyingKey::from_sec1_bytes(\u0026pubkey_bytes)\n                    .map_err(|_| VMError::InvalidPublicKey)?;\n                let signature =\n                    Signature::from_slice(\u0026sig_bytes).map_err(|_| VMError::InvalidSignature)?;\n                let msg_hash = Sha256::digest(\u0026msg_bytes);\n\n                let verified = result.verify(\u0026msg_hash, \u0026signature).is_ok();\n                self.eval_stack.push(StackItem::Boolean(verified));\n            }\n            // SYSCALL\n            0x41 =\u003e {\n                let ctx = self\n                    .invocation_stack\n                    .last_mut()\n                    .ok_or(VMError::StackUnderflow)?;\n                // Read 4-byte syscall ID\n                let id = u32::from_le_bytes([\n                    ctx.script[ctx.ip],\n                    ctx.script[ctx.ip + 1],\n                    ctx.script[ctx.ip + 2],\n                    ctx.script[ctx.ip + 3],\n                ]);\n                ctx.ip += 4;\n                self.execute_syscall(id)?;\n            }\n            // NEWARRAY0 - Create empty array\n            0xC2 =\u003e {\n                self.eval_stack.push(StackItem::Array(Vec::new()));\n            }\n            // NEWARRAY - Create array with n elements\n            0xC3 =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let arr = vec![StackItem::Null; n];\n                self.eval_stack.push(StackItem::Array(arr));\n            }\n            // NEWSTRUCT0 - Create empty struct\n            0xC5 =\u003e {\n                self.eval_stack.push(StackItem::Struct(Vec::new()));\n            }\n            // NEWSTRUCT - Create struct with n elements\n            0xC6 =\u003e {\n                let n = self\n                    .eval_stack\n                    .pop()\n                    .and_then(|x| x.to_integer())\n                    .ok_or(VMError::StackUnderflow)? as usize;\n                let s = vec![StackItem::Null; n];\n                self.eval_stack.push(StackItem::Struct(s));\n            }\n            // NEWMAP - Create empty map\n            0xC8 =\u003e {\n                self.eval_stack.push(StackItem::Map(Vec::new()));\n            }\n            // SIZE - Get size of array/map/string\n            0xCA =\u003e {\n                let item = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let size = match \u0026item {\n                    StackItem::Array(a) | StackItem::Struct(a) =\u003e a.len(),\n                    StackItem::Map(m) =\u003e m.len(),\n                    StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b.len(),\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                self.eval_stack.push(StackItem::Integer(size as i128));\n            }\n            // PICKITEM - Get item from array/map\n            0xCE =\u003e {\n                let key = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let container = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let item = match (container, key) {\n                    (StackItem::Array(a), StackItem::Integer(i)) =\u003e a\n                        .get(i as usize)\n                        .cloned()\n                        .ok_or(VMError::InvalidOperation)?,\n                    (StackItem::Struct(s), StackItem::Integer(i)) =\u003e s\n                        .get(i as usize)\n                        .cloned()\n                        .ok_or(VMError::InvalidOperation)?,\n                    (StackItem::Map(m), k) =\u003e m\n                        .iter()\n                        .find(|(mk, _)| *mk == k)\n                        .map(|(_, v)| v.clone())\n                        .ok_or(VMError::InvalidOperation)?,\n                    _ =\u003e return Err(VMError::InvalidType),\n                };\n                self.eval_stack.push(item);\n            }\n            // SETITEM - Set item in array/map\n            0xD0 =\u003e {\n                let value = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let key = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let container = self.eval_stack.last_mut().ok_or(VMError::StackUnderflow)?;\n                match (container, key) {\n                    (StackItem::Array(a), StackItem::Integer(i)) =\u003e {\n                        let idx = i as usize;\n                        if idx \u003e= a.len() {\n                            return Err(VMError::InvalidOperation);\n                        }\n                        a[idx] = value;\n                    }\n                    (StackItem::Map(m), k) =\u003e {\n                        if let Some(entry) = m.iter_mut().find(|(mk, _)| *mk == k) {\n                            entry.1 = value;\n                        } else {\n                            m.push((k, value));\n                        }\n                    }\n                    _ =\u003e return Err(VMError::InvalidType),\n                }\n            }\n            // APPEND - Append to array\n            0xCF =\u003e {\n                let item = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let container = self.eval_stack.last_mut().ok_or(VMError::StackUnderflow)?;\n                match container {\n                    StackItem::Array(a) =\u003e a.push(item),\n                    _ =\u003e return Err(VMError::InvalidType),\n                }\n            }\n            // REMOVE - Remove from array/map\n            0xD2 =\u003e {\n                let key = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                let container = self.eval_stack.last_mut().ok_or(VMError::StackUnderflow)?;\n                match (container, key) {\n                    (StackItem::Array(a), StackItem::Integer(i)) =\u003e {\n                        let idx = i as usize;\n                        if idx \u003e= a.len() {\n                            return Err(VMError::InvalidOperation);\n                        }\n                        a.remove(idx);\n                    }\n                    (StackItem::Map(m), k) =\u003e {\n                        m.retain(|(mk, _)| *mk != k);\n                    }\n                    _ =\u003e return Err(VMError::InvalidType),\n                }\n            }\n            // RET\n            0x40 =\u003e {\n                self.invocation_stack\n                    .pop()\n                    .ok_or(VMError::InvalidOperation)?;\n                if self.invocation_stack.is_empty() {\n                    self.state = VMState::Halt;\n                }\n            }\n            _ =\u003e return Err(VMError::InvalidOpcode(op)),\n        }\n        Ok(())\n    }\n\n    fn execute_syscall(\u0026mut self, id: u32) -\u003e Result\u003c(), VMError\u003e {\n        match id {\n            syscall::SYSTEM_RUNTIME_LOG =\u003e {\n                let msg = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                if let StackItem::ByteString(b) = msg {\n                    if let Ok(s) = String::from_utf8(b) {\n                        self.logs.push(s);\n                    }\n                }\n                Ok(())\n            }\n            syscall::SYSTEM_RUNTIME_NOTIFY =\u003e {\n                let item = self.eval_stack.pop().ok_or(VMError::StackUnderflow)?;\n                self.notifications.push(item);\n                Ok(())\n            }\n            syscall::SYSTEM_RUNTIME_GETTIME =\u003e {\n                // Return a mock timestamp for zkVM\n                self.eval_stack.push(StackItem::Integer(0));\n                Ok(())\n            }\n            _ =\u003e Err(VMError::UnknownSyscall(id)),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_push_operations() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert!(matches!(vm.state, VMState::Halt));\n        assert_eq!(vm.eval_stack.len(), 3);\n    }\n\n    #[test]\n    fn test_add_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x12, 0x13, 0x9E, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n\n    #[test]\n    fn test_sub_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x12, 0x9F, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n\n    #[test]\n    fn test_mul_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x13, 0x14, 0xA0, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(12)));\n    }\n\n    #[test]\n    fn test_comparison_lt() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x12, 0x15, 0xB5, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n}\n","traces":[{"line":92,"address":[1546784],"length":1,"stats":{"Line":34}},{"line":93,"address":[1546805,1546870],"length":1,"stats":{"Line":40}},{"line":139,"address":[2042925,2042919,2042128],"length":1,"stats":{"Line":45}},{"line":142,"address":[2042158],"length":1,"stats":{"Line":45}},{"line":143,"address":[1427489],"length":1,"stats":{"Line":45}},{"line":146,"address":[2004143],"length":1,"stats":{"Line":45}},{"line":147,"address":[1423973],"length":1,"stats":{"Line":45}},{"line":148,"address":[1996083],"length":1,"stats":{"Line":45}},{"line":150,"address":[1992704],"length":1,"stats":{"Line":45}},{"line":151,"address":[1440977],"length":1,"stats":{"Line":45}},{"line":152,"address":[1996258],"length":1,"stats":{"Line":45}},{"line":158,"address":[1996672],"length":1,"stats":{"Line":8}},{"line":159,"address":[1993265],"length":1,"stats":{"Line":8}},{"line":160,"address":[2043002],"length":1,"stats":{"Line":8}},{"line":161,"address":[1993353],"length":1,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[1993536],"length":1,"stats":{"Line":0}},{"line":169,"address":[1993553],"length":1,"stats":{"Line":0}},{"line":170,"address":[1618024],"length":1,"stats":{"Line":0}},{"line":174,"address":[1984517,1983984,1984523],"length":1,"stats":{"Line":0}},{"line":176,"address":[2068206],"length":1,"stats":{"Line":0}},{"line":177,"address":[1995364,1995342],"length":1,"stats":{"Line":0}},{"line":178,"address":[2068623,2068325],"length":1,"stats":{"Line":0}},{"line":180,"address":[2002724],"length":1,"stats":{"Line":0}},{"line":181,"address":[1995659],"length":1,"stats":{"Line":0}},{"line":185,"address":[1427168,1427428,1427402],"length":1,"stats":{"Line":45}},{"line":186,"address":[1999473,1999539],"length":1,"stats":{"Line":87}},{"line":187,"address":[1429313],"length":1,"stats":{"Line":0}},{"line":189,"address":[1423653],"length":1,"stats":{"Line":40}},{"line":190,"address":[1989001],"length":1,"stats":{"Line":42}},{"line":191,"address":[2000696],"length":1,"stats":{"Line":40}},{"line":194,"address":[2000752],"length":1,"stats":{"Line":40}},{"line":195,"address":[1981284,1981314,1981384,1981346],"length":1,"stats":{"Line":124}},{"line":198,"address":[2065566,2065501,2065527],"length":1,"stats":{"Line":67}},{"line":200,"address":[1992790],"length":1,"stats":{"Line":33}},{"line":201,"address":[2001082],"length":1,"stats":{"Line":1}},{"line":202,"address":[2039185,2039798],"length":1,"stats":{"Line":1}},{"line":203,"address":[2039720],"length":1,"stats":{"Line":0}},{"line":205,"address":[2066316],"length":1,"stats":{"Line":1}},{"line":208,"address":[1981511],"length":1,"stats":{"Line":40}},{"line":209,"address":[2039112],"length":1,"stats":{"Line":34}},{"line":210,"address":[1617336,1617403,1617456],"length":1,"stats":{"Line":74}},{"line":213,"address":[1981637],"length":1,"stats":{"Line":40}},{"line":214,"address":[1992973,1993046,1993021],"length":1,"stats":{"Line":74}},{"line":215,"address":[2001204],"length":1,"stats":{"Line":34}},{"line":216,"address":[1993080],"length":1,"stats":{"Line":3}},{"line":217,"address":[1981775],"length":1,"stats":{"Line":3}},{"line":221,"address":[1617522],"length":1,"stats":{"Line":40}},{"line":225,"address":[1989771],"length":1,"stats":{"Line":0}},{"line":226,"address":[2039494],"length":1,"stats":{"Line":0}},{"line":228,"address":[2039588],"length":1,"stats":{"Line":0}},{"line":231,"address":[1982068,1981810],"length":1,"stats":{"Line":37}},{"line":232,"address":[1993396],"length":1,"stats":{"Line":3}},{"line":233,"address":[2000539],"length":1,"stats":{"Line":3}},{"line":235,"address":[1982106],"length":1,"stats":{"Line":24}},{"line":238,"address":[1940611,1940579,1927312],"length":1,"stats":{"Line":40}},{"line":239,"address":[1966518],"length":1,"stats":{"Line":34}},{"line":240,"address":[1928781],"length":1,"stats":{"Line":3}},{"line":241,"address":[1614470,1547302],"length":1,"stats":{"Line":59}},{"line":242,"address":[2065077,2065157,2062829],"length":1,"stats":{"Line":58}},{"line":243,"address":[2038492],"length":1,"stats":{"Line":30}},{"line":245,"address":[1917250],"length":1,"stats":{"Line":4}},{"line":246,"address":[1928919],"length":1,"stats":{"Line":3}},{"line":249,"address":[1993668,1993701,1993739,2005625],"length":1,"stats":{"Line":6}},{"line":252,"address":[1940905,1929021,1928989],"length":1,"stats":{"Line":4}},{"line":253,"address":[2005731],"length":1,"stats":{"Line":2}},{"line":254,"address":[1940034,1940111],"length":1,"stats":{"Line":2}},{"line":255,"address":[1979222,1979268],"length":1,"stats":{"Line":4}},{"line":256,"address":[1979362],"length":1,"stats":{"Line":1}},{"line":258,"address":[1933143,1933226,1933049],"length":1,"stats":{"Line":2}},{"line":259,"address":[1941552,1941439,1941373],"length":1,"stats":{"Line":2}},{"line":260,"address":[1921955],"length":1,"stats":{"Line":1}},{"line":264,"address":[1917522,1917560,1917489,1930089],"length":1,"stats":{"Line":3}},{"line":267,"address":[1909658,1922185,1909626],"length":1,"stats":{"Line":2}},{"line":268,"address":[1559743],"length":1,"stats":{"Line":1}},{"line":269,"address":[2006640],"length":1,"stats":{"Line":0}},{"line":271,"address":[1941062,1940941,1940829],"length":1,"stats":{"Line":2}},{"line":272,"address":[1560117,1560025,1560088],"length":1,"stats":{"Line":2}},{"line":273,"address":[1941103,1941149],"length":1,"stats":{"Line":2}},{"line":274,"address":[1941243],"length":1,"stats":{"Line":1}},{"line":276,"address":[1922848,1922754,1922931],"length":1,"stats":{"Line":0}},{"line":277,"address":[1934280,1934393,1934214],"length":1,"stats":{"Line":0}},{"line":278,"address":[1922972],"length":1,"stats":{"Line":0}},{"line":282,"address":[1909726,1923190,1909797,1909759],"length":1,"stats":{"Line":6}},{"line":285,"address":[1942662,1929271,1929239],"length":1,"stats":{"Line":4}},{"line":286,"address":[1942784],"length":1,"stats":{"Line":2}},{"line":287,"address":[1942930],"length":1,"stats":{"Line":1}},{"line":289,"address":[1942826],"length":1,"stats":{"Line":2}},{"line":290,"address":[1923412,1923511,1923568],"length":1,"stats":{"Line":4}},{"line":291,"address":[1941963],"length":1,"stats":{"Line":2}},{"line":295,"address":[1942045,1928299,1928332,1928370],"length":1,"stats":{"Line":3}},{"line":298,"address":[1928356,1928324,1942029],"length":1,"stats":{"Line":2}},{"line":299,"address":[2007895],"length":1,"stats":{"Line":1}},{"line":300,"address":[1942295],"length":1,"stats":{"Line":1}},{"line":302,"address":[2008232,2007972,2008084],"length":1,"stats":{"Line":2}},{"line":303,"address":[1924150,1924093,1924014],"length":1,"stats":{"Line":2}},{"line":304,"address":[1561513],"length":1,"stats":{"Line":1}},{"line":307,"address":[1921288,1935475],"length":1,"stats":{"Line":6}},{"line":310,"address":[1921499,1921432,1921461,1935736],"length":1,"stats":{"Line":13}},{"line":313,"address":[1910173,1910141,1924408],"length":1,"stats":{"Line":9}},{"line":315,"address":[1935855],"length":1,"stats":{"Line":3}},{"line":319,"address":[1562053,1548366,1548329],"length":1,"stats":{"Line":20}},{"line":322,"address":[1921586],"length":1,"stats":{"Line":26}},{"line":323,"address":[1967939,1967907,1982210],"length":1,"stats":{"Line":21}},{"line":324,"address":[1936223,1936182,1936276],"length":1,"stats":{"Line":26}},{"line":327,"address":[1924813],"length":1,"stats":{"Line":28}},{"line":328,"address":[2009054,2009140,2009086],"length":1,"stats":{"Line":19}},{"line":329,"address":[1982686],"length":1,"stats":{"Line":5}},{"line":330,"address":[1982947],"length":1,"stats":{"Line":10}},{"line":334,"address":[1928964,1943880,1929005],"length":1,"stats":{"Line":15}},{"line":337,"address":[1757504,1757488],"length":1,"stats":{"Line":18}},{"line":338,"address":[1994732,2009608,1994700],"length":1,"stats":{"Line":15}},{"line":339,"address":[1925660,1925754,1925701],"length":1,"stats":{"Line":12}},{"line":342,"address":[1765440,1765424],"length":1,"stats":{"Line":18}},{"line":343,"address":[1945226,1945172,1945140],"length":1,"stats":{"Line":12}},{"line":344,"address":[1945380],"length":1,"stats":{"Line":6}},{"line":345,"address":[2010345],"length":1,"stats":{"Line":6}},{"line":349,"address":[1968326,1968285,1983806],"length":1,"stats":{"Line":17}},{"line":352,"address":[1918532],"length":1,"stats":{"Line":18}},{"line":353,"address":[1945694,1930181,1930213],"length":1,"stats":{"Line":16}},{"line":354,"address":[1944898,1944939,1944992],"length":1,"stats":{"Line":14}},{"line":357,"address":[1983977],"length":1,"stats":{"Line":21}},{"line":358,"address":[1945962,1945930,1946016],"length":1,"stats":{"Line":14}},{"line":359,"address":[1946170],"length":1,"stats":{"Line":7}},{"line":360,"address":[1926943],"length":1,"stats":{"Line":7}},{"line":364,"address":[1934900,1918774,1918815],"length":1,"stats":{"Line":12}},{"line":367,"address":[1968413],"length":1,"stats":{"Line":15}},{"line":368,"address":[1968462,1968494,1984580],"length":1,"stats":{"Line":11}},{"line":369,"address":[1938552,1938593,1938646],"length":1,"stats":{"Line":8}},{"line":372,"address":[1689312,1689328],"length":1,"stats":{"Line":14}},{"line":373,"address":[1946720,1946752,1946806],"length":1,"stats":{"Line":10}},{"line":374,"address":[2011672],"length":1,"stats":{"Line":5}},{"line":375,"address":[1947144],"length":1,"stats":{"Line":3}},{"line":377,"address":[1564861,1565010],"length":1,"stats":{"Line":4}},{"line":378,"address":[1947311],"length":1,"stats":{"Line":3}},{"line":382,"address":[1922424,1939204,1922383],"length":1,"stats":{"Line":8}},{"line":385,"address":[1995206],"length":1,"stats":{"Line":13}},{"line":386,"address":[1918951,1918983,1935764],"length":1,"stats":{"Line":10}},{"line":387,"address":[1565523,1565471,1565434],"length":1,"stats":{"Line":10}},{"line":390,"address":[1565389],"length":1,"stats":{"Line":14}},{"line":391,"address":[1946646,1946560,1946592],"length":1,"stats":{"Line":8}},{"line":392,"address":[1946808],"length":1,"stats":{"Line":4}},{"line":393,"address":[1939848],"length":1,"stats":{"Line":2}},{"line":395,"address":[1939723,1939877],"length":1,"stats":{"Line":3}},{"line":396,"address":[1928703],"length":1,"stats":{"Line":3}},{"line":400,"address":[1549189,1566073,1549226],"length":1,"stats":{"Line":6}},{"line":403,"address":[1995391],"length":1,"stats":{"Line":9}},{"line":404,"address":[1919168,1936644,1919136],"length":1,"stats":{"Line":6}},{"line":405,"address":[1566381,1566329,1566292],"length":1,"stats":{"Line":6}},{"line":408,"address":[1684608,1684624],"length":1,"stats":{"Line":8}},{"line":409,"address":[1936912,1936966,1936880],"length":1,"stats":{"Line":4}},{"line":410,"address":[1929232],"length":1,"stats":{"Line":2}},{"line":411,"address":[2013539],"length":1,"stats":{"Line":2}},{"line":413,"address":[2013455],"length":1,"stats":{"Line":1}},{"line":414,"address":[1986878],"length":1,"stats":{"Line":1}},{"line":418,"address":[1911482,1929392,1911441],"length":1,"stats":{"Line":6}},{"line":421,"address":[1758736,1758752],"length":1,"stats":{"Line":9}},{"line":422,"address":[1911433,1911465,1929376],"length":1,"stats":{"Line":6}},{"line":423,"address":[1949149,1949108,1949202],"length":1,"stats":{"Line":6}},{"line":426,"address":[1807360,1807344],"length":1,"stats":{"Line":9}},{"line":427,"address":[1948060,1948146,1948092],"length":1,"stats":{"Line":6}},{"line":428,"address":[1987428],"length":1,"stats":{"Line":3}},{"line":429,"address":[1937757],"length":1,"stats":{"Line":1}},{"line":431,"address":[1941327,1941286,1941380],"length":1,"stats":{"Line":4}},{"line":432,"address":[1929914],"length":1,"stats":{"Line":2}},{"line":433,"address":[1930052,1929966,1929998],"length":1,"stats":{"Line":4}},{"line":434,"address":[1567453],"length":1,"stats":{"Line":2}},{"line":438,"address":[1941571,1922979,1922938],"length":1,"stats":{"Line":6}},{"line":441,"address":[1804480,1804464],"length":1,"stats":{"Line":9}},{"line":442,"address":[1969234,1969202,1987827],"length":1,"stats":{"Line":6}},{"line":443,"address":[1950016,1949975,1950069],"length":1,"stats":{"Line":6}},{"line":446,"address":[1770192,1770176],"length":1,"stats":{"Line":9}},{"line":447,"address":[1941791,1941823,1941877],"length":1,"stats":{"Line":6}},{"line":448,"address":[2014903],"length":1,"stats":{"Line":3}},{"line":449,"address":[1988320],"length":1,"stats":{"Line":1}},{"line":451,"address":[2015074,2015033,2015127],"length":1,"stats":{"Line":4}},{"line":452,"address":[1942093],"length":1,"stats":{"Line":2}},{"line":453,"address":[1568160,1568079,1568119],"length":1,"stats":{"Line":4}},{"line":454,"address":[1942369],"length":1,"stats":{"Line":2}},{"line":458,"address":[1996044,1996003,2015318],"length":1,"stats":{"Line":6}},{"line":461,"address":[1686880,1686864],"length":1,"stats":{"Line":9}},{"line":462,"address":[1988694,1969387,1969419],"length":1,"stats":{"Line":6}},{"line":463,"address":[1950936,1950883,1950842],"length":1,"stats":{"Line":6}},{"line":466,"address":[1755680,1755664],"length":1,"stats":{"Line":9}},{"line":467,"address":[2015624,2015538,2015570],"length":1,"stats":{"Line":6}},{"line":468,"address":[1568802],"length":1,"stats":{"Line":3}},{"line":472,"address":[1931484,1931525,1951152],"length":1,"stats":{"Line":2}},{"line":475,"address":[1931427],"length":1,"stats":{"Line":3}},{"line":476,"address":[1969572,1969604,1989232],"length":1,"stats":{"Line":2}},{"line":477,"address":[1989517,1989570,1989476],"length":1,"stats":{"Line":2}},{"line":480,"address":[1758880,1758864],"length":1,"stats":{"Line":3}},{"line":481,"address":[1950418,1950332,1950364],"length":1,"stats":{"Line":2}},{"line":482,"address":[1951604],"length":1,"stats":{"Line":1}},{"line":486,"address":[1912222,1932202,1912181],"length":1,"stats":{"Line":2}},{"line":489,"address":[1550004],"length":1,"stats":{"Line":3}},{"line":490,"address":[1943498,1923485,1923517],"length":1,"stats":{"Line":2}},{"line":491,"address":[1940412,1940318,1940359],"length":1,"stats":{"Line":4}},{"line":494,"address":[1761664,1761648],"length":1,"stats":{"Line":3}},{"line":495,"address":[1940396,1940342,1940310],"length":1,"stats":{"Line":2}},{"line":496,"address":[1951241,1951294,1951200],"length":1,"stats":{"Line":2}},{"line":499,"address":[1805520,1805536],"length":1,"stats":{"Line":4}},{"line":500,"address":[1990328,1990414,1990360],"length":1,"stats":{"Line":4}},{"line":501,"address":[2017184],"length":1,"stats":{"Line":2}},{"line":505,"address":[1996558,1996599,2017331],"length":1,"stats":{"Line":2}},{"line":508,"address":[1809664,1809648],"length":1,"stats":{"Line":3}},{"line":509,"address":[1931846,1931878,1952611],"length":1,"stats":{"Line":2}},{"line":510,"address":[1933312,1933263],"length":1,"stats":{"Line":2}},{"line":511,"address":[2017480],"length":1,"stats":{"Line":1}},{"line":512,"address":[1990865,1990922],"length":1,"stats":{"Line":0}},{"line":513,"address":[1933340],"length":1,"stats":{"Line":0}},{"line":515,"address":[1952802],"length":1,"stats":{"Line":0}},{"line":517,"address":[1952860],"length":1,"stats":{"Line":1}},{"line":521,"address":[1932039,1932080,1952945],"length":1,"stats":{"Line":4}},{"line":524,"address":[1996686],"length":1,"stats":{"Line":6}},{"line":525,"address":[1920463,1941329,1920431],"length":1,"stats":{"Line":4}},{"line":526,"address":[1570745],"length":1,"stats":{"Line":2}},{"line":527,"address":[1991424],"length":1,"stats":{"Line":2}},{"line":531,"address":[1912777,1933909,1912736],"length":1,"stats":{"Line":4}},{"line":534,"address":[1767824,1767840],"length":1,"stats":{"Line":6}},{"line":535,"address":[1996920,2018085,1996952],"length":1,"stats":{"Line":4}},{"line":536,"address":[1571189],"length":1,"stats":{"Line":2}},{"line":537,"address":[1934292],"length":1,"stats":{"Line":2}},{"line":541,"address":[1550737,1550774,1571512],"length":1,"stats":{"Line":4}},{"line":544,"address":[1815792,1815808],"length":1,"stats":{"Line":6}},{"line":545,"address":[1550729,1571496,1550769],"length":1,"stats":{"Line":4}},{"line":546,"address":[1571643],"length":1,"stats":{"Line":2}},{"line":547,"address":[1571898],"length":1,"stats":{"Line":2}},{"line":551,"address":[1954311,1932635,1932594],"length":1,"stats":{"Line":4}},{"line":554,"address":[1755008,1754992],"length":1,"stats":{"Line":6}},{"line":555,"address":[1921018,1942695,1920986],"length":1,"stats":{"Line":4}},{"line":556,"address":[2019147],"length":1,"stats":{"Line":2}},{"line":557,"address":[1992800],"length":1,"stats":{"Line":2}},{"line":561,"address":[1924644,1946597,1924603],"length":1,"stats":{"Line":10}},{"line":564,"address":[1806192,1806208],"length":1,"stats":{"Line":15}},{"line":565,"address":[1932771,1932803,1954757],"length":1,"stats":{"Line":10}},{"line":566,"address":[1946919,1946825,1946866],"length":1,"stats":{"Line":10}},{"line":569,"address":[1946768],"length":1,"stats":{"Line":15}},{"line":570,"address":[1953985,1953953,1954039],"length":1,"stats":{"Line":10}},{"line":571,"address":[1943633],"length":1,"stats":{"Line":5}},{"line":575,"address":[1954264,1931924,1931965],"length":1,"stats":{"Line":4}},{"line":578,"address":[1817344,1817328],"length":1,"stats":{"Line":6}},{"line":579,"address":[1551285,1572919,1551245],"length":1,"stats":{"Line":4}},{"line":580,"address":[1943932,1943973,1944026],"length":1,"stats":{"Line":4}},{"line":583,"address":[1771472,1771488],"length":1,"stats":{"Line":6}},{"line":584,"address":[1954484,1954516,1954570],"length":1,"stats":{"Line":4}},{"line":585,"address":[2020468],"length":1,"stats":{"Line":2}},{"line":589,"address":[1997894,1997853,2020539],"length":1,"stats":{"Line":8}},{"line":592,"address":[1803760,1803744],"length":1,"stats":{"Line":12}},{"line":593,"address":[1932101,1932133,1954779],"length":1,"stats":{"Line":8}},{"line":594,"address":[1956104,1956157,1956063],"length":1,"stats":{"Line":8}},{"line":597,"address":[2020710],"length":1,"stats":{"Line":12}},{"line":598,"address":[2020759,2020791,2020845],"length":1,"stats":{"Line":8}},{"line":599,"address":[1956295],"length":1,"stats":{"Line":4}},{"line":603,"address":[1932335,1932294,1955326],"length":1,"stats":{"Line":4}},{"line":606,"address":[1774464,1774448],"length":1,"stats":{"Line":6}},{"line":607,"address":[1971422,1971454,1994446],"length":1,"stats":{"Line":4}},{"line":608,"address":[1955648,1955554,1955595],"length":1,"stats":{"Line":4}},{"line":611,"address":[1956537],"length":1,"stats":{"Line":6}},{"line":612,"address":[1937130,1937098,1937184],"length":1,"stats":{"Line":4}},{"line":613,"address":[1948650],"length":1,"stats":{"Line":2}},{"line":617,"address":[1956881,1933429],"length":1,"stats":{"Line":1}},{"line":618,"address":[1956011,1956527,1956074],"length":1,"stats":{"Line":2}},{"line":619,"address":[1949299,1949226],"length":1,"stats":{"Line":2}},{"line":623,"address":[1938122,1914085],"length":1,"stats":{"Line":0}},{"line":624,"address":[1995876,1995939,1996396],"length":1,"stats":{"Line":0}},{"line":625,"address":[1996211,1996304],"length":1,"stats":{"Line":0}},{"line":629,"address":[1957303,1932677],"length":1,"stats":{"Line":2}},{"line":631,"address":[1576021],"length":1,"stats":{"Line":2}},{"line":635,"address":[1925816,1925775,1950500],"length":1,"stats":{"Line":2}},{"line":638,"address":[1971990],"length":1,"stats":{"Line":3}},{"line":639,"address":[1552184,1552224,1576159],"length":1,"stats":{"Line":2}},{"line":640,"address":[1939310],"length":1,"stats":{"Line":1}},{"line":644,"address":[1934136,1934177,1958866],"length":1,"stats":{"Line":0}},{"line":647,"address":[1772720,1772736],"length":1,"stats":{"Line":0}},{"line":648,"address":[1914672,1939362,1914640],"length":1,"stats":{"Line":0}},{"line":649,"address":[2023839,2023892,2023798],"length":1,"stats":{"Line":0}},{"line":652,"address":[1950861],"length":1,"stats":{"Line":0}},{"line":653,"address":[1958078,1958132,1958046],"length":1,"stats":{"Line":0}},{"line":654,"address":[2024030],"length":1,"stats":{"Line":0}},{"line":658,"address":[1933322,1933281,1958360],"length":1,"stats":{"Line":0}},{"line":661,"address":[1803520,1803504],"length":1,"stats":{"Line":0}},{"line":662,"address":[1933305,1958344,1933273],"length":1,"stats":{"Line":0}},{"line":663,"address":[1940181,1940140,1940234],"length":1,"stats":{"Line":0}},{"line":666,"address":[1760784,1760800],"length":1,"stats":{"Line":0}},{"line":667,"address":[1577092,1577132,1577173],"length":1,"stats":{"Line":0}},{"line":668,"address":[1948260],"length":1,"stats":{"Line":0}},{"line":672,"address":[1915059,1940446,1915018],"length":1,"stats":{"Line":0}},{"line":675,"address":[1815312,1815328],"length":1,"stats":{"Line":0}},{"line":676,"address":[1915010,1915042,1940430],"length":1,"stats":{"Line":0}},{"line":677,"address":[1960056],"length":1,"stats":{"Line":0}},{"line":681,"address":[1915203,1940643,1915244],"length":1,"stats":{"Line":6}},{"line":684,"address":[1934634],"length":1,"stats":{"Line":9}},{"line":685,"address":[1923083,1923115,1948515],"length":1,"stats":{"Line":6}},{"line":686,"address":[1948853,1948800,1948759],"length":1,"stats":{"Line":6}},{"line":689,"address":[1749184,1749200],"length":1,"stats":{"Line":9}},{"line":690,"address":[1960351,1960383,1960437],"length":1,"stats":{"Line":6}},{"line":691,"address":[2025295],"length":1,"stats":{"Line":3}},{"line":695,"address":[1999580,1999621,2025370],"length":1,"stats":{"Line":6}},{"line":698,"address":[1972915],"length":1,"stats":{"Line":9}},{"line":699,"address":[1923268,1949050,1923300],"length":1,"stats":{"Line":6}},{"line":700,"address":[1999031,1998990,1999084],"length":1,"stats":{"Line":6}},{"line":703,"address":[1754320,1754336],"length":1,"stats":{"Line":9}},{"line":704,"address":[1941484,1941430,1941398],"length":1,"stats":{"Line":6}},{"line":705,"address":[1578558],"length":1,"stats":{"Line":3}},{"line":709,"address":[2025905,1999806,1999765],"length":1,"stats":{"Line":6}},{"line":712,"address":[1759824,1759840],"length":1,"stats":{"Line":9}},{"line":713,"address":[1935053,1935085,1961185],"length":1,"stats":{"Line":6}},{"line":714,"address":[1942035,1941941,1941982],"length":1,"stats":{"Line":6}},{"line":717,"address":[1762752,1762768],"length":1,"stats":{"Line":9}},{"line":718,"address":[1999549,1999603,1999517],"length":1,"stats":{"Line":6}},{"line":719,"address":[1579077],"length":1,"stats":{"Line":3}},{"line":723,"address":[1950120,1923556],"length":1,"stats":{"Line":1}},{"line":724,"address":[2000059,1999986],"length":1,"stats":{"Line":2}},{"line":728,"address":[1579435,1553455],"length":1,"stats":{"Line":1}},{"line":729,"address":[1961223,1961729,1961160],"length":1,"stats":{"Line":3}},{"line":731,"address":[1579988,1579927],"length":1,"stats":{"Line":2}},{"line":735,"address":[1973540,2000908],"length":1,"stats":{"Line":1}},{"line":736,"address":[1943494,1943557,1944061],"length":1,"stats":{"Line":2}},{"line":738,"address":[1943902,1943837],"length":1,"stats":{"Line":2}},{"line":742,"address":[1923988],"length":1,"stats":{"Line":4}},{"line":743,"address":[1916122],"length":1,"stats":{"Line":4}},{"line":744,"address":[2028360],"length":1,"stats":{"Line":2}},{"line":746,"address":[1952093,1952000],"length":1,"stats":{"Line":6}},{"line":750,"address":[1973729],"length":1,"stats":{"Line":2}},{"line":751,"address":[1553802],"length":1,"stats":{"Line":2}},{"line":752,"address":[1952227],"length":1,"stats":{"Line":1}},{"line":754,"address":[2028576,2028504,2028688],"length":1,"stats":{"Line":2}},{"line":755,"address":[2028605],"length":1,"stats":{"Line":1}},{"line":759,"address":[1927633,1955837,1927592],"length":1,"stats":{"Line":2}},{"line":761,"address":[1553841],"length":1,"stats":{"Line":1}},{"line":762,"address":[1916223],"length":1,"stats":{"Line":3}},{"line":763,"address":[1927584,1927616,1955821],"length":1,"stats":{"Line":2}},{"line":764,"address":[1952551],"length":1,"stats":{"Line":1}},{"line":765,"address":[2002280],"length":1,"stats":{"Line":1}},{"line":766,"address":[1956044],"length":1,"stats":{"Line":1}},{"line":768,"address":[2028969,2029143,2028901],"length":1,"stats":{"Line":0}},{"line":769,"address":[1964356],"length":1,"stats":{"Line":0}},{"line":773,"address":[1935953,1964468,1935994],"length":1,"stats":{"Line":2}},{"line":775,"address":[2000567],"length":1,"stats":{"Line":1}},{"line":776,"address":[1820160,1820176],"length":1,"stats":{"Line":3}},{"line":777,"address":[1927769,1956276,1927801],"length":1,"stats":{"Line":2}},{"line":778,"address":[1956430],"length":1,"stats":{"Line":1}},{"line":779,"address":[2002735],"length":1,"stats":{"Line":1}},{"line":780,"address":[1964675],"length":1,"stats":{"Line":1}},{"line":782,"address":[1945232,1945164,1945398],"length":1,"stats":{"Line":0}},{"line":783,"address":[1953203],"length":1,"stats":{"Line":0}},{"line":787,"address":[1927872],"length":1,"stats":{"Line":2}},{"line":788,"address":[1936070],"length":1,"stats":{"Line":2}},{"line":789,"address":[1963894],"length":1,"stats":{"Line":1}},{"line":791,"address":[2003075,2003195,2003003],"length":1,"stats":{"Line":2}},{"line":792,"address":[2003112],"length":1,"stats":{"Line":1}},{"line":796,"address":[1935053],"length":1,"stats":{"Line":3}},{"line":797,"address":[2000834],"length":1,"stats":{"Line":3}},{"line":801,"address":[1936195],"length":1,"stats":{"Line":2}},{"line":802,"address":[2000921],"length":1,"stats":{"Line":2}},{"line":803,"address":[2003239],"length":1,"stats":{"Line":1}},{"line":805,"address":[1964080,1964148],"length":1,"stats":{"Line":2}},{"line":809,"address":[1935331,1964217,1935290],"length":1,"stats":{"Line":2}},{"line":811,"address":[2000944],"length":1,"stats":{"Line":1}},{"line":812,"address":[1928097],"length":1,"stats":{"Line":3}},{"line":813,"address":[2003337,1974418,1974450],"length":1,"stats":{"Line":2}},{"line":814,"address":[1953795],"length":1,"stats":{"Line":1}},{"line":815,"address":[2003524],"length":1,"stats":{"Line":1}},{"line":816,"address":[1965464],"length":1,"stats":{"Line":1}},{"line":818,"address":[1953909,1953841],"length":1,"stats":{"Line":0}},{"line":822,"address":[1928249],"length":1,"stats":{"Line":2}},{"line":826,"address":[1928268],"length":1,"stats":{"Line":1}},{"line":827,"address":[1916978],"length":1,"stats":{"Line":1}},{"line":828,"address":[1954043],"length":1,"stats":{"Line":1}},{"line":830,"address":[1946268,1946132,1946200],"length":1,"stats":{"Line":0}},{"line":831,"address":[1965733,1965785],"length":1,"stats":{"Line":0}},{"line":835,"address":[1928313],"length":1,"stats":{"Line":1}},{"line":836,"address":[1936511],"length":1,"stats":{"Line":1}},{"line":837,"address":[1957832],"length":1,"stats":{"Line":1}},{"line":839,"address":[1957776,1957869],"length":1,"stats":{"Line":0}},{"line":843,"address":[1924934],"length":1,"stats":{"Line":1}},{"line":844,"address":[1936556],"length":1,"stats":{"Line":1}},{"line":845,"address":[1966208],"length":1,"stats":{"Line":1}},{"line":847,"address":[1954645,1954790,1954552],"length":1,"stats":{"Line":0}},{"line":848,"address":[1966334,1966411],"length":1,"stats":{"Line":0}},{"line":852,"address":[1965486,1935629,1935670],"length":1,"stats":{"Line":2}},{"line":854,"address":[1974675],"length":1,"stats":{"Line":1}},{"line":855,"address":[1815120,1815136],"length":1,"stats":{"Line":3}},{"line":856,"address":[1928485,1928517,1958334],"length":1,"stats":{"Line":2}},{"line":857,"address":[1583963],"length":1,"stats":{"Line":1}},{"line":858,"address":[2004793],"length":1,"stats":{"Line":1}},{"line":859,"address":[1947251],"length":1,"stats":{"Line":1}},{"line":861,"address":[1584016,1584082,1584118],"length":1,"stats":{"Line":0}},{"line":862,"address":[2031496],"length":1,"stats":{"Line":0}},{"line":866,"address":[2001501,2001468,2001539,2031555],"length":1,"stats":{"Line":3}},{"line":869,"address":[1935781,1965795,1935749],"length":1,"stats":{"Line":2}},{"line":870,"address":[1584252],"length":1,"stats":{"Line":1}},{"line":871,"address":[1965964,1966073],"length":1,"stats":{"Line":1}},{"line":872,"address":[2005183,2005246,2005319],"length":1,"stats":{"Line":2}},{"line":873,"address":[1955644,1955564],"length":1,"stats":{"Line":1}},{"line":875,"address":[1955762,1955813],"length":1,"stats":{"Line":1}},{"line":876,"address":[1959897,1959370],"length":1,"stats":{"Line":2}},{"line":877,"address":[2032480,2032594,2032310],"length":1,"stats":{"Line":2}},{"line":878,"address":[1967962],"length":1,"stats":{"Line":1}},{"line":880,"address":[1959570],"length":1,"stats":{"Line":1}},{"line":883,"address":[1978611,1978681],"length":1,"stats":{"Line":7}},{"line":884,"address":[1978692,1980365,1980543],"length":1,"stats":{"Line":2}},{"line":885,"address":[1980482,1980436,1980381,1980670,1980572],"length":1,"stats":{"Line":4}},{"line":887,"address":[1616206],"length":1,"stats":{"Line":1}},{"line":889,"address":[2038012,2038044,2038140],"length":1,"stats":{"Line":3}},{"line":890,"address":[2000230],"length":1,"stats":{"Line":0}},{"line":894,"address":[1928746,1928784,1928713,1959940],"length":1,"stats":{"Line":3}},{"line":897,"address":[1925314,1956500,1925346],"length":1,"stats":{"Line":2}},{"line":898,"address":[2006318],"length":1,"stats":{"Line":1}},{"line":899,"address":[1960314,1960093],"length":1,"stats":{"Line":1}},{"line":900,"address":[1948941,1949129,1948837,1948895,1949031],"length":1,"stats":{"Line":4}},{"line":902,"address":[1960176],"length":1,"stats":{"Line":1}},{"line":904,"address":[1968503,1968407,1968375],"length":1,"stats":{"Line":3}},{"line":905,"address":[2033393],"length":1,"stats":{"Line":0}},{"line":908,"address":[1986554,1986631],"length":1,"stats":{"Line":7}},{"line":909,"address":[1990914,1990801,1990067],"length":1,"stats":{"Line":0}},{"line":910,"address":[2063930,2063994],"length":1,"stats":{"Line":0}},{"line":911,"address":[1987762,1987667],"length":1,"stats":{"Line":0}},{"line":912,"address":[2064178],"length":1,"stats":{"Line":0}},{"line":914,"address":[1980087,1980149,1980309,1979892],"length":1,"stats":{"Line":0}},{"line":918,"address":[1555121,1586083,1555090,1555158],"length":1,"stats":{"Line":0}},{"line":921,"address":[1928895,1960644,1928863],"length":1,"stats":{"Line":0}},{"line":922,"address":[1968942],"length":1,"stats":{"Line":0}},{"line":923,"address":[1949686,1949501],"length":1,"stats":{"Line":0}},{"line":924,"address":[1969187,1969045],"length":1,"stats":{"Line":0}},{"line":925,"address":[1961189,1961272],"length":1,"stats":{"Line":0}},{"line":926,"address":[2007646],"length":1,"stats":{"Line":0}},{"line":928,"address":[1586825,1586889,1587060,1586706],"length":1,"stats":{"Line":0}},{"line":931,"address":[1997389,1997169],"length":1,"stats":{"Line":8}},{"line":932,"address":[1979159,1978952],"length":1,"stats":{"Line":2}},{"line":933,"address":[2036636,2036682,2036581,2036772,2036870],"length":1,"stats":{"Line":8}},{"line":935,"address":[1614861],"length":1,"stats":{"Line":2}},{"line":937,"address":[2063364,2063236,2063268],"length":1,"stats":{"Line":5}},{"line":938,"address":[1990670],"length":1,"stats":{"Line":1}},{"line":942,"address":[1928963,1961721,1928996,1929034],"length":1,"stats":{"Line":0}},{"line":945,"address":[1936156,1968841,1936124],"length":1,"stats":{"Line":0}},{"line":946,"address":[2008099],"length":1,"stats":{"Line":0}},{"line":947,"address":[1969010,1969231],"length":1,"stats":{"Line":0}},{"line":948,"address":[2008494,2008306,2008202,2008260,2008396],"length":1,"stats":{"Line":0}},{"line":950,"address":[1950645],"length":1,"stats":{"Line":0}},{"line":952,"address":[1969148,1969116,1969244],"length":1,"stats":{"Line":0}},{"line":953,"address":[1958870],"length":1,"stats":{"Line":0}},{"line":959,"address":[1975373,2008697],"length":1,"stats":{"Line":1}},{"line":960,"address":[1587974,1588035],"length":1,"stats":{"Line":2}},{"line":961,"address":[1951362],"length":1,"stats":{"Line":1}},{"line":962,"address":[1959257],"length":1,"stats":{"Line":1}},{"line":967,"address":[1936452,1936381,1936414,1969895],"length":1,"stats":{"Line":3}},{"line":970,"address":[2009015,1975542,1975574],"length":1,"stats":{"Line":2}},{"line":971,"address":[1970001],"length":1,"stats":{"Line":1}},{"line":972,"address":[1588280,1588375],"length":1,"stats":{"Line":1}},{"line":976,"address":[1925979,1926017,1925946,1959609],"length":1,"stats":{"Line":3}},{"line":979,"address":[2002275,2002307,2035897],"length":1,"stats":{"Line":2}},{"line":980,"address":[1588509],"length":1,"stats":{"Line":2}},{"line":981,"address":[1959759,1959944],"length":1,"stats":{"Line":2}},{"line":982,"address":[1971415,1971557],"length":1,"stats":{"Line":2}},{"line":983,"address":[1960192,1960127,1960324],"length":1,"stats":{"Line":5}},{"line":984,"address":[1589110,1589009],"length":1,"stats":{"Line":1}},{"line":989,"address":[1589147,1555796,1555728,1555759],"length":1,"stats":{"Line":0}},{"line":992,"address":[1926128,1960347,1926096],"length":1,"stats":{"Line":0}},{"line":993,"address":[1971029],"length":1,"stats":{"Line":0}},{"line":994,"address":[1971073,1971258],"length":1,"stats":{"Line":0}},{"line":995,"address":[1971271,1971129],"length":1,"stats":{"Line":0}},{"line":996,"address":[1964504,1964370,1964305],"length":1,"stats":{"Line":0}},{"line":997,"address":[1971520,1971642,1971577],"length":1,"stats":{"Line":0}},{"line":1002,"address":[1936789,1936827,1971679,1936756],"length":1,"stats":{"Line":0}},{"line":1005,"address":[1937821,1937853,1972703],"length":1,"stats":{"Line":0}},{"line":1006,"address":[1972825],"length":1,"stats":{"Line":0}},{"line":1007,"address":[1961269,1961495],"length":1,"stats":{"Line":0}},{"line":1008,"address":[1961524,1961415,1961456],"length":1,"stats":{"Line":0}},{"line":1011,"address":[1972958],"length":1,"stats":{"Line":0}},{"line":1012,"address":[2011135,2011204,2011103],"length":1,"stats":{"Line":0}},{"line":1013,"address":[1590538,1590501,1590590],"length":1,"stats":{"Line":0}},{"line":1016,"address":[2011391],"length":1,"stats":{"Line":0}},{"line":1017,"address":[2038134,2038048,2038080],"length":1,"stats":{"Line":0}},{"line":1018,"address":[1590835,1590719],"length":1,"stats":{"Line":0}},{"line":1019,"address":[2038305,2038401],"length":1,"stats":{"Line":0}},{"line":1024,"address":[1937921,1973726,1937954,1937992],"length":1,"stats":{"Line":0}},{"line":1027,"address":[1972670,1936906,1936938],"length":1,"stats":{"Line":0}},{"line":1028,"address":[1972792],"length":1,"stats":{"Line":0}},{"line":1029,"address":[2038806,2038580],"length":1,"stats":{"Line":0}},{"line":1030,"address":[2038767,2038835,2038726],"length":1,"stats":{"Line":0}},{"line":1033,"address":[1954477],"length":1,"stats":{"Line":0}},{"line":1034,"address":[2038819,2038718,2038750],"length":1,"stats":{"Line":0}},{"line":1035,"address":[1962800,1962759,1962853],"length":1,"stats":{"Line":0}},{"line":1038,"address":[1807456,1807440],"length":1,"stats":{"Line":0}},{"line":1039,"address":[1962751,1962837,1962783],"length":1,"stats":{"Line":0}},{"line":1040,"address":[1973543,1973659],"length":1,"stats":{"Line":0}},{"line":1041,"address":[1955216,1955120],"length":1,"stats":{"Line":0}},{"line":1046,"address":[1929941,1966557,1929870,1929903],"length":1,"stats":{"Line":0}},{"line":1049,"address":[2002775,2002807,2039421],"length":1,"stats":{"Line":0}},{"line":1050,"address":[1973799],"length":1,"stats":{"Line":0}},{"line":1051,"address":[1975109,1974883],"length":1,"stats":{"Line":0}},{"line":1052,"address":[2013125,2013166,2013234],"length":1,"stats":{"Line":0}},{"line":1055,"address":[1770992,1771008],"length":1,"stats":{"Line":0}},{"line":1056,"address":[1955634,1955533,1955565],"length":1,"stats":{"Line":0}},{"line":1057,"address":[1974420,1974367,1974326],"length":1,"stats":{"Line":0}},{"line":1060,"address":[1974269],"length":1,"stats":{"Line":0}},{"line":1061,"address":[1963790,1963844,1963758],"length":1,"stats":{"Line":0}},{"line":1062,"address":[1956215,1956102],"length":1,"stats":{"Line":0}},{"line":1063,"address":[1975708,1975612],"length":1,"stats":{"Line":0}},{"line":1068,"address":[1592820,1556243,1556280,1556212],"length":1,"stats":{"Line":0}},{"line":1071,"address":[1975721,1938196,1938228],"length":1,"stats":{"Line":0}},{"line":1072,"address":[1967667],"length":1,"stats":{"Line":0}},{"line":1073,"address":[1964513,1964287],"length":1,"stats":{"Line":0}},{"line":1074,"address":[1967857,1967898,1967966],"length":1,"stats":{"Line":0}},{"line":1077,"address":[2040680],"length":1,"stats":{"Line":0}},{"line":1078,"address":[1975017,1974985,1975086],"length":1,"stats":{"Line":0}},{"line":1079,"address":[1593518,1593466,1593429],"length":1,"stats":{"Line":0}},{"line":1082,"address":[1759168,1759152],"length":1,"stats":{"Line":0}},{"line":1083,"address":[2014490,2014544,2014458],"length":1,"stats":{"Line":0}},{"line":1084,"address":[1593760,1593647],"length":1,"stats":{"Line":0}},{"line":1085,"address":[1593669,1593765],"length":1,"stats":{"Line":0}},{"line":1090,"address":[1937289,1937327,1975701,1937256],"length":1,"stats":{"Line":0}},{"line":1093,"address":[1975685,1937313,1937281],"length":1,"stats":{"Line":0}},{"line":1094,"address":[1968671],"length":1,"stats":{"Line":0}},{"line":1095,"address":[1965291,1965517],"length":1,"stats":{"Line":0}},{"line":1096,"address":[2015174,2015242,2015133],"length":1,"stats":{"Line":0}},{"line":1099,"address":[1968804],"length":1,"stats":{"Line":0}},{"line":1100,"address":[1976021,1975989,1976090],"length":1,"stats":{"Line":0}},{"line":1101,"address":[2015564,2015470,2015511],"length":1,"stats":{"Line":0}},{"line":1104,"address":[1977317],"length":1,"stats":{"Line":0}},{"line":1105,"address":[1969190,1969222,1969276],"length":1,"stats":{"Line":0}},{"line":1106,"address":[1976671,1976558],"length":1,"stats":{"Line":0}},{"line":1107,"address":[1966020,1966116],"length":1,"stats":{"Line":0}},{"line":1112,"address":[1556454,1594768,1556485,1556522],"length":1,"stats":{"Line":0}},{"line":1115,"address":[2042433,2003150,2003182],"length":1,"stats":{"Line":0}},{"line":1116,"address":[1976811],"length":1,"stats":{"Line":0}},{"line":1117,"address":[1978121,1977895],"length":1,"stats":{"Line":0}},{"line":1118,"address":[1969865,1969974,1969906],"length":1,"stats":{"Line":0}},{"line":1121,"address":[1806384,1806400],"length":1,"stats":{"Line":0}},{"line":1122,"address":[1969857,1969889,1969958],"length":1,"stats":{"Line":0}},{"line":1123,"address":[1970243,1970296,1970202],"length":1,"stats":{"Line":0}},{"line":1126,"address":[1966721],"length":1,"stats":{"Line":0}},{"line":1127,"address":[2016466,2016552,2016498],"length":1,"stats":{"Line":0}},{"line":1128,"address":[1595708,1595595],"length":1,"stats":{"Line":0}},{"line":1129,"address":[1967120,1967024],"length":1,"stats":{"Line":0}},{"line":1134,"address":[1937539,1937577,1937506,1977709],"length":1,"stats":{"Line":0}},{"line":1137,"address":[1978733,1938571,1938603],"length":1,"stats":{"Line":0}},{"line":1138,"address":[1967255],"length":1,"stats":{"Line":0}},{"line":1139,"address":[1967369,1967299],"length":1,"stats":{"Line":0}},{"line":1140,"address":[1595938,1596213,1595988],"length":1,"stats":{"Line":0}},{"line":1141,"address":[1978020],"length":1,"stats":{"Line":0}},{"line":1142,"address":[1979090],"length":1,"stats":{"Line":0}},{"line":1147,"address":[2017276],"length":1,"stats":{"Line":0}},{"line":1151,"address":[1967637,1927071],"length":1,"stats":{"Line":1}},{"line":1152,"address":[1596741,1596680,1596403],"length":1,"stats":{"Line":2}},{"line":1153,"address":[1971521,1971736,1971460],"length":1,"stats":{"Line":2}},{"line":1154,"address":[1971683,1971410],"length":1,"stats":{"Line":0}},{"line":1155,"address":[2044211],"length":1,"stats":{"Line":0}},{"line":1157,"address":[1971717],"length":1,"stats":{"Line":1}},{"line":1158,"address":[1960518],"length":1,"stats":{"Line":1}},{"line":1159,"address":[1980033],"length":1,"stats":{"Line":1}},{"line":1160,"address":[1972074],"length":1,"stats":{"Line":1}},{"line":1164,"address":[1919327,1961064],"length":1,"stats":{"Line":0}},{"line":1165,"address":[2045434,2045711,2045772],"length":1,"stats":{"Line":0}},{"line":1166,"address":[1961524,1961739,1961463],"length":1,"stats":{"Line":0}},{"line":1167,"address":[1961686,1961413],"length":1,"stats":{"Line":0}},{"line":1168,"address":[1980822],"length":1,"stats":{"Line":0}},{"line":1170,"address":[1973032],"length":1,"stats":{"Line":0}},{"line":1171,"address":[1961833],"length":1,"stats":{"Line":0}},{"line":1172,"address":[1980308],"length":1,"stats":{"Line":0}},{"line":1173,"address":[1598522],"length":1,"stats":{"Line":0}},{"line":1177,"address":[1981867,1938959],"length":1,"stats":{"Line":0}},{"line":1178,"address":[1962834,1962895,1962557],"length":1,"stats":{"Line":0}},{"line":1179,"address":[1599212,1599492,1599273],"length":1,"stats":{"Line":0}},{"line":1180,"address":[2046920,2047193],"length":1,"stats":{"Line":0}},{"line":1181,"address":[2020233],"length":1,"stats":{"Line":0}},{"line":1183,"address":[1963035],"length":1,"stats":{"Line":0}},{"line":1184,"address":[1599586],"length":1,"stats":{"Line":0}},{"line":1185,"address":[1963293],"length":1,"stats":{"Line":0}},{"line":1189,"address":[1939103,1983083],"length":1,"stats":{"Line":0}},{"line":1190,"address":[1600200,1600308,1604024],"length":1,"stats":{"Line":0}},{"line":1191,"address":[1975312,1972085,1972205],"length":1,"stats":{"Line":0}},{"line":1193,"address":[1601137,1600984],"length":1,"stats":{"Line":0}},{"line":1194,"address":[1964760,1964702,1964816],"length":1,"stats":{"Line":0}},{"line":1195,"address":[1984161],"length":1,"stats":{"Line":0}},{"line":1197,"address":[1601227,1601380],"length":1,"stats":{"Line":0}},{"line":1198,"address":[1984547,1984433,1984491],"length":1,"stats":{"Line":0}},{"line":1199,"address":[1972804],"length":1,"stats":{"Line":0}},{"line":1201,"address":[1983692,1983539],"length":1,"stats":{"Line":0}},{"line":1202,"address":[2049380,2049438,2049494],"length":1,"stats":{"Line":0}},{"line":1203,"address":[1965159],"length":1,"stats":{"Line":0}},{"line":1206,"address":[2049737,2051209,2049667,2049621,2049526],"length":1,"stats":{"Line":0}},{"line":1207,"address":[1976841,1976760],"length":1,"stats":{"Line":0}},{"line":1208,"address":[2023422,2024550],"length":1,"stats":{"Line":0}},{"line":1210,"address":[2050382],"length":1,"stats":{"Line":0}},{"line":1212,"address":[1974105],"length":1,"stats":{"Line":0}},{"line":1213,"address":[1985911],"length":1,"stats":{"Line":0}},{"line":1217,"address":[2025558,1977343,1977414,1977376],"length":1,"stats":{"Line":3}},{"line":1220,"address":[2004008,2052150,2003976],"length":1,"stats":{"Line":2}},{"line":1222,"address":[1604654],"length":1,"stats":{"Line":1}},{"line":1223,"address":[1987568],"length":1,"stats":{"Line":1}},{"line":1224,"address":[1976005,1976104],"length":1,"stats":{"Line":1}},{"line":1225,"address":[1987796,1987678,1987733],"length":1,"stats":{"Line":2}},{"line":1226,"address":[1604618,1604559,1604763],"length":1,"stats":{"Line":2}},{"line":1228,"address":[1976415,1976534,1976341],"length":1,"stats":{"Line":2}},{"line":1229,"address":[1968659,1968531],"length":1,"stats":{"Line":2}},{"line":1233,"address":[1977460],"length":1,"stats":{"Line":2}},{"line":1237,"address":[1605051,1557605,1557568],"length":1,"stats":{"Line":12}},{"line":1239,"address":[1557502],"length":1,"stats":{"Line":5}},{"line":1240,"address":[1818880,1818864],"length":1,"stats":{"Line":16}},{"line":1241,"address":[1976645,1927961,1927993],"length":1,"stats":{"Line":12}},{"line":1242,"address":[1968895],"length":1,"stats":{"Line":6}},{"line":1243,"address":[1980255],"length":1,"stats":{"Line":6}},{"line":1247,"address":[1557650],"length":1,"stats":{"Line":0}},{"line":1251,"address":[1605319,1557882,1557845],"length":1,"stats":{"Line":0}},{"line":1253,"address":[2004475],"length":1,"stats":{"Line":0}},{"line":1254,"address":[1557800],"length":1,"stats":{"Line":0}},{"line":1255,"address":[1987476,1938845,1938813],"length":1,"stats":{"Line":0}},{"line":1256,"address":[1969166],"length":1,"stats":{"Line":0}},{"line":1257,"address":[1987662],"length":1,"stats":{"Line":0}},{"line":1261,"address":[2004652],"length":1,"stats":{"Line":0}},{"line":1265,"address":[1928445,1977187],"length":1,"stats":{"Line":4}},{"line":1266,"address":[1988949,1989090,1989134,1989112,1989159],"length":1,"stats":{"Line":7}},{"line":1267,"address":[1977514,1977762,1977539],"length":1,"stats":{"Line":6}},{"line":1268,"address":[1989415,1989172],"length":1,"stats":{"Line":0}},{"line":1269,"address":[2053985,2053774,2053906,2053796],"length":1,"stats":{"Line":0}},{"line":1270,"address":[1989027],"length":1,"stats":{"Line":1}},{"line":1272,"address":[1989297],"length":1,"stats":{"Line":3}},{"line":1276,"address":[1939149,1988407],"length":1,"stats":{"Line":1}},{"line":1277,"address":[1606442,1606394,1609691],"length":1,"stats":{"Line":2}},{"line":1278,"address":[1606995,1606710],"length":1,"stats":{"Line":2}},{"line":1279,"address":[2055851,2055471,2055551,2055420,2055183],"length":1,"stats":{"Line":5}},{"line":1280,"address":[1971174],"length":1,"stats":{"Line":1}},{"line":1282,"address":[1607709,1607888,1607339,1607433,1607481,1607548],"length":1,"stats":{"Line":4}},{"line":1283,"address":[1979689,1979926,1979977,1980057,1980225],"length":1,"stats":{"Line":0}},{"line":1284,"address":[1971984],"length":1,"stats":{"Line":0}},{"line":1286,"address":[2029891,2029500,2029614,2029737,2029945,2029646],"length":1,"stats":{"Line":0}},{"line":1287,"address":[2030156,2028465,2030827,2030207,2030287,2030070],"length":1,"stats":{"Line":0}},{"line":1289,"address":[1608667],"length":1,"stats":{"Line":0}},{"line":1290,"address":[1751824,1751841],"length":1,"stats":{"Line":0}},{"line":1291,"address":[1972383,1972844,1972596,1972687,1972564,1973267],"length":1,"stats":{"Line":0}},{"line":1292,"address":[1982045],"length":1,"stats":{"Line":0}},{"line":1294,"address":[2057229],"length":1,"stats":{"Line":0}},{"line":1298,"address":[1920845,1973722],"length":1,"stats":{"Line":1}},{"line":1299,"address":[1976334,1973963,1973900],"length":1,"stats":{"Line":2}},{"line":1300,"address":[2060459,2058435,2058522],"length":1,"stats":{"Line":2}},{"line":1301,"address":[1985863,1986043],"length":1,"stats":{"Line":2}},{"line":1302,"address":[1993335],"length":1,"stats":{"Line":1}},{"line":1303,"address":[2059147],"length":1,"stats":{"Line":1}},{"line":1304,"address":[1982927,1982851],"length":1,"stats":{"Line":2}},{"line":1305,"address":[1611118],"length":1,"stats":{"Line":1}},{"line":1307,"address":[1983051,1983296,1982948,1983119],"length":1,"stats":{"Line":0}},{"line":1309,"address":[1982673],"length":1,"stats":{"Line":0}},{"line":1310,"address":[1611481,1610853],"length":1,"stats":{"Line":0}},{"line":1311,"address":[1611638,1611870],"length":1,"stats":{"Line":0}},{"line":1313,"address":[1611700,1612013],"length":1,"stats":{"Line":0}},{"line":1316,"address":[1986014],"length":1,"stats":{"Line":0}},{"line":1321,"address":[1920989,1976373],"length":1,"stats":{"Line":1}},{"line":1322,"address":[2034219,2034135,2034637],"length":1,"stats":{"Line":2}},{"line":1323,"address":[2034448],"length":1,"stats":{"Line":1}},{"line":1324,"address":[1995367],"length":1,"stats":{"Line":0}},{"line":1325,"address":[1995438],"length":1,"stats":{"Line":1}},{"line":1330,"address":[1940621,1996602],"length":1,"stats":{"Line":1}},{"line":1331,"address":[2034955,2035858,2034868],"length":1,"stats":{"Line":2}},{"line":1332,"address":[1977757,1977583],"length":1,"stats":{"Line":2}},{"line":1333,"address":[1997377],"length":1,"stats":{"Line":1}},{"line":1334,"address":[1985839],"length":1,"stats":{"Line":1}},{"line":1335,"address":[1977959,1978026],"length":1,"stats":{"Line":2}},{"line":1336,"address":[2062259],"length":1,"stats":{"Line":1}},{"line":1338,"address":[1997529,1997581],"length":1,"stats":{"Line":0}},{"line":1340,"address":[2062003],"length":1,"stats":{"Line":0}},{"line":1341,"address":[1985755],"length":1,"stats":{"Line":0}},{"line":1343,"address":[1985616],"length":1,"stats":{"Line":0}},{"line":1348,"address":[2005495,2005469,2005541,2062525],"length":1,"stats":{"Line":27}},{"line":1350,"address":[1978911,2035901,1978879,2036127],"length":1,"stats":{"Line":26}},{"line":1351,"address":[1997013,1997047],"length":1,"stats":{"Line":25}},{"line":1352,"address":[1986480],"length":1,"stats":{"Line":11}},{"line":1355,"address":[1990210],"length":1,"stats":{"Line":4}},{"line":1357,"address":[1937256],"length":1,"stats":{"Line":17}},{"line":1360,"address":[2067791,2067735,2066512],"length":1,"stats":{"Line":1}},{"line":1361,"address":[1982351],"length":1,"stats":{"Line":1}},{"line":1363,"address":[1982782,1982446,1982882],"length":1,"stats":{"Line":0}},{"line":1364,"address":[2002482],"length":1,"stats":{"Line":0}},{"line":1365,"address":[2002565,2002854,2002766],"length":1,"stats":{"Line":0}},{"line":1366,"address":[2040982,2041100],"length":1,"stats":{"Line":0}},{"line":1369,"address":[2067327],"length":1,"stats":{"Line":0}},{"line":1372,"address":[2002112,2002217,2001023],"length":1,"stats":{"Line":0}},{"line":1373,"address":[1995153],"length":1,"stats":{"Line":0}},{"line":1374,"address":[2068133],"length":1,"stats":{"Line":0}},{"line":1378,"address":[2002204],"length":1,"stats":{"Line":0}},{"line":1379,"address":[2066964],"length":1,"stats":{"Line":0}},{"line":1381,"address":[1982408],"length":1,"stats":{"Line":1}}],"covered":441,"coverable":683},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","lib.rs"],"content":"//! # Neo VM Core\n//!\n//! Core virtual machine implementation for Neo zkVM.\n//!\n//! ## Features\n//!\n//! - Full Neo N3 opcode support\n//! - Gas metering\n//! - Execution tracing for proof generation\n//! - Cryptographic operations (SHA256, RIPEMD160, ECDSA)\n//!\n//! ## Quick Start\n//!\n//! ```rust\n//! use neo_vm_core::{NeoVM, VMState, StackItem};\n//!\n//! // Create a VM with 1M gas limit\n//! let mut vm = NeoVM::new(1_000_000);\n//!\n//! // Load a script: 2 + 3 = 5\n//! vm.load_script(vec![0x12, 0x13, 0x9E, 0x40]).unwrap();\n//!\n//! // Execute until halt\n//! while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n//!     vm.execute_next().unwrap();\n//! }\n//!\n//! // Get the result\n//! assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n//! ```\n//!\n//! ## Script Format\n//!\n//! Scripts are byte vectors containing Neo N3 opcodes. Common operations:\n//!\n//! - `0x10` - `0x20`: Push integers 0-16\n//! - `0x0F`: Push -1\n//! - `0x0B`: Push Null\n//! - `0x9E`: ADD\n//! - `0x9F`: SUB\n//! - `0xA0`: MUL\n//! - `0xA1`: DIV\n//! - `0xA2`: MOD\n//! - `0x40`: RET (return)\n//!\n//! ## Example: Simple Arithmetic\n//!\n//! ```rust\n//! use neo_vm_core::{NeoVM, VMState, StackItem};\n//!\n//! // Compute 5 * 4 = 20\n//! let script = vec![0x15, 0x14, 0xA0, 0x40];\n//!\n//! let mut vm = NeoVM::new(1_000_000);\n//! vm.load_script(script).unwrap();\n//!\n//! while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n//!     vm.execute_next().unwrap();\n//! }\n//!\n//! assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(20)));\n//! ```\n//!\n//! ## Example: Hash Computation\n//!\n//! ```rust\n//! use neo_vm_core::{NeoVM, VMState, StackItem};\n//!\n//! // Compute SHA256 of \"hello\"\n//! let script = vec![\n//!     0x0C, 0x05, b'h', b'e', b'l', b'l', b'o', // PUSHDATA1 \"hello\"\n//!     0xF0, // SHA256\n//!     0x40, // RET\n//! ];\n//!\n//! let mut vm = NeoVM::new(1_000_000);\n//! vm.load_script(script).unwrap();\n//!\n//! while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n//!     vm.execute_next().unwrap();\n//! }\n//!\n//! if let Some(StackItem::ByteString(hash)) = vm.eval_stack.pop() {\n//!     assert_eq!(hash.len(), 32); // SHA256 produces 32 bytes\n//! }\n//! ```\n//!\n//! ## Example: Gas Metering\n//!\n//! ```rust,ignore\n//! use neo_vm_core::{NeoVM, VMState};\n//!\n//! let mut vm = NeoVM::new(10); // Very low gas limit\n//!\n//! // Create a loop that will exhaust gas\n//! let script = vec![0x22, 0xFE]; // Infinite loop: JMP -2\n//! vm.load_script(script).unwrap();\n//!\n//! // Execute until out of gas\n//! while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n//!     let _ = vm.execute_next();\n//! }\n//!\n//! assert!(matches!(vm.state, VMState::Fault));\n//! assert!(vm.gas_consumed \u003e 0);\n//! ```\n//!\n//! ## Example: Error Handling\n//!\n//! The VM correctly handles errors like division by zero:\n//!\n//! ```rust,ignore\n//! use neo_vm_core::{NeoVM, VMState};\n//!\n//! let mut vm = NeoVM::new(1_000_000);\n//!\n//! // Division by zero should cause a fault\n//! let script = vec![0x15, 0x10, 0xA1, 0x40]; // 5, 0, DIV\n//! vm.load_script(script).unwrap();\n//!\n//! while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n//!     let _ = vm.execute_next();\n//! }\n//!\n//! assert!(matches!(vm.state, VMState::Fault));\n//! ```\n//!\n\npub mod engine;\npub mod native;\npub mod opcode;\npub mod stack_item;\npub mod storage;\n\npub use engine::{NeoVM, VMError, VMState};\npub use native::{CryptoLib, NativeContract, NativeRegistry, StdLib};\npub use opcode::OpCode;\npub use stack_item::StackItem;\npub use storage::{MemoryStorage, StorageBackend, StorageContext, TrackedStorage};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","native.rs"],"content":"//! Native Contract Implementations\n//!\n//! Built-in contracts that provide core blockchain functionality.\n\nuse crate::stack_item::StackItem;\nuse sha2::{Digest, Sha256};\n\n/// Maximum input size for native contract functions (1MB)\nconst MAX_INPUT_SIZE: usize = 1024 * 1024;\n\n/// Native contract interface\npub trait NativeContract {\n    fn hash(\u0026self) -\u003e [u8; 20];\n    fn invoke(\u0026self, method: \u0026str, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e;\n}\n\n/// StdLib native contract - utility functions\n#[derive(Debug, Default)]\npub struct StdLib;\n\nimpl StdLib {\n    #[inline]\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    #[inline]\n    fn serialize(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if args.is_empty() {\n            return Err(\"serialize requires 1 argument\".to_string());\n        }\n        let bytes = bincode::serialize(\u0026args[0]).map_err(|e| e.to_string())?;\n        Ok(StackItem::ByteString(bytes))\n    }\n\n    fn deserialize(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(bytes)) = args.first() {\n            if bytes.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"deserialize input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            bincode::deserialize(bytes).map_err(|e| format!(\"deserialize failed: {}\", e))\n        } else {\n            Err(\"deserialize requires ByteString argument\".to_string())\n        }\n    }\n\n    #[inline]\n    fn json_serialize(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if args.is_empty() {\n            return Err(\"jsonSerialize requires 1 argument\".to_string());\n        }\n        let json = serde_json::to_string(\u0026args[0]).map_err(|e| e.to_string())?;\n        if json.len() \u003e MAX_INPUT_SIZE {\n            return Err(format!(\n                \"jsonSerialize output exceeds maximum size of {} bytes\",\n                MAX_INPUT_SIZE\n            ));\n        }\n        Ok(StackItem::ByteString(json.into_bytes()))\n    }\n}\n\nimpl StdLib {\n    #[inline]\n    fn base64_encode(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(bytes)) = args.first() {\n            if bytes.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"base64Encode input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            use base64::{engine::general_purpose::STANDARD, Engine};\n            let encoded = STANDARD.encode(bytes);\n            Ok(StackItem::ByteString(encoded.into_bytes()))\n        } else {\n            Err(\"base64Encode requires ByteString\".to_string())\n        }\n    }\n\n    #[inline]\n    fn base64_decode(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(bytes)) = args.first() {\n            if bytes.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"base64Decode input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            use base64::{engine::general_purpose::STANDARD, Engine};\n            let s = String::from_utf8_lossy(bytes);\n            let decoded = STANDARD.decode(s.as_ref()).map_err(|e| e.to_string())?;\n            Ok(StackItem::ByteString(decoded))\n        } else {\n            Err(\"base64Decode requires ByteString\".to_string())\n        }\n    }\n}\n\nimpl StdLib {\n    #[inline]\n    fn itoa(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::Integer(n)) = args.first() {\n            let base = args\n                .get(1)\n                .and_then(|i| {\n                    if let StackItem::Integer(b) = i {\n                        Some(*b as u32)\n                    } else {\n                        None\n                    }\n                })\n                .unwrap_or(10);\n            if base != 2 \u0026\u0026 base != 10 \u0026\u0026 base != 16 {\n                return Err(format!(\n                    \"Unsupported base {}. Supported bases: 2 (binary), 10 (decimal), 16 (hexadecimal)\",\n                    base\n                ));\n            }\n            let s = match base {\n                2 =\u003e format!(\"{:b}\", n),\n                10 =\u003e format!(\"{}\", n),\n                16 =\u003e format!(\"{:x}\", n),\n                _ =\u003e unreachable!(),\n            };\n            Ok(StackItem::ByteString(s.into_bytes()))\n        } else {\n            Err(\"itoa requires Integer\".to_string())\n        }\n    }\n\n    #[inline]\n    fn atoi(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(bytes)) = args.first() {\n            if bytes.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"atoi input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            let s = String::from_utf8_lossy(bytes);\n            let base = args\n                .get(1)\n                .and_then(|i| {\n                    if let StackItem::Integer(b) = i {\n                        Some(*b as u32)\n                    } else {\n                        None\n                    }\n                })\n                .unwrap_or(10);\n            if base != 2 \u0026\u0026 base != 10 \u0026\u0026 base != 16 {\n                return Err(format!(\n                    \"Unsupported base {}. Supported bases: 2 (binary), 10 (decimal), 16 (hexadecimal)\",\n                    base\n                ));\n            }\n            let n = i128::from_str_radix(s.trim(), base).map_err(|e| e.to_string())?;\n            Ok(StackItem::Integer(n))\n        } else {\n            Err(\"atoi requires ByteString\".to_string())\n        }\n    }\n}\n\nimpl NativeContract for StdLib {\n    #[inline]\n    fn hash(\u0026self) -\u003e [u8; 20] {\n        [\n            0xac, 0xce, 0x6f, 0xd8, 0x0d, 0x44, 0xe1, 0xa3, 0x92, 0x6d, 0xe2, 0x1c, 0xcf, 0x30,\n            0x96, 0x9a, 0x22, 0x4b, 0xc0, 0x6b,\n        ]\n    }\n\n    #[inline]\n    fn invoke(\u0026self, method: \u0026str, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        match method {\n            \"serialize\" =\u003e self.serialize(args),\n            \"deserialize\" =\u003e self.deserialize(args),\n            \"jsonSerialize\" =\u003e self.json_serialize(args),\n            \"base64Encode\" =\u003e self.base64_encode(args),\n            \"base64Decode\" =\u003e self.base64_decode(args),\n            \"itoa\" =\u003e self.itoa(args),\n            \"atoi\" =\u003e self.atoi(args),\n            _ =\u003e Err(format!(\"Unknown method: {}\", method)),\n        }\n    }\n}\n\n/// CryptoLib native contract - cryptographic functions\n#[derive(Debug, Default)]\npub struct CryptoLib;\n\nimpl CryptoLib {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl NativeContract for CryptoLib {\n    #[inline]\n    fn hash(\u0026self) -\u003e [u8; 20] {\n        [\n            0x72, 0x6c, 0xb6, 0xe0, 0xcd, 0x8b, 0x0a, 0xc3, 0x3c, 0xe1, 0xde, 0xc0, 0xd4, 0x7e,\n            0x5c, 0x3c, 0x4a, 0x6b, 0x8a, 0x0d,\n        ]\n    }\n\n    #[inline]\n    fn invoke(\u0026self, method: \u0026str, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        match method {\n            \"sha256\" =\u003e self.sha256(args),\n            \"ripemd160\" =\u003e self.ripemd160(args),\n            \"verifyWithECDsa\" =\u003e self.verify_ecdsa(args),\n            _ =\u003e Err(format!(\"Unknown method: {}\", method)),\n        }\n    }\n}\n\nimpl CryptoLib {\n    #[inline]\n    fn sha256(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(data)) = args.first() {\n            if data.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"sha256 input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            let hash = Sha256::digest(data);\n            Ok(StackItem::ByteString(hash.to_vec()))\n        } else {\n            Err(\"sha256 requires ByteString\".to_string())\n        }\n    }\n\n    #[inline]\n    fn ripemd160(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        if let Some(StackItem::ByteString(data)) = args.first() {\n            if data.len() \u003e MAX_INPUT_SIZE {\n                return Err(format!(\n                    \"ripemd160 input exceeds maximum size of {} bytes\",\n                    MAX_INPUT_SIZE\n                ));\n            }\n            use ripemd::Ripemd160;\n            let hash = Ripemd160::digest(data);\n            Ok(StackItem::ByteString(hash.to_vec()))\n        } else {\n            Err(\"ripemd160 requires ByteString\".to_string())\n        }\n    }\n\n    #[inline]\n    fn verify_ecdsa(\u0026self, args: Vec\u003cStackItem\u003e) -\u003e Result\u003cStackItem, String\u003e {\n        use k256::ecdsa::{signature::Verifier, Signature, VerifyingKey};\n\n        if args.len() \u003c 2 {\n            return Err(\"verify_ecdsa requires at least 2 arguments\".to_string());\n        }\n\n        let message = match \u0026args[0] {\n            StackItem::ByteString(msg) =\u003e msg.as_slice(),\n            _ =\u003e return Err(\"verify_ecdsa: first argument must be ByteString\".to_string()),\n        };\n\n        let signature = match \u0026args[1] {\n            StackItem::ByteString(sig) =\u003e sig.as_slice(),\n            _ =\u003e return Err(\"verify_ecdsa: second argument must be ByteString\".to_string()),\n        };\n\n        let pubkey = if args.len() \u003e= 3 {\n            match \u0026args[2] {\n                StackItem::ByteString(pk) =\u003e pk.as_slice(),\n                _ =\u003e return Err(\"verify_ecdsa: third argument must be ByteString\".to_string()),\n            }\n        } else {\n            return Err(\"verify_ecdsa: public key required\".to_string());\n        };\n\n        if message.len() \u003e MAX_INPUT_SIZE {\n            return Err(format!(\n                \"verify_ecdsa message exceeds maximum size of {} bytes\",\n                MAX_INPUT_SIZE\n            ));\n        }\n\n        let signature = Signature::from_slice(signature)\n            .map_err(|_| \"Invalid ECDSA signature format\".to_string())?;\n        let verifying_key = VerifyingKey::from_sec1_bytes(pubkey)\n            .map_err(|_| \"Invalid public key format\".to_string())?;\n\n        Ok(StackItem::Boolean(\n            verifying_key.verify(message, \u0026signature).is_ok(),\n        ))\n    }\n}\n\n/// Native contract registry\n#[derive(Default)]\npub struct NativeRegistry {\n    stdlib: StdLib,\n    cryptolib: CryptoLib,\n}\n\nimpl NativeRegistry {\n    #[inline]\n    pub fn new() -\u003e Self {\n        Self {\n            stdlib: StdLib::new(),\n            cryptolib: CryptoLib::new(),\n        }\n    }\n\n    #[inline]\n    pub fn invoke(\n        \u0026self,\n        hash: \u0026[u8; 20],\n        method: \u0026str,\n        args: Vec\u003cStackItem\u003e,\n    ) -\u003e Result\u003cStackItem, String\u003e {\n        if *hash == self.stdlib.hash() {\n            self.stdlib.invoke(method, args)\n        } else if *hash == self.cryptolib.hash() {\n            self.cryptolib.invoke(method, args)\n        } else {\n            Err(\"Unknown native contract\".to_string())\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[1491216,1491798],"length":1,"stats":{"Line":1}},{"line":29,"address":[1491314,1491254],"length":1,"stats":{"Line":2}},{"line":30,"address":[1491756,1491352],"length":1,"stats":{"Line":0}},{"line":32,"address":[1892992,1893008],"length":1,"stats":{"Line":2}},{"line":33,"address":[1978340],"length":1,"stats":{"Line":1}},{"line":36,"address":[1971312,1971976],"length":1,"stats":{"Line":1}},{"line":37,"address":[1971562,1971971,1971422,1971350],"length":1,"stats":{"Line":3}},{"line":38,"address":[1971584],"length":1,"stats":{"Line":1}},{"line":39,"address":[1971744,1971639],"length":1,"stats":{"Line":0}},{"line":44,"address":[1910800,1910827],"length":1,"stats":{"Line":2}},{"line":46,"address":[1971528,1971922],"length":1,"stats":{"Line":0}},{"line":51,"address":[1414136,1414066,1413168],"length":1,"stats":{"Line":1}},{"line":52,"address":[1973942,1974010],"length":1,"stats":{"Line":2}},{"line":53,"address":[1414094,1413300],"length":1,"stats":{"Line":0}},{"line":55,"address":[1488105,1487348,1487285],"length":1,"stats":{"Line":2}},{"line":56,"address":[1413628,1413570],"length":1,"stats":{"Line":2}},{"line":57,"address":[1413879,1413693],"length":1,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[1487768,1487664],"length":1,"stats":{"Line":2}},{"line":68,"address":[1973104,1973885],"length":1,"stats":{"Line":1}},{"line":69,"address":[1973142,1973354,1973214,1973880],"length":1,"stats":{"Line":3}},{"line":70,"address":[1486640],"length":1,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[1412678],"length":1,"stats":{"Line":2}},{"line":78,"address":[1486737],"length":1,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[1485374,1485302,1485514,1486348],"length":1,"stats":{"Line":8}},{"line":87,"address":[1485536],"length":1,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[1950172,1950160],"length":1,"stats":{"Line":8}},{"line":96,"address":[1411985],"length":1,"stats":{"Line":2}},{"line":98,"address":[1972216,1973035],"length":1,"stats":{"Line":0}},{"line":105,"address":[1491194,1489760],"length":1,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[1976795,1976903],"length":1,"stats":{"Line":2}},{"line":109,"address":[1908960],"length":1,"stats":{"Line":4}},{"line":110,"address":[1962265,1962186],"length":1,"stats":{"Line":5}},{"line":111,"address":[1892954],"length":1,"stats":{"Line":3}},{"line":113,"address":[1892971],"length":1,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[1490184],"length":1,"stats":{"Line":1}},{"line":124,"address":[1416223,1416314],"length":1,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[1977276,1977557],"length":1,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[1488208,1489488,1489736],"length":1,"stats":{"Line":5}},{"line":137,"address":[1976467,1974994,1975081,1975236],"length":1,"stats":{"Line":15}},{"line":138,"address":[1488525],"length":1,"stats":{"Line":5}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[1975301,1975369],"length":1,"stats":{"Line":8}},{"line":145,"address":[1488660,1488812],"length":1,"stats":{"Line":5}},{"line":147,"address":[1414709],"length":1,"stats":{"Line":6}},{"line":148,"address":[1900666,1900745],"length":1,"stats":{"Line":4}},{"line":149,"address":[1962138],"length":1,"stats":{"Line":2}},{"line":151,"address":[1904171],"length":1,"stats":{"Line":0}},{"line":155,"address":[1488819,1488858],"length":1,"stats":{"Line":4}},{"line":156,"address":[1976039,1975622],"length":1,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[1892720,1892739],"length":1,"stats":{"Line":4}},{"line":162,"address":[1975920],"length":1,"stats":{"Line":3}},{"line":164,"address":[1415600,1414422],"length":1,"stats":{"Line":0}},{"line":171,"address":[1421728],"length":1,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[1422872,1421963,1422017,1421885],"length":1,"stats":{"Line":6}},{"line":182,"address":[1496081,1496173,1496986,1496227],"length":1,"stats":{"Line":8}},{"line":183,"address":[1983107,1983206,1983260,1983912],"length":1,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":11}},{"line":185,"address":[],"length":0,"stats":{"Line":14}},{"line":186,"address":[1422382,1422537,1422862,1422483],"length":1,"stats":{"Line":14}},{"line":187,"address":[1422489,1422643,1422590,1422860],"length":1,"stats":{"Line":16}},{"line":188,"address":[1422601,1422692],"length":1,"stats":{"Line":2}},{"line":205,"address":[1983984],"length":1,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[1497152,1497792,1497821],"length":1,"stats":{"Line":7}},{"line":214,"address":[1497197],"length":1,"stats":{"Line":7}},{"line":215,"address":[1423101,1423179,1423233,1423652],"length":1,"stats":{"Line":16}},{"line":216,"address":[1497443,1497297,1497389,1497762],"length":1,"stats":{"Line":16}},{"line":217,"address":[],"length":0,"stats":{"Line":13}},{"line":218,"address":[1497501,1497592],"length":1,"stats":{"Line":2}},{"line":225,"address":[1981746,1980960],"length":1,"stats":{"Line":2}},{"line":226,"address":[1980998,1981210,1981070,1981741],"length":1,"stats":{"Line":6}},{"line":227,"address":[1981232],"length":1,"stats":{"Line":2}},{"line":228,"address":[1494762,1494533],"length":1,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[1420286],"length":1,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[1982562,1981776],"length":1,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[1982101,1982330],"length":1,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[1981992,1982508],"length":1,"stats":{"Line":0}},{"line":258,"address":[1978560,1980496,1980924],"length":1,"stats":{"Line":4}},{"line":261,"address":[1978681,1978610],"length":1,"stats":{"Line":8}},{"line":262,"address":[1494134,1491989],"length":1,"stats":{"Line":2}},{"line":265,"address":[1417791,1417859],"length":1,"stats":{"Line":6}},{"line":266,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[1417947,1419834],"length":1,"stats":{"Line":0}},{"line":270,"address":[1492203],"length":1,"stats":{"Line":3}},{"line":271,"address":[1492288,1492373],"length":1,"stats":{"Line":6}},{"line":272,"address":[1494010,1492321],"length":1,"stats":{"Line":0}},{"line":275,"address":[1418229],"length":1,"stats":{"Line":3}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[1493948,1492665],"length":1,"stats":{"Line":0}},{"line":281,"address":[1492507,1492432],"length":1,"stats":{"Line":2}},{"line":284,"address":[1979466],"length":1,"stats":{"Line":2}},{"line":285,"address":[1979503,1980512],"length":1,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[1979484,1979567,1979648,1980507],"length":1,"stats":{"Line":8}},{"line":292,"address":[1962400,1962422],"length":1,"stats":{"Line":8}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[1911702,1911680],"length":1,"stats":{"Line":0}},{"line":296,"address":[1493660],"length":1,"stats":{"Line":0}},{"line":297,"address":[1493546],"length":1,"stats":{"Line":0}},{"line":311,"address":[1410096],"length":1,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[1970774],"length":1,"stats":{"Line":3}},{"line":319,"address":[1410596,1410112,1410621],"length":1,"stats":{"Line":2}},{"line":325,"address":[1410265,1410186],"length":1,"stats":{"Line":6}},{"line":326,"address":[1484956,1485201],"length":1,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}}],"covered":105,"coverable":150},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","opcode.rs"],"content":"//! Neo VM OpCodes - Based on Neo N3 specification\n\n/// Neo VM Operation Codes\n///\n/// Names follow the official Neo N3 specification exactly.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\n#[allow(non_camel_case_types)]\npub enum OpCode {\n    // Constants\n    PUSHINT8 = 0x00,\n    PUSHINT16 = 0x01,\n    PUSHINT32 = 0x02,\n    PUSHINT64 = 0x03,\n    PUSHINT128 = 0x04,\n    PUSHINT256 = 0x05,\n    PUSHA = 0x0A,\n    PUSHNULL = 0x0B,\n    PUSHDATA1 = 0x0C,\n    PUSHDATA2 = 0x0D,\n    PUSHDATA4 = 0x0E,\n    PUSHM1 = 0x0F,\n    PUSH0 = 0x10,\n    PUSH1 = 0x11,\n    PUSH2 = 0x12,\n    PUSH3 = 0x13,\n    PUSH4 = 0x14,\n    PUSH5 = 0x15,\n    PUSH6 = 0x16,\n    PUSH7 = 0x17,\n    PUSH8 = 0x18,\n    PUSH9 = 0x19,\n    PUSH10 = 0x1A,\n    PUSH11 = 0x1B,\n    PUSH12 = 0x1C,\n    PUSH13 = 0x1D,\n    PUSH14 = 0x1E,\n    PUSH15 = 0x1F,\n    PUSH16 = 0x20,\n\n    // Flow control\n    NOP = 0x21,\n    JMP = 0x22,\n    JMP_L = 0x23,\n    JMPIF = 0x24,\n    JMPIF_L = 0x25,\n    JMPIFNOT = 0x26,\n    JMPIFNOT_L = 0x27,\n    JMPEQ = 0x28,\n    JMPEQ_L = 0x29,\n    JMPNE = 0x2A,\n    JMPNE_L = 0x2B,\n    JMPGT = 0x2C,\n    JMPGT_L = 0x2D,\n    JMPGE = 0x2E,\n    JMPGE_L = 0x2F,\n    JMPLT = 0x30,\n    JMPLT_L = 0x31,\n    JMPLE = 0x32,\n    JMPLE_L = 0x33,\n    CALL = 0x34,\n    CALL_L = 0x35,\n    CALLA = 0x36,\n    CALLT = 0x37,\n    ABORT = 0x38,\n    ASSERT = 0x39,\n    THROW = 0x3A,\n    TRY = 0x3B,\n    TRY_L = 0x3C,\n    ENDTRY = 0x3D,\n    ENDTRY_L = 0x3E,\n    ENDFINALLY = 0x3F,\n    RET = 0x40,\n    SYSCALL = 0x41,\n\n    // Stack operations\n    DEPTH = 0x43,\n    DROP = 0x45,\n    NIP = 0x46,\n    XDROP = 0x48,\n    CLEAR = 0x49,\n    DUP = 0x4A,\n    OVER = 0x4B,\n    PICK = 0x4D,\n    TUCK = 0x4E,\n    SWAP = 0x50,\n    ROT = 0x51,\n    ROLL = 0x52,\n    REVERSE3 = 0x53,\n    REVERSE4 = 0x54,\n    REVERSEN = 0x55,\n\n    // Slot operations\n    INITSSLOT = 0x56,\n    INITSLOT = 0x57,\n    LDSFLD0 = 0x58,\n    LDSFLD = 0x5E,\n    STSFLD0 = 0x5F,\n    STSFLD = 0x65,\n    LDLOC0 = 0x66,\n    LDLOC = 0x6C,\n    STLOC0 = 0x6D,\n    STLOC = 0x73,\n    LDARG0 = 0x74,\n    LDARG = 0x7A,\n    STARG0 = 0x7B,\n    STARG = 0x81,\n\n    // Splice operations\n    NEWBUFFER = 0x88,\n    MEMCPY = 0x89,\n    CAT = 0x8B,\n    SUBSTR = 0x8C,\n    LEFT = 0x8D,\n    RIGHT = 0x8E,\n\n    // Bitwise operations\n    INVERT = 0x90,\n    AND = 0x91,\n    OR = 0x92,\n    XOR = 0x93,\n    EQUAL = 0x97,\n    NOTEQUAL = 0x98,\n\n    // Arithmetic\n    SIGN = 0x99,\n    ABS = 0x9A,\n    NEGATE = 0x9B,\n    INC = 0x9C,\n    DEC = 0x9D,\n    ADD = 0x9E,\n    SUB = 0x9F,\n    MUL = 0xA0,\n    DIV = 0xA1,\n    MOD = 0xA2,\n    POW = 0xA3,\n    SQRT = 0xA4,\n    MODMUL = 0xA5,\n    MODPOW = 0xA6,\n    SHL = 0xA8,\n    SHR = 0xA9,\n    NOT = 0xAA,\n    BOOLAND = 0xAB,\n    BOOLOR = 0xAC,\n    NZ = 0xB1,\n    NUMEQUAL = 0xB3,\n    NUMNOTEQUAL = 0xB4,\n    LT = 0xB5,\n    LE = 0xB6,\n    GT = 0xB7,\n    GE = 0xB8,\n    MIN = 0xB9,\n    MAX = 0xBA,\n    WITHIN = 0xBB,\n\n    // Compound types\n    PACKMAP = 0xBE,\n    PACKSTRUCT = 0xBF,\n    PACK = 0xC0,\n    UNPACK = 0xC1,\n    NEWARRAY0 = 0xC2,\n    NEWARRAY = 0xC3,\n    NEWARRAY_T = 0xC4,\n    NEWSTRUCT0 = 0xC5,\n    NEWSTRUCT = 0xC6,\n    NEWMAP = 0xC8,\n    SIZE = 0xCA,\n    HASKEY = 0xCB,\n    KEYS = 0xCC,\n    VALUES = 0xCD,\n    PICKITEM = 0xCE,\n    APPEND = 0xCF,\n    SETITEM = 0xD0,\n    REVERSEITEMS = 0xD1,\n    REMOVE = 0xD2,\n    CLEARITEMS = 0xD3,\n    POPITEM = 0xD4,\n\n    // Types\n    ISNULL = 0xD8,\n    ISTYPE = 0xD9,\n    CONVERT = 0xDB,\n    ABORTMSG = 0xE0,\n    ASSERTMSG = 0xE1,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","stack_item.rs"],"content":"//! Neo VM Stack Item types\n\nuse serde::{Deserialize, Serialize};\n\n/// Stack item types in Neo VM (simplified for zkVM)\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum StackItem {\n    Null,\n    Boolean(bool),\n    Integer(i128),\n    ByteString(Vec\u003cu8\u003e),\n    Buffer(Vec\u003cu8\u003e),\n    Array(Vec\u003cStackItem\u003e),\n    Struct(Vec\u003cStackItem\u003e),\n    Map(Vec\u003c(StackItem, StackItem)\u003e),\n    Pointer(u32),\n}\n\n// SAFETY: NeoVM is designed for single-threaded use. StackItem contains Vec which is not\n// thread-safe by default, but we explicitly mark it as Send/Sync because the VM\n// is never shared across threads in the intended usage pattern (SP1 guest execution\n// or single-threaded CLI usage). Users must not share NeoVM instances between threads.\nunsafe impl Send for StackItem {}\nunsafe impl Sync for StackItem {}\n\nimpl StackItem {\n    #[inline]\n    pub fn to_bool(\u0026self) -\u003e bool {\n        match self {\n            StackItem::Null =\u003e false,\n            StackItem::Boolean(b) =\u003e *b,\n            StackItem::Integer(i) =\u003e *i != 0,\n            StackItem::ByteString(b) | StackItem::Buffer(b) =\u003e b.iter().any(|\u0026x| x != 0),\n            StackItem::Array(a) | StackItem::Struct(a) =\u003e !a.is_empty(),\n            StackItem::Map(m) =\u003e !m.is_empty(),\n            _ =\u003e true,\n        }\n    }\n\n    #[inline]\n    pub fn to_integer(\u0026self) -\u003e Option\u003ci128\u003e {\n        match self {\n            StackItem::Integer(i) =\u003e Some(*i),\n            StackItem::Boolean(b) =\u003e Some(*b as i128),\n            _ =\u003e None,\n        }\n    }\n}\n","traces":[{"line":28,"address":[2115702,2115632],"length":1,"stats":{"Line":2}},{"line":29,"address":[2042849,2042864,2042669,2042834,2042819],"length":1,"stats":{"Line":2}},{"line":30,"address":[2054392],"length":1,"stats":{"Line":0}},{"line":31,"address":[2035958],"length":1,"stats":{"Line":0}},{"line":32,"address":[2093572],"length":1,"stats":{"Line":2}},{"line":33,"address":[2115801,2115883,2115786],"length":1,"stats":{"Line":0}},{"line":34,"address":[2043944,2043959,2044063],"length":1,"stats":{"Line":0}},{"line":35,"address":[2043974],"length":1,"stats":{"Line":0}},{"line":36,"address":[2036107],"length":1,"stats":{"Line":0}},{"line":41,"address":[1710000],"length":1,"stats":{"Line":23}},{"line":42,"address":[2042148],"length":1,"stats":{"Line":22}},{"line":43,"address":[2043396],"length":1,"stats":{"Line":25}},{"line":44,"address":[2042237],"length":1,"stats":{"Line":0}},{"line":45,"address":[2035426],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":14},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","src","storage.rs"],"content":"//! Neo VM Storage Implementation\n//!\n//! Provides key-value storage for smart contracts with Merkle proof support.\n\nuse sha2::{Digest, Sha256};\nuse std::collections::BTreeMap;\n\n/// Storage context for a contract\n#[derive(Debug, Clone, Default)]\npub struct StorageContext {\n    /// Contract script hash (20 bytes)\n    pub script_hash: [u8; 20],\n    /// Read-only flag\n    pub read_only: bool,\n}\n\n/// Storage backend trait\npub trait StorageBackend {\n    fn get(\u0026self, context: \u0026StorageContext, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e;\n    fn put(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8], value: \u0026[u8]);\n    fn delete(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8]);\n    fn find(\u0026self, context: \u0026StorageContext, prefix: \u0026[u8]) -\u003e Vec\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e;\n}\n\n/// In-memory storage implementation\n#[derive(Debug, Clone, Default)]\npub struct MemoryStorage {\n    data: BTreeMap\u003cVec\u003cu8\u003e, Vec\u003cu8\u003e\u003e,\n}\n\nimpl MemoryStorage {\n    #[inline]\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    #[inline]\n    fn make_key(context: \u0026StorageContext, key: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n        let mut full_key = context.script_hash.to_vec();\n        full_key.extend_from_slice(key);\n        full_key\n    }\n\n    /// Compute Merkle root of storage\n    #[inline]\n    pub fn merkle_root(\u0026self) -\u003e [u8; 32] {\n        if self.data.is_empty() {\n            return [0u8; 32];\n        }\n\n        // Collect and sort leaves by key for deterministic Merkle root\n        // This ensures cross-platform/environment determinism\n        let mut leaves: Vec\u003c[u8; 32]\u003e = self\n            .data\n            .iter()\n            .map(|(k, v)| {\n                let mut hasher = Sha256::new();\n                hasher.update(k);\n                hasher.update(v);\n                hasher.finalize().into()\n            })\n            .collect();\n\n        // Sort leaves to ensure deterministic ordering\n        leaves.sort();\n\n        Self::compute_merkle_root(\u0026leaves)\n    }\n\n    #[inline]\n    fn compute_merkle_root(leaves: \u0026[[u8; 32]]) -\u003e [u8; 32] {\n        if leaves.is_empty() {\n            return [0u8; 32];\n        }\n        if leaves.len() == 1 {\n            return leaves[0];\n        }\n\n        let mut current: Vec\u003c[u8; 32]\u003e = leaves.to_vec();\n        while current.len() \u003e 1 {\n            let mut next_level = Vec::with_capacity(current.len().div_ceil(2));\n            for chunk in current.chunks(2) {\n                let mut hasher = Sha256::new();\n                hasher.update(chunk[0]);\n                if chunk.len() \u003e 1 {\n                    hasher.update(chunk[1]);\n                } else {\n                    hasher.update([0u8; 32]);\n                }\n                next_level.push(hasher.finalize().into());\n            }\n            current = next_level;\n        }\n        current.first().copied().unwrap_or([0u8; 32])\n    }\n}\n\nimpl StorageBackend for MemoryStorage {\n    fn get(\u0026self, context: \u0026StorageContext, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        let full_key = Self::make_key(context, key);\n        self.data.get(\u0026full_key).cloned()\n    }\n\n    fn put(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8], value: \u0026[u8]) {\n        if context.read_only {\n            return;\n        }\n        let full_key = Self::make_key(context, key);\n        self.data.insert(full_key, value.to_vec());\n    }\n\n    fn delete(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8]) {\n        if context.read_only {\n            return;\n        }\n        let full_key = Self::make_key(context, key);\n        self.data.remove(\u0026full_key);\n    }\n\n    fn find(\u0026self, context: \u0026StorageContext, prefix: \u0026[u8]) -\u003e Vec\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n        let full_prefix = Self::make_key(context, prefix);\n        self.data\n            .range(full_prefix.clone()..)\n            .take_while(|(k, _)| k.starts_with(\u0026full_prefix))\n            .map(|(k, v)| {\n                let key = k[context.script_hash.len()..].to_vec();\n                (key, v.clone())\n            })\n            .collect()\n    }\n}\n\n/// Storage proof for ZK verification\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct StorageProof {\n    pub key: Vec\u003cu8\u003e,\n    pub value: Option\u003cVec\u003cu8\u003e\u003e,\n    pub merkle_path: Vec\u003c[u8; 32]\u003e,\n    pub root: [u8; 32],\n}\n\nimpl StorageProof {\n    /// Verify a storage proof against a given root\n    pub fn verify(\u0026self, expected_root: [u8; 32]) -\u003e bool {\n        // Compute leaf hash from key and value\n        let leaf = if let Some(ref value) = self.value {\n            let mut hasher = Sha256::new();\n            hasher.update(\u0026self.key);\n            hasher.update(value);\n            hasher.finalize().into()\n        } else {\n            // For deleted/missing values, use zero hash with key\n            let mut hasher = Sha256::new();\n            hasher.update(\u0026self.key);\n            hasher.update([0u8; 32]);\n            hasher.finalize().into()\n        };\n\n        // Compute root from leaf and merkle path\n        let computed_root = Self::compute_root_from_path(\u0026leaf, \u0026self.merkle_path);\n\n        computed_root == expected_root\n    }\n\n    /// Compute root hash from leaf and path\n    fn compute_root_from_path(leaf: \u0026[u8; 32], path: \u0026[[u8; 32]]) -\u003e [u8; 32] {\n        let mut current = *leaf;\n        for sibling in path {\n            let mut hasher = Sha256::new();\n            // Determine left/right based on hash ordering\n            if current \u003c *sibling {\n                hasher.update(current);\n                hasher.update(*sibling);\n            } else {\n                hasher.update(*sibling);\n                hasher.update(current);\n            }\n            current = hasher.finalize().into();\n        }\n        current\n    }\n}\n\n/// Storage change record\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct StorageChange {\n    pub script_hash: [u8; 20],\n    pub key: Vec\u003cu8\u003e,\n    pub old_value: Option\u003cVec\u003cu8\u003e\u003e,\n    pub new_value: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n/// Tracked storage with change log\n#[derive(Debug, Clone, Default)]\npub struct TrackedStorage {\n    inner: MemoryStorage,\n    changes: Vec\u003cStorageChange\u003e,\n}\n\nimpl TrackedStorage {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn changes(\u0026self) -\u003e \u0026[StorageChange] {\n        \u0026self.changes\n    }\n\n    pub fn merkle_root(\u0026self) -\u003e [u8; 32] {\n        self.inner.merkle_root()\n    }\n}\n\nimpl StorageBackend for TrackedStorage {\n    fn get(\u0026self, context: \u0026StorageContext, key: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        self.inner.get(context, key)\n    }\n\n    fn put(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8], value: \u0026[u8]) {\n        if context.read_only {\n            return;\n        }\n        let old_value = self.inner.get(context, key);\n        self.inner.put(context, key, value);\n        self.changes.push(StorageChange {\n            script_hash: context.script_hash,\n            key: key.to_vec(),\n            old_value,\n            new_value: Some(value.to_vec()),\n        });\n    }\n\n    fn delete(\u0026mut self, context: \u0026StorageContext, key: \u0026[u8]) {\n        if context.read_only {\n            return;\n        }\n        let old_value = self.inner.get(context, key);\n        self.inner.delete(context, key);\n        self.changes.push(StorageChange {\n            script_hash: context.script_hash,\n            key: key.to_vec(),\n            old_value,\n            new_value: None,\n        });\n    }\n\n    fn find(\u0026self, context: \u0026StorageContext, prefix: \u0026[u8]) -\u003e Vec\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n        self.inner.find(context, prefix)\n    }\n}\n","traces":[{"line":33,"address":[2036496],"length":1,"stats":{"Line":8}},{"line":34,"address":[1761512],"length":1,"stats":{"Line":8}},{"line":38,"address":[2086393,2086387,2086224],"length":1,"stats":{"Line":6}},{"line":39,"address":[2028678],"length":1,"stats":{"Line":4}},{"line":40,"address":[1761616],"length":1,"stats":{"Line":5}},{"line":41,"address":[1761668],"length":1,"stats":{"Line":8}},{"line":46,"address":[1759873,1759867,1759568],"length":1,"stats":{"Line":3}},{"line":47,"address":[1435606],"length":1,"stats":{"Line":3}},{"line":48,"address":[2045274],"length":1,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[2041472,2041522],"length":1,"stats":{"Line":16}},{"line":57,"address":[2041538],"length":1,"stats":{"Line":5}},{"line":58,"address":[2023105],"length":1,"stats":{"Line":5}},{"line":59,"address":[2034433],"length":1,"stats":{"Line":5}},{"line":60,"address":[1396890],"length":1,"stats":{"Line":5}},{"line":65,"address":[1435784,1435696],"length":1,"stats":{"Line":11}},{"line":67,"address":[2045347],"length":1,"stats":{"Line":5}},{"line":71,"address":[2106944,2108468,2108462],"length":1,"stats":{"Line":5}},{"line":72,"address":[2107006],"length":1,"stats":{"Line":5}},{"line":73,"address":[2045538],"length":1,"stats":{"Line":0}},{"line":75,"address":[1435973],"length":1,"stats":{"Line":2}},{"line":76,"address":[1760034,1761435],"length":1,"stats":{"Line":8}},{"line":79,"address":[2035005],"length":1,"stats":{"Line":1}},{"line":80,"address":[2038466,2038539,2039319],"length":1,"stats":{"Line":3}},{"line":81,"address":[2035313,2035150],"length":1,"stats":{"Line":3}},{"line":82,"address":[1760377,1760457],"length":1,"stats":{"Line":2}},{"line":83,"address":[2039107],"length":1,"stats":{"Line":1}},{"line":84,"address":[1436913],"length":1,"stats":{"Line":1}},{"line":85,"address":[2046561],"length":1,"stats":{"Line":1}},{"line":86,"address":[2108122,2108287],"length":1,"stats":{"Line":2}},{"line":88,"address":[1748713,1748779],"length":1,"stats":{"Line":2}},{"line":90,"address":[2108143,2108374],"length":1,"stats":{"Line":2}},{"line":92,"address":[1436713,1436772],"length":1,"stats":{"Line":1}},{"line":94,"address":[2107251,2107185],"length":1,"stats":{"Line":2}},{"line":99,"address":[1752240,1752048,1752246],"length":1,"stats":{"Line":2}},{"line":100,"address":[1752137],"length":1,"stats":{"Line":2}},{"line":101,"address":[2031592,2031653],"length":1,"stats":{"Line":4}},{"line":104,"address":[2039600,2039906,2039877],"length":1,"stats":{"Line":6}},{"line":105,"address":[2043108],"length":1,"stats":{"Line":6}},{"line":108,"address":[1764725],"length":1,"stats":{"Line":6}},{"line":109,"address":[1752541,1752388,1752440],"length":1,"stats":{"Line":8}},{"line":112,"address":[2043890,2043896,2043712],"length":1,"stats":{"Line":1}},{"line":113,"address":[2090031],"length":1,"stats":{"Line":1}},{"line":116,"address":[2112428],"length":1,"stats":{"Line":1}},{"line":117,"address":[2032490,2032549],"length":1,"stats":{"Line":2}},{"line":120,"address":[2039920,2040263,2040269],"length":1,"stats":{"Line":1}},{"line":121,"address":[2043447],"length":1,"stats":{"Line":2}},{"line":123,"address":[1752689,1752754],"length":1,"stats":{"Line":6}},{"line":124,"address":[1765165],"length":1,"stats":{"Line":5}},{"line":125,"address":[2036817,2036560,2036613,2036823],"length":1,"stats":{"Line":5}},{"line":126,"address":[2040629],"length":1,"stats":{"Line":1}},{"line":127,"address":[2105312],"length":1,"stats":{"Line":1}},{"line":144,"address":[2034128],"length":1,"stats":{"Line":0}},{"line":146,"address":[2044713],"length":1,"stats":{"Line":0}},{"line":147,"address":[2034212],"length":1,"stats":{"Line":0}},{"line":148,"address":[2083924],"length":1,"stats":{"Line":0}},{"line":149,"address":[1759252],"length":1,"stats":{"Line":0}},{"line":150,"address":[2037679],"length":1,"stats":{"Line":0}},{"line":153,"address":[1747128],"length":1,"stats":{"Line":0}},{"line":154,"address":[2026462],"length":1,"stats":{"Line":0}},{"line":155,"address":[2037788],"length":1,"stats":{"Line":0}},{"line":156,"address":[1747201],"length":1,"stats":{"Line":0}},{"line":160,"address":[2034485],"length":1,"stats":{"Line":0}},{"line":162,"address":[2045091],"length":1,"stats":{"Line":0}},{"line":166,"address":[2025536],"length":1,"stats":{"Line":0}},{"line":167,"address":[2025603],"length":1,"stats":{"Line":0}},{"line":168,"address":[2033526,2034109],"length":1,"stats":{"Line":0}},{"line":169,"address":[1746418],"length":1,"stats":{"Line":0}},{"line":171,"address":[2083316],"length":1,"stats":{"Line":0}},{"line":172,"address":[2105905],"length":1,"stats":{"Line":0}},{"line":173,"address":[2083613],"length":1,"stats":{"Line":0}},{"line":175,"address":[2037123],"length":1,"stats":{"Line":0}},{"line":176,"address":[2083461],"length":1,"stats":{"Line":0}},{"line":178,"address":[1758991],"length":1,"stats":{"Line":0}},{"line":180,"address":[2044211],"length":1,"stats":{"Line":0}},{"line":201,"address":[2036768],"length":1,"stats":{"Line":2}},{"line":202,"address":[2040200],"length":1,"stats":{"Line":3}},{"line":205,"address":[2040224],"length":1,"stats":{"Line":2}},{"line":206,"address":[1761813],"length":1,"stats":{"Line":2}},{"line":209,"address":[1761728],"length":1,"stats":{"Line":1}},{"line":210,"address":[2028849],"length":1,"stats":{"Line":1}},{"line":215,"address":[1765504],"length":1,"stats":{"Line":0}},{"line":216,"address":[2032639],"length":1,"stats":{"Line":0}},{"line":219,"address":[1765568,1766148,1766176],"length":1,"stats":{"Line":3}},{"line":220,"address":[1765653],"length":1,"stats":{"Line":3}},{"line":223,"address":[2090374],"length":1,"stats":{"Line":3}},{"line":224,"address":[1753357],"length":1,"stats":{"Line":4}},{"line":225,"address":[2044421],"length":1,"stats":{"Line":4}},{"line":226,"address":[2090508],"length":1,"stats":{"Line":4}},{"line":227,"address":[2051394],"length":1,"stats":{"Line":4}},{"line":228,"address":[2090559],"length":1,"stats":{"Line":4}},{"line":229,"address":[2040897,2040965],"length":1,"stats":{"Line":8}},{"line":233,"address":[1754314,1753872,1754339],"length":1,"stats":{"Line":1}},{"line":234,"address":[1766331],"length":1,"stats":{"Line":1}},{"line":237,"address":[2091052],"length":1,"stats":{"Line":1}},{"line":238,"address":[1754009],"length":1,"stats":{"Line":1}},{"line":239,"address":[2091274],"length":1,"stats":{"Line":1}},{"line":240,"address":[2033592],"length":1,"stats":{"Line":1}},{"line":241,"address":[2052062],"length":1,"stats":{"Line":1}},{"line":242,"address":[2044950],"length":1,"stats":{"Line":1}},{"line":243,"address":[2041570],"length":1,"stats":{"Line":1}},{"line":247,"address":[2090896],"length":1,"stats":{"Line":0}},{"line":248,"address":[2033343],"length":1,"stats":{"Line":0}}],"covered":74,"coverable":104},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","boundary_tests.rs"],"content":"//! Boundary condition tests for Neo VM Core\n//!\n//! Tests edge cases and boundary conditions for all VM operations.\n\nuse neo_vm_core::{NeoVM, StackItem, VMState};\n\n// Helper to run VM until completion\nfn run_vm(vm: \u0026mut NeoVM) {\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            vm.state = VMState::Fault;\n            break;\n        }\n    }\n}\n\n// ============================================================================\n// Integer Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_push_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x40]); // PUSH0, RET\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_push_negative_one() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x0F, 0x40]); // PUSHM1, RET\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-1)));\n}\n\n#[test]\nfn test_push_max_small_int() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x20, 0x40]); // PUSH16, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(16)));\n}\n\n#[test]\nfn test_pushint8_max() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x00, 0x7F, 0x40]); // PUSHINT8 127, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(127)));\n}\n\n#[test]\nfn test_pushint8_min() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x00, 0x80, 0x40]); // PUSHINT8 -128, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-128)));\n}\n\n#[test]\nfn test_pushint16_max() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x01, 0xFF, 0x7F, 0x40]); // PUSHINT16 32767, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(32767)));\n}\n\n#[test]\nfn test_pushint16_min() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x01, 0x00, 0x80, 0x40]); // PUSHINT16 -32768, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-32768)));\n}\n\n// ============================================================================\n// Arithmetic Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_add_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0x9E, 0x40]); // 5 + 0 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_add_negative_result() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x12, 0x0F, 0x9E, 0x0F, 0x9E, 0x0F, 0x9E, 0x40]); // 2 + (-1) + (-1) + (-1) = -1\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-1)));\n}\n\n#[test]\nfn test_sub_to_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0x9F, 0x40]); // 5 - 5 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_sub_negative_result() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x13, 0x15, 0x9F, 0x40]); // 3 - 5 = -2\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-2)));\n}\n\n#[test]\nfn test_mul_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA0, 0x40]); // 5 * 0 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_mul_by_one() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x11, 0xA0, 0x40]); // 5 * 1 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_mul_negative() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x0F, 0xA0, 0x40]); // 5 * (-1) = -5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-5)));\n}\n\n#[test]\nfn test_div_by_one() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x11, 0xA1, 0x40]); // 5 / 1 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_div_zero_dividend() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x15, 0xA1, 0x40]); // 0 / 5 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_mod_zero_dividend() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x15, 0xA2, 0x40]); // 0 % 5 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_mod_same_numbers() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xA2, 0x40]); // 5 % 5 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n// ============================================================================\n// Comparison Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_lt_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB5, 0x40]); // 5 \u003c 5 = false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_le_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB6, 0x40]); // 5 \u003c= 5 = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_gt_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB7, 0x40]); // 5 \u003e 5 = false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_ge_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB8, 0x40]); // 5 \u003e= 5 = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_compare_with_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x11, 0xB5, 0x40]); // 0 \u003c 1 = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_compare_negative() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x0F, 0x10, 0xB5, 0x40]); // -1 \u003c 0 = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n// ============================================================================\n// Stack Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_depth_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x43, 0x40]); // DEPTH, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_depth_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x43, 0x40]); // PUSH5, DEPTH, RET\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n}\n\n#[test]\nfn test_clear_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x49, 0x40]); // CLEAR, RET\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.len(), 0);\n}\n\n#[test]\nfn test_swap_two_items() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x50, 0x40]); // 1, 2, SWAP\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(2)));\n}\n\n#[test]\nfn test_rot_three_items() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x51, 0x40]); // 1, 2, 3, ROT -\u003e 2, 3, 1\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(2)));\n}\n\n// ============================================================================\n// Bitwise Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_and_with_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x10, 0x91, 0x40]); // 15 \u0026 0 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_or_with_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x10, 0x92, 0x40]); // 15 | 0 = 15\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(15)));\n}\n\n#[test]\nfn test_xor_same_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x1F, 0x93, 0x40]); // 15 ^ 15 = 0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_shl_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA8, 0x40]); // 5 \u003c\u003c 0 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_shr_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA9, 0x40]); // 5 \u003e\u003e 0 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n// ============================================================================\n// Array Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_newarray_zero_size() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0xC3, 0x40]); // PUSH0, NEWARRAY\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Array(vec![])));\n}\n\n#[test]\nfn test_newarray0() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xC2, 0x40]); // NEWARRAY0\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Array(vec![])));\n}\n\n#[test]\nfn test_size_empty_array() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xC2, 0xCA, 0x40]); // NEWARRAY0, SIZE\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(0)));\n}\n\n// ============================================================================\n// Boolean Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_not_true() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0xAA, 0x40]); // PUSH1 (true), NOT\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_not_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0xAA, 0x40]); // PUSH0 (false), NOT\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_booland_true_true() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x11, 0xAB, 0x40]); // true \u0026\u0026 true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_booland_true_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x10, 0xAB, 0x40]); // true \u0026\u0026 false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_boolor_false_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x10, 0xAC, 0x40]); // false || false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_boolor_true_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x10, 0xAC, 0x40]); // true || false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n// ============================================================================\n// WITHIN Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_within_at_lower_bound() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x13, 0x13, 0x17, 0xBB, 0x40]); // 3 within [3, 7) = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_within_at_upper_bound() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x17, 0x13, 0x17, 0xBB, 0x40]); // 7 within [3, 7) = false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_within_below_range() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x12, 0x13, 0x17, 0xBB, 0x40]); // 2 within [3, 7) = false\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_within_inside_range() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x13, 0x17, 0xBB, 0x40]); // 5 within [3, 7) = true\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n// ============================================================================\n// MIN/MAX Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_min_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB9, 0x40]); // min(5, 5) = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_max_equal_values() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xBA, 0x40]); // max(5, 5) = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_min_with_negative() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x0F, 0x15, 0xB9, 0x40]); // min(-1, 5) = -1\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-1)));\n}\n\n#[test]\nfn test_max_with_negative() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x0F, 0x15, 0xBA, 0x40]); // max(-1, 5) = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n// ============================================================================\n// Integer Overflow Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_negate_max_i8() {\n    // -128 negated should fail (overflow)\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x00, 0x80, 0x9B, 0x40]); // PUSHINT8 -128, NEGATE, RET\n    run_vm(\u0026mut vm);\n    // The VM should handle this gracefully\n    assert!(matches!(vm.state, VMState::Halt) || matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_abs_max_i8() {\n    // abs(-128) should fail (overflow)\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x00, 0x80, 0x9A, 0x40]); // PUSHINT8 -128, ABS, RET\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt) || matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_add_overflow() {\n    // Large positive + large positive should fail\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHINT16 32767, PUSHINT16 32767, ADD should overflow\n    let _ = vm.load_script(vec![0x01, 0xFF, 0x7F, 0x01, 0xFF, 0x7F, 0x9E, 0x40]);\n    run_vm(\u0026mut vm);\n    // 32767 + 32767 = 65534, which fits in i128\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_sub_underflow() {\n    // MIN - positive should fail\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHINT8 -128, PUSH1, SUB should underflow\n    let _ = vm.load_script(vec![0x00, 0x80, 0x11, 0x9F, 0x40]);\n    run_vm(\u0026mut vm);\n    // -128 - 1 = -129, which fits in i128\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_mul_overflow() {\n    // 256 * 256 = 65536, which fits in i128\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x01, 0x00, 0x01, 0x01, 0x00, 0xA0, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_inc_overflow() {\n    // Increment multiple times to test overflow\n    let mut vm = NeoVM::new(1_000_000);\n    let mut script = Vec::new();\n    for _ in 0..100 {\n        script.push(0x11); // PUSH1\n        script.push(0x9C); // INC\n    }\n    script.push(0x40); // RET\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_dec_underflow() {\n    // i128::MIN - 1 should fail\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x00, 0x80, 0x9D, 0x40]); // PUSHINT8 -128, DEC, RET\n    run_vm(\u0026mut vm);\n    // -128 - 1 = -129, which fits in i128\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_pow_zero_exponent() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA3, 0x40]); // 5^0 = 1\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n}\n\n#[test]\nfn test_pow_one_exponent() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x11, 0xA3, 0x40]); // 5^1 = 5\n    run_vm(\u0026mut vm);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_pow_negative_exponent() {\n    // Negative exponent should fail\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x0F, 0xA3, 0x40]); // 5^-1 should fail\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Script Size Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_empty_script() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_single_nop() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x42]); // NOP\n    assert!(matches!(vm.state, VMState::None));\n}\n\n#[test]\nfn test_ret_single_context_halts() {\n    // RET on a script with only the main context should Halt normally\n    // This is the expected behavior for a simple return\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![0x40]; // RET - main script returns\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let exec_result = vm.execute_next();\n    // RET pops the only context, sees stack is empty, sets Halt\n    assert!(\n        matches!(vm.state, VMState::Halt),\n        \"Expected Halt, got {:?}\",\n        vm.state\n    );\n    assert!(exec_result.is_ok(), \"RET should succeed for main script\");\n}\n\n// ============================================================================\n// Stack Depth Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_stack_depth_limit() {\n    let mut vm = NeoVM::new(1_000_000);\n    // Push many items to test depth handling\n    let mut script = Vec::new();\n    for _ in 0..100 {\n        script.push(0x11); // PUSH1\n    }\n    script.push(0x40); // RET\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.len(), 100);\n}\n\n// ============================================================================\n// Gas Exhaustion Tests\n// ============================================================================\n\n#[test]\nfn test_gas_exhaustion() {\n    let mut vm = NeoVM::new(10); // Very low gas limit\n                                 // Create a script that needs more gas than available\n    let mut script = Vec::new();\n    for _ in 0..20 {\n        script.push(0x11); // PUSH1\n    }\n    script.push(0x40); // RET\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    // Should fault due to gas exhaustion\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Arithmetic Overflow Tests\n// ============================================================================\n\n#[test]\nfn test_add_overflow_detection() {\n    let mut vm = NeoVM::new(1_000_000);\n    // i128::MAX + 1 should overflow\n    let max_val = i128::MAX;\n    let script = vec![\n        0x02, // PUSHINT32\n        (max_val \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 24) \u0026 0xFF) as u8,\n        0x02, // PUSHINT32\n        1u8,\n        0u8,\n        0u8,\n        0u8,  // 1\n        0x9E, // ADD\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_sub_underflow_detection() {\n    let mut vm = NeoVM::new(1_000_000);\n    // i128::MIN - 1 should overflow\n    let min_val = i128::MIN;\n    let script = vec![\n        0x02, // PUSHINT32\n        (min_val \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 24) \u0026 0xFF) as u8,\n        0x02, // PUSHINT32\n        1u8,\n        0u8,\n        0u8,\n        0u8,  // 1\n        0x9F, // SUB\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_mul_overflow_detection() {\n    let mut vm = NeoVM::new(1_000_000);\n    // i128::MAX * 2 should overflow\n    let max_val = i128::MAX / 2;\n    let script = vec![\n        0x02, // PUSHINT32\n        (max_val \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((max_val \u003e\u003e 24) \u0026 0xFF) as u8,\n        0x02, // PUSHINT32\n        (2i128 \u0026 0xFF) as u8,\n        ((2i128 \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((2i128 \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((2i128 \u003e\u003e 24) \u0026 0xFF) as u8,\n        0xA0, // MUL\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_negate_overflow_detection() {\n    let mut vm = NeoVM::new(1_000_000);\n    // NEGATE i128::MIN should overflow\n    let min_val = i128::MIN;\n    let script = vec![\n        0x02, // PUSHINT32\n        (min_val \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 24) \u0026 0xFF) as u8,\n        0x9B, // NEGATE\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_abs_overflow_detection() {\n    let mut vm = NeoVM::new(1_000_000);\n    // ABS of i128::MIN should overflow\n    let min_val = i128::MIN;\n    let script = vec![\n        0x02, // PUSHINT32\n        (min_val \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 8) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 16) \u0026 0xFF) as u8,\n        ((min_val \u003e\u003e 24) \u0026 0xFF) as u8,\n        0x9A, // ABS\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_div_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![0x11, 0x10, 0xA1, 0x40]; // 1, 0, DIV\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_mod_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![0x11, 0x10, 0xA2, 0x40]; // 1, 0, MOD\n    let _ = vm.load_script(script).ok();\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Script Validation Tests\n// ============================================================================\n\n#[test]\nfn test_pushdata1_truncated() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHDATA1 with length 10 but only 5 bytes available\n    let script = vec![0x0C, 0x0A, 0x42, 0x42, 0x42, 0x42, 0x42]; // 7 bytes total\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let _ = vm.execute_next();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_pushdata2_truncated() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHDATA2 with length 256 but not enough bytes\n    let script = vec![0x0D, 0x00, 0x01, 0x42]; // Only 1 data byte\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let _ = vm.execute_next();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_pushint8_truncated() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHINT8 at end of script\n    let script = vec![0x00]; // Just the opcode, no operand\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let _ = vm.execute_next();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_pushint16_truncated() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSHINT16 with only 1 byte available\n    let script = vec![0x01, 0x42]; // Only 1 of 2 bytes\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let _ = vm.execute_next();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_drop_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![0x45, 0x40]; // DROP on empty stack\n    let result = vm.load_script(script);\n    assert!(result.is_ok());\n    let _ = vm.execute_next();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Type Conversion Tests\n// ============================================================================\n\n#[test]\nfn test_isnull_true() {\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![\n        0x0B, // PUSHNULL\n        0xD8, // ISNULL\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_isnull_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let script = vec![\n        0x11, // PUSH1 (true)\n        0xD8, // ISNULL\n        0x40, // RET\n    ];\n    let _ = vm.load_script(script);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n","traces":[{"line":8,"address":[1491808],"length":1,"stats":{"Line":5}},{"line":9,"address":[1491825],"length":1,"stats":{"Line":3}},{"line":10,"address":[1491866],"length":1,"stats":{"Line":5}},{"line":11,"address":[1491913],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","comprehensive_tests.rs"],"content":"//! Comprehensive Neo VM Tests - Production Grade\n\nuse neo_vm_core::{NeoVM, StackItem, VMState};\n\n// === Arithmetic Tests ===\n\n#[test]\nfn test_add_positive() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x17, 0x9E, 0x40]); // 5 + 7 = 12\n    vm.run();\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(12)));\n}\n\n#[test]\nfn test_add_negative() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x0F, 0x9E, 0x40]); // 5 + (-1) = 4\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(4)));\n}\n\n#[test]\nfn test_sub() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1A, 0x13, 0x9F, 0x40]); // 10 - 3 = 7\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(7)));\n}\n\n#[test]\nfn test_mul() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x16, 0x17, 0xA0, 0x40]); // 6 * 7 = 42\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(42)));\n}\n\n#[test]\nfn test_div() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x15, 0xA1, 0x40]); // 15 / 5 = 3\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n}\n\n#[test]\nfn test_div_by_zero() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA1, 0x40]); // 5 / 0\n    vm.run();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_mod() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1A, 0x13, 0xA2, 0x40]); // 10 % 3 = 1\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n}\n\n// === Comparison Tests ===\n\n#[test]\nfn test_lt_true() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x13, 0x15, 0xB5, 0x40]); // 3 \u003c 5 = true\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_lt_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x13, 0xB5, 0x40]); // 5 \u003c 3 = false\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(false)));\n}\n\n#[test]\nfn test_le() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB6, 0x40]); // 5 \u003c= 5 = true\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_gt() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x17, 0x13, 0xB7, 0x40]); // 7 \u003e 3 = true\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n#[test]\nfn test_ge() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x15, 0xB8, 0x40]); // 5 \u003e= 5 = true\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n}\n\n// === Stack Operation Tests ===\n\n#[test]\nfn test_dup() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x4A, 0x40]); // 5, DUP\n    vm.run();\n    assert_eq!(vm.eval_stack.len(), 2);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_swap() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x50, 0x40]); // 1, 2, SWAP\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(2)));\n}\n\n#[test]\nfn test_drop() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x45, 0x40]); // 1, 2, DROP\n    vm.run();\n    assert_eq!(vm.eval_stack.len(), 1);\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n}\n\n#[test]\nfn test_depth() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x43, 0x40]); // 1,2,3,DEPTH\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n}\n\n// === Flow Control Tests ===\n\n#[test]\nfn test_jmp() {\n    let mut vm = NeoVM::new(1_000_000);\n    // JMP +4, PUSH1, RET, PUSH2, RET\n    // Offset is relative to JMP opcode position\n    let _ = vm.load_script(vec![0x22, 0x04, 0x11, 0x40, 0x12, 0x40]);\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(2)));\n}\n\n#[test]\nfn test_jmpif_true() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSH1(true), JMPIF +4, PUSH5, RET, PUSH9, RET\n    let _ = vm.load_script(vec![0x11, 0x24, 0x04, 0x15, 0x40, 0x19, 0x40]);\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(9)));\n}\n\n#[test]\nfn test_jmpif_false() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSH0(false), JMPIF +4, PUSH5, RET, PUSH9, RET\n    let _ = vm.load_script(vec![0x10, 0x24, 0x04, 0x15, 0x40, 0x19, 0x40]);\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_assert_pass() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x39, 0x15, 0x40]); // PUSH1, ASSERT, PUSH5, RET\n    vm.run();\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n}\n\n#[test]\nfn test_assert_fail() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x10, 0x39, 0x15, 0x40]); // PUSH0, ASSERT, PUSH5, RET\n    vm.run();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// === Bitwise Tests ===\n\n#[test]\nfn test_and() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x17, 0x91, 0x40]); // 15 \u0026 7 = 7\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(7)));\n}\n\n#[test]\nfn test_or() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x18, 0x13, 0x92, 0x40]); // 8 | 3 = 11\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(11)));\n}\n\n#[test]\nfn test_xor() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x1F, 0x19, 0x93, 0x40]); // 15 ^ 9 = 6\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(6)));\n}\n\n#[test]\nfn test_shl() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x13, 0xA8, 0x40]); // 1 \u003c\u003c 3 = 8\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(8)));\n}\n\n#[test]\nfn test_shr() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x20, 0x12, 0xA9, 0x40]); // 16 \u003e\u003e 2 = 4\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(4)));\n}\n\n// === Array Tests ===\n\n#[test]\nfn test_newarray() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x13, 0xC3, 0x40]); // PUSH3, NEWARRAY\n    vm.run();\n    if let Some(StackItem::Array(arr)) = vm.eval_stack.pop() {\n        assert_eq!(arr.len(), 3);\n    } else {\n        panic!(\"Expected array\");\n    }\n}\n\n#[test]\nfn test_pack_unpack() {\n    let mut vm = NeoVM::new(1_000_000);\n    // PUSH1, PUSH2, PUSH3, PUSH3, PACK, UNPACK\n    let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x13, 0xC0, 0xC1, 0x40]);\n    vm.run();\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3))); // count\n}\n\n// === Gas Limit Tests ===\n\n#[test]\nfn test_gas_limit() {\n    let mut vm = NeoVM::new(5); // Very low gas\n    let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x40]);\n    vm.run();\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_sufficient_gas() {\n    let mut vm = NeoVM::new(100);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x9E, 0x40]); // 1+2\n    vm.run();\n    assert!(matches!(vm.state, VMState::Halt));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","error_handling_tests.rs"],"content":"//! Error handling tests for Neo VM Core\n//!\n//! Tests error conditions and fault states.\n\nuse neo_vm_core::{NeoVM, StackItem, VMState};\n\n// Helper to run VM until completion\nfn run_vm(vm: \u0026mut NeoVM) {\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            vm.state = VMState::Fault;\n            break;\n        }\n    }\n}\n\n// ============================================================================\n// Division by Zero Tests\n// ============================================================================\n\n#[test]\nfn test_div_by_zero_faults() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA1, 0x40]); // 5 / 0\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_mod_by_zero_faults() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x10, 0xA2, 0x40]); // 5 % 0\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Stack Underflow Tests\n// ============================================================================\n\n#[test]\nfn test_add_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x9E, 0x40]); // ADD with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_add_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x9E, 0x40]); // PUSH5, ADD (needs 2 items)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_sub_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x9F, 0x40]); // SUB with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_mul_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xA0, 0x40]); // MUL with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_div_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xA1, 0x40]); // DIV with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_dup_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x4A, 0x40]); // DUP with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_drop_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x45, 0x40]); // DROP with empty stack\n    run_vm(\u0026mut vm);\n    // DROP on empty stack should fault or be a no-op depending on impl\n    // Current impl just pops, which returns None\n}\n\n#[test]\nfn test_swap_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x50, 0x40]); // PUSH5, SWAP (needs 2 items)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_swap_empty_stack() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x50, 0x40]); // SWAP with empty stack\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_rot_insufficient_items() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x51, 0x40]); // 1, 2, ROT (needs 3)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_over_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x4B, 0x40]); // PUSH5, OVER (needs 2)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_nip_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x46, 0x40]); // PUSH5, NIP (needs 2)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_tuck_single_item() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x4E, 0x40]); // PUSH5, TUCK (needs 2)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Invalid Opcode Tests\n// ============================================================================\n\n#[test]\nfn test_invalid_opcode() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xFF, 0x40]); // Invalid opcode 0xFF\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_another_invalid_opcode() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0xFE, 0x40]); // Invalid opcode 0xFE\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Invalid Operation Tests\n// ============================================================================\n\n#[test]\nfn test_pow_negative_exponent() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x12, 0x0F, 0xA3, 0x40]); // 2 ^ (-1) - invalid\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_shl_negative_shift() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x0F, 0xA8, 0x40]); // 5 \u003c\u003c (-1) - invalid\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_shr_negative_shift() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x0F, 0xA9, 0x40]); // 5 \u003e\u003e (-1) - invalid\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Pick/Roll Out of Bounds Tests\n// ============================================================================\n\n#[test]\nfn test_pick_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x15, 0x4D, 0x40]); // 1, 2, PUSH5, PICK (index 5 \u003e stack size)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_roll_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x15, 0x52, 0x40]); // 1, 2, PUSH5, ROLL (index 5 \u003e stack size)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_xdrop_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x15, 0x48, 0x40]); // 1, PUSH5, XDROP (index 5 \u003e stack size)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Reverse Tests with Insufficient Items\n// ============================================================================\n\n#[test]\nfn test_reverse3_insufficient() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x53, 0x40]); // 1, 2, REVERSE3 (needs 3)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_reverse4_insufficient() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x54, 0x40]); // 1, 2, 3, REVERSE4 (needs 4)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_reversen_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x11, 0x12, 0x1A, 0x55, 0x40]); // 1, 2, PUSH10, REVERSEN (n=10 \u003e stack)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Slot Access Tests\n// ============================================================================\n\n#[test]\nfn test_ldloc_without_initslot() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x66, 0x40]); // LDLOC0 without INITSLOT\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_ldarg_without_initslot() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x74, 0x40]); // LDARG0 without INITSLOT\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_stloc_without_initslot() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x6D, 0x40]); // PUSH5, STLOC0 without INITSLOT\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Unknown Syscall Tests\n// ============================================================================\n\n#[test]\nfn test_unknown_syscall() {\n    let mut vm = NeoVM::new(1_000_000);\n    // SYSCALL with unknown ID 0xFFFFFFFF\n    let _ = vm.load_script(vec![0x41, 0xFF, 0xFF, 0xFF, 0xFF, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Type Mismatch Tests\n// ============================================================================\n\n#[test]\nfn test_add_with_null() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x0B, 0x15, 0x9E, 0x40]); // PUSHNULL, PUSH5, ADD\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_size_on_integer() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0xCA, 0x40]); // PUSH5, SIZE (integer has no size)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n// ============================================================================\n// Array Operation Error Tests\n// ============================================================================\n\n#[test]\nfn test_pickitem_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    // Create array of size 3, try to access index 5\n    let _ = vm.load_script(vec![0x13, 0xC3, 0x15, 0xCE, 0x40]); // PUSH3, NEWARRAY, PUSH5, PICKITEM\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_setitem_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    // Create array of size 2, try to set index 5\n    let _ = vm.load_script(vec![0x12, 0xC3, 0x15, 0x11, 0xD0, 0x40]); // PUSH2, NEWARRAY, PUSH5, PUSH1, SETITEM\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_remove_out_of_bounds() {\n    let mut vm = NeoVM::new(1_000_000);\n    // Create array of size 2, try to remove index 5\n    let _ = vm.load_script(vec![0x12, 0xC3, 0x15, 0xD2, 0x40]); // PUSH2, NEWARRAY, PUSH5, REMOVE\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_append_to_non_array() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x11, 0xCF, 0x40]); // PUSH5, PUSH1, APPEND (5 is not array)\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n","traces":[{"line":8,"address":[1442704],"length":1,"stats":{"Line":8}},{"line":9,"address":[1442721],"length":1,"stats":{"Line":8}},{"line":10,"address":[1442762],"length":1,"stats":{"Line":8}},{"line":11,"address":[1442809],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","gas_tests.rs"],"content":"//! Gas consumption tests for Neo VM Core\n//!\n//! Tests gas metering and limits.\n\nuse neo_vm_core::{NeoVM, StackItem, VMState};\n\n// Helper to run VM until completion\nfn run_vm(vm: \u0026mut NeoVM) {\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            vm.state = VMState::Fault;\n            break;\n        }\n    }\n}\n\n// ============================================================================\n// Basic Gas Consumption Tests\n// ============================================================================\n\n#[test]\nfn test_gas_consumed_push() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x40]); // PUSH5, RET\n    run_vm(\u0026mut vm);\n    assert!(vm.gas_consumed \u003e 0);\n    assert!(vm.gas_consumed \u003c 10); // Push should be cheap\n}\n\n#[test]\nfn test_gas_consumed_arithmetic() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x13, 0x9E, 0x40]); // 5 + 3\n    run_vm(\u0026mut vm);\n    let gas_with_add = vm.gas_consumed;\n\n    let mut vm2 = NeoVM::new(1_000_000);\n    let _ = vm2.load_script(vec![0x15, 0x13, 0x40]); // Just push\n    run_vm(\u0026mut vm2);\n    let gas_without_add = vm2.gas_consumed;\n\n    assert!(gas_with_add \u003e gas_without_add);\n}\n\n#[test]\nfn test_gas_consumed_multiple_ops() {\n    let mut vm = NeoVM::new(1_000_000);\n    // 5 + 3 + 2 + 1\n    let _ = vm.load_script(vec![0x15, 0x13, 0x9E, 0x12, 0x9E, 0x11, 0x9E, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(vm.gas_consumed \u003e 20); // Multiple operations\n}\n\n// ============================================================================\n// Gas Limit Tests\n// ============================================================================\n\n#[test]\nfn test_out_of_gas_simple() {\n    let mut vm = NeoVM::new(1); // Very low gas limit\n    let _ = vm.load_script(vec![0x15, 0x13, 0x9E, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_out_of_gas_loop() {\n    let mut vm = NeoVM::new(50); // Limited gas\n                                 // Many push operations to exhaust gas\n    let _ = vm.load_script(vec![\n        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,\n        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,\n        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,\n        0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x40,\n    ]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_exact_gas_limit() {\n    // First, measure gas for a simple script\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x40]); // PUSH5, RET\n    run_vm(\u0026mut vm);\n    let required_gas = vm.gas_consumed;\n\n    // Now run with exact gas\n    let mut vm2 = NeoVM::new(required_gas);\n    let _ = vm2.load_script(vec![0x15, 0x40]);\n    run_vm(\u0026mut vm2);\n    assert!(matches!(vm2.state, VMState::Halt));\n}\n\n#[test]\nfn test_one_less_gas() {\n    // First, measure gas for a simple script\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x13, 0x9E, 0x40]); // 5 + 3\n    run_vm(\u0026mut vm);\n    let required_gas = vm.gas_consumed;\n\n    // Now run with one less gas\n    let mut vm2 = NeoVM::new(required_gas - 1);\n    let _ = vm2.load_script(vec![0x15, 0x13, 0x9E, 0x40]);\n    run_vm(\u0026mut vm2);\n    assert!(matches!(vm2.state, VMState::Fault));\n}\n\n// ============================================================================\n// Gas Cost Comparison Tests\n// ============================================================================\n\n#[test]\nfn test_hash_ops_cost_more() {\n    // Hash operations should cost more than arithmetic\n    let mut vm_hash = NeoVM::new(1_000_000);\n    vm_hash.load_script(vec![0x0C, 0x05, b'h', b'e', b'l', b'l', b'o', 0xF0, 0x40]); // PUSHDATA1 \"hello\", SHA256\n    run_vm(\u0026mut vm_hash);\n    let hash_gas = vm_hash.gas_consumed;\n\n    let mut vm_add = NeoVM::new(1_000_000);\n    vm_add.load_script(vec![0x15, 0x13, 0x9E, 0x40]); // 5 + 3\n    run_vm(\u0026mut vm_add);\n    let add_gas = vm_add.gas_consumed;\n\n    assert!(\n        hash_gas \u003e add_gas * 10,\n        \"Hash should cost significantly more than add\"\n    );\n}\n\n#[test]\nfn test_stack_ops_cheaper_than_arithmetic() {\n    let mut vm_stack = NeoVM::new(1_000_000);\n    vm_stack.load_script(vec![0x15, 0x4A, 0x40]); // PUSH5, DUP\n    run_vm(\u0026mut vm_stack);\n    let stack_gas = vm_stack.gas_consumed;\n\n    let mut vm_arith = NeoVM::new(1_000_000);\n    vm_arith.load_script(vec![0x15, 0x13, 0x9E, 0x40]); // 5 + 3\n    run_vm(\u0026mut vm_arith);\n    let arith_gas = vm_arith.gas_consumed;\n\n    // Stack ops should be cheaper or similar\n    assert!(stack_gas \u003c= arith_gas + 5);\n}\n\n// ============================================================================\n// Gas Tracking Tests\n// ============================================================================\n\n#[test]\nfn test_gas_tracking_accuracy() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x40]); // PUSH5, RET\n\n    let initial_gas = vm.gas_consumed;\n    assert_eq!(initial_gas, 0);\n\n    vm.execute_next().unwrap(); // PUSH5\n    let after_push = vm.gas_consumed;\n    assert!(after_push \u003e 0);\n\n    vm.execute_next().unwrap(); // RET\n    let after_ret = vm.gas_consumed;\n    assert!(after_ret \u003e= after_push);\n}\n\n#[test]\nfn test_gas_not_consumed_after_halt() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x40]); // PUSH5, RET\n    run_vm(\u0026mut vm);\n\n    let gas_at_halt = vm.gas_consumed;\n\n    // Try to execute more (should do nothing)\n    let _ = vm.execute_next();\n\n    assert_eq!(vm.gas_consumed, gas_at_halt);\n}\n\n// ============================================================================\n// Complex Script Gas Tests\n// ============================================================================\n\n#[test]\nfn test_complex_script_gas() {\n    let mut vm = NeoVM::new(1_000_000);\n    // Complex script: push, dup, add, mul, compare\n    let _ = vm.load_script(vec![\n        0x15, // PUSH5\n        0x4A, // DUP\n        0x9E, // ADD (5+5=10)\n        0x12, // PUSH2\n        0xA0, // MUL (10*2=20)\n        0x20, // PUSH16\n        0xB7, // GT (20 \u003e 16)\n        0x40, // RET\n    ]);\n    run_vm(\u0026mut vm);\n\n    assert!(matches!(vm.state, VMState::Halt));\n    assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    assert!(vm.gas_consumed \u003e 0);\n}\n\n#[test]\nfn test_array_operations_gas() {\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![\n        0x13, // PUSH3\n        0xC3, // NEWARRAY\n        0xCA, // SIZE\n        0x40, // RET\n    ]);\n    run_vm(\u0026mut vm);\n\n    assert!(matches!(vm.state, VMState::Halt));\n    assert!(vm.gas_consumed \u003e 0);\n}\n\n// ============================================================================\n// Gas Limit Edge Cases\n// ============================================================================\n\n#[test]\nfn test_zero_gas_limit() {\n    let mut vm = NeoVM::new(0);\n    let _ = vm.load_script(vec![0x15, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Fault));\n}\n\n#[test]\nfn test_max_gas_limit() {\n    let mut vm = NeoVM::new(u64::MAX);\n    let _ = vm.load_script(vec![0x15, 0x13, 0x9E, 0x40]);\n    run_vm(\u0026mut vm);\n    assert!(matches!(vm.state, VMState::Halt));\n}\n\n#[test]\nfn test_gas_consumed_equals_limit() {\n    // Find exact gas needed\n    let mut vm = NeoVM::new(1_000_000);\n    let _ = vm.load_script(vec![0x15, 0x40]);\n    run_vm(\u0026mut vm);\n    let exact_gas = vm.gas_consumed;\n\n    // Run with exact gas\n    let mut vm2 = NeoVM::new(exact_gas);\n    vm2.load_script(vec![0x15, 0x40]);\n    run_vm(\u0026mut vm2);\n\n    assert!(matches!(vm2.state, VMState::Halt));\n    assert_eq!(vm2.gas_consumed, exact_gas);\n}\n","traces":[{"line":8,"address":[1427152],"length":1,"stats":{"Line":8}},{"line":9,"address":[1427169],"length":1,"stats":{"Line":8}},{"line":10,"address":[1427210],"length":1,"stats":{"Line":8}},{"line":11,"address":[1427257],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":4},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","native_tests.rs"],"content":"//! Native contract tests for Neo VM Core\n//!\n//! Tests StdLib and CryptoLib native contracts.\n\nuse neo_vm_core::{CryptoLib, NativeContract, NativeRegistry, StackItem, StdLib};\n\n// ============================================================================\n// StdLib Tests\n// ============================================================================\n\n#[test]\nfn test_stdlib_hash() {\n    let stdlib = StdLib::new();\n    let hash = stdlib.hash();\n    assert_eq!(hash.len(), 20);\n}\n\n#[test]\nfn test_stdlib_itoa_decimal() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"itoa\", vec![StackItem::Integer(42)]);\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"42\");\n    }\n}\n\n#[test]\nfn test_stdlib_itoa_hex() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"itoa\",\n        vec![StackItem::Integer(255), StackItem::Integer(16)],\n    );\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"ff\");\n    }\n}\n\n#[test]\nfn test_stdlib_itoa_binary() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"itoa\", vec![StackItem::Integer(5), StackItem::Integer(2)]);\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"101\");\n    }\n}\n\n#[test]\nfn test_stdlib_atoi_decimal() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"atoi\", vec![StackItem::ByteString(b\"42\".to_vec())]);\n\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), StackItem::Integer(42));\n}\n\n#[test]\nfn test_stdlib_atoi_hex() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"atoi\",\n        vec![\n            StackItem::ByteString(b\"ff\".to_vec()),\n            StackItem::Integer(16),\n        ],\n    );\n\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), StackItem::Integer(255));\n}\n\n#[test]\nfn test_stdlib_serialize_deserialize() {\n    let stdlib = StdLib::new();\n    let original = StackItem::Integer(12345);\n\n    let serialized = stdlib.invoke(\"serialize\", vec![original.clone()]);\n    assert!(serialized.is_ok());\n\n    if let Ok(StackItem::ByteString(bytes)) = serialized {\n        let deserialized = stdlib.invoke(\"deserialize\", vec![StackItem::ByteString(bytes)]);\n        assert!(deserialized.is_ok());\n        assert_eq!(deserialized.unwrap(), original);\n    }\n}\n\n#[test]\nfn test_stdlib_base64_encode() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"base64Encode\",\n        vec![StackItem::ByteString(b\"hello\".to_vec())],\n    );\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"aGVsbG8=\");\n    }\n}\n\n#[test]\nfn test_stdlib_base64_decode() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"base64Decode\",\n        vec![StackItem::ByteString(b\"aGVsbG8=\".to_vec())],\n    );\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(bytes, b\"hello\".to_vec());\n    }\n}\n\n#[test]\nfn test_stdlib_json_serialize() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"jsonSerialize\", vec![StackItem::Integer(42)]);\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_stdlib_unknown_method() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"unknownMethod\", vec![]);\n    assert!(result.is_err());\n}\n\n// ============================================================================\n// CryptoLib Tests\n// ============================================================================\n\n#[test]\nfn test_cryptolib_hash() {\n    let cryptolib = CryptoLib::new();\n    let hash = cryptolib.hash();\n    assert_eq!(hash.len(), 20);\n}\n\n#[test]\nfn test_cryptolib_sha256() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\"sha256\", vec![StackItem::ByteString(b\"hello\".to_vec())]);\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(hash)) = result {\n        assert_eq!(hash.len(), 32);\n    }\n}\n\n#[test]\nfn test_cryptolib_sha256_deterministic() {\n    let cryptolib = CryptoLib::new();\n    let result1 = cryptolib.invoke(\"sha256\", vec![StackItem::ByteString(b\"test\".to_vec())]);\n    let result2 = cryptolib.invoke(\"sha256\", vec![StackItem::ByteString(b\"test\".to_vec())]);\n\n    assert_eq!(result1, result2);\n}\n\n#[test]\nfn test_cryptolib_ripemd160() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\"ripemd160\", vec![StackItem::ByteString(b\"hello\".to_vec())]);\n\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(hash)) = result {\n        assert_eq!(hash.len(), 20);\n    }\n}\n\n#[test]\nfn test_cryptolib_unknown_method() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\"unknownMethod\", vec![]);\n    assert!(result.is_err());\n}\n\n// ============================================================================\n// NativeRegistry Tests\n// ============================================================================\n\n#[test]\nfn test_registry_invoke_stdlib() {\n    let registry = NativeRegistry::new();\n    let stdlib = StdLib::new();\n\n    let result = registry.invoke(\u0026stdlib.hash(), \"itoa\", vec![StackItem::Integer(100)]);\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_registry_invoke_cryptolib() {\n    let registry = NativeRegistry::new();\n    let cryptolib = CryptoLib::new();\n\n    let result = registry.invoke(\n        \u0026cryptolib.hash(),\n        \"sha256\",\n        vec![StackItem::ByteString(b\"test\".to_vec())],\n    );\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_registry_unknown_contract() {\n    let registry = NativeRegistry::new();\n    let unknown_hash = [0xFFu8; 20];\n\n    let result = registry.invoke(\u0026unknown_hash, \"method\", vec![]);\n    assert!(result.is_err());\n}\n\n// ============================================================================\n// Input Size Limit Tests\n// ============================================================================\n\n#[test]\nfn test_stdlib_serialize_large_input() {\n    let stdlib = StdLib::new();\n    let large_data = vec![0xFFu8; 1024 * 1024 + 1];\n    let result = stdlib.invoke(\"serialize\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_stdlib_base64_encode_large_input() {\n    let stdlib = StdLib::new();\n    let large_data = vec![0xFFu8; 1024 * 1024 + 1];\n    let result = stdlib.invoke(\"base64Encode\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_stdlib_base64_decode_large_input() {\n    let stdlib = StdLib::new();\n    let large_data = vec![0x41u8; 1024 * 1024 + 1];\n    let result = stdlib.invoke(\"base64Decode\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_stdlib_atoi_large_input() {\n    let stdlib = StdLib::new();\n    let large_data = vec![0x41u8; 1024 * 1024 + 1];\n    let result = stdlib.invoke(\"atoi\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_sha256_large_input() {\n    let cryptolib = CryptoLib::new();\n    let large_data = vec![0xFFu8; 1024 * 1024 + 1];\n    let result = cryptolib.invoke(\"sha256\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_ripemd160_large_input() {\n    let cryptolib = CryptoLib::new();\n    let large_data = vec![0xFFu8; 1024 * 1024 + 1];\n    let result = cryptolib.invoke(\"ripemd160\", vec![StackItem::ByteString(large_data)]);\n    assert!(result.is_err());\n}\n\n// ============================================================================\n// Invalid Input Tests\n// ============================================================================\n\n#[test]\nfn test_stdlib_itoa_invalid_base() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"itoa\", vec![StackItem::Integer(42), StackItem::Integer(8)]);\n    assert!(result.is_err());\n    if let Err(e) = result {\n        assert!(e.contains(\"Unsupported base\"));\n    }\n}\n\n#[test]\nfn test_stdlib_atoi_invalid_base() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"atoi\",\n        vec![StackItem::ByteString(b\"42\".to_vec()), StackItem::Integer(8)],\n    );\n    assert!(result.is_err());\n    if let Err(e) = result {\n        assert!(e.contains(\"Unsupported base\"));\n    }\n}\n\n#[test]\nfn test_stdlib_base64_decode_invalid() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\n        \"base64Decode\",\n        vec![StackItem::ByteString(b\"!!!invalid!!!\".to_vec())],\n    );\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_ecdsa_invalid_signature() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\n        \"verifyWithECDsa\",\n        vec![\n            StackItem::ByteString(b\"message\".to_vec()),\n            StackItem::ByteString(b\"invalid-signature\".to_vec()),\n            StackItem::ByteString(vec![0x04u8; 65]),\n        ],\n    );\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_ecdsa_invalid_public_key() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\n        \"verifyWithECDsa\",\n        vec![\n            StackItem::ByteString(b\"message\".to_vec()),\n            StackItem::ByteString(vec![0u8; 64]),\n            StackItem::ByteString(b\"invalid-key\".to_vec()),\n        ],\n    );\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_ecdsa_wrong_args() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\"verifyWithECDsa\", vec![StackItem::Integer(42)]);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cryptolib_ecdsa_no_public_key() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\n        \"verifyWithECDsa\",\n        vec![\n            StackItem::ByteString(b\"message\".to_vec()),\n            StackItem::ByteString(vec![0u8; 64]),\n        ],\n    );\n    assert!(result.is_err());\n}\n\n// ============================================================================\n// Edge Case Tests\n// ============================================================================\n\n#[test]\nfn test_stdlib_itoa_negative() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"itoa\", vec![StackItem::Integer(-42)]);\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"-42\");\n    }\n}\n\n#[test]\nfn test_stdlib_itoa_zero() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"itoa\", vec![StackItem::Integer(0)]);\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"0\");\n    }\n}\n\n#[test]\nfn test_stdlib_atoi_negative() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"atoi\", vec![StackItem::ByteString(b\"-42\".to_vec())]);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), StackItem::Integer(-42));\n}\n\n#[test]\nfn test_stdlib_base64_encode_empty() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"base64Encode\", vec![StackItem::ByteString(vec![])]);\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert_eq!(String::from_utf8(bytes).unwrap(), \"\");\n    }\n}\n\n#[test]\nfn test_stdlib_base64_decode_empty() {\n    let stdlib = StdLib::new();\n    let result = stdlib.invoke(\"base64Decode\", vec![StackItem::ByteString(vec![])]);\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(bytes)) = result {\n        assert!(bytes.is_empty());\n    }\n}\n\n#[test]\nfn test_cryptolib_sha256_empty() {\n    let cryptolib = CryptoLib::new();\n    let result = cryptolib.invoke(\"sha256\", vec![StackItem::ByteString(vec![])]);\n    assert!(result.is_ok());\n    if let Ok(StackItem::ByteString(hash)) = result {\n        assert_eq!(hash.len(), 32);\n        assert_eq!(\n            hash,\n            vec![\n                0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f,\n                0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b,\n                0x78, 0x52, 0xb8, 0x55\n            ]\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","storage_tests.rs"],"content":"//! Storage integration tests for Neo VM Core\n//!\n//! Tests storage operations and Merkle proof generation.\n\nuse neo_vm_core::{MemoryStorage, StorageBackend, StorageContext, TrackedStorage};\n\n// ============================================================================\n// Basic Storage Operations\n// ============================================================================\n\n#[test]\nfn test_storage_put_get() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n    let result = storage.get(\u0026ctx, b\"key1\");\n\n    assert_eq!(result, Some(b\"value1\".to_vec()));\n}\n\n#[test]\nfn test_storage_get_nonexistent() {\n    let storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    let result = storage.get(\u0026ctx, b\"nonexistent\");\n    assert_eq!(result, None);\n}\n\n#[test]\nfn test_storage_delete() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage.delete(\u0026ctx, b\"key1\");\n\n    let result = storage.get(\u0026ctx, b\"key1\");\n    assert_eq!(result, None);\n}\n\n#[test]\nfn test_storage_overwrite() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage.put(\u0026ctx, b\"key1\", b\"value2\");\n\n    let result = storage.get(\u0026ctx, b\"key1\");\n    assert_eq!(result, Some(b\"value2\".to_vec()));\n}\n\n// ============================================================================\n// Storage Context Isolation\n// ============================================================================\n\n#[test]\nfn test_storage_context_isolation() {\n    let mut storage = MemoryStorage::new();\n    let ctx1 = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n    let ctx2 = StorageContext {\n        script_hash: [2u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx1, b\"key\", b\"value1\");\n    storage.put(\u0026ctx2, b\"key\", b\"value2\");\n\n    assert_eq!(storage.get(\u0026ctx1, b\"key\"), Some(b\"value1\".to_vec()));\n    assert_eq!(storage.get(\u0026ctx2, b\"key\"), Some(b\"value2\".to_vec()));\n}\n\n#[test]\nfn test_storage_read_only() {\n    let mut storage = MemoryStorage::new();\n    let ctx_rw = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n    let ctx_ro = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: true,\n    };\n\n    storage.put(\u0026ctx_rw, b\"key\", b\"value\");\n    storage.put(\u0026ctx_ro, b\"key\", b\"new_value\"); // Should be ignored\n\n    assert_eq!(storage.get(\u0026ctx_rw, b\"key\"), Some(b\"value\".to_vec()));\n}\n\n#[test]\nfn test_storage_read_only_delete() {\n    let mut storage = MemoryStorage::new();\n    let ctx_rw = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n    let ctx_ro = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: true,\n    };\n\n    storage.put(\u0026ctx_rw, b\"key\", b\"value\");\n    storage.delete(\u0026ctx_ro, b\"key\"); // Should be ignored\n\n    assert_eq!(storage.get(\u0026ctx_rw, b\"key\"), Some(b\"value\".to_vec()));\n}\n\n// ============================================================================\n// Storage Find/Prefix Operations\n// ============================================================================\n\n#[test]\nfn test_storage_find_prefix() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"user:1\", b\"alice\");\n    storage.put(\u0026ctx, b\"user:2\", b\"bob\");\n    storage.put(\u0026ctx, b\"user:3\", b\"charlie\");\n    storage.put(\u0026ctx, b\"admin:1\", b\"root\");\n\n    let users = storage.find(\u0026ctx, b\"user:\");\n    assert_eq!(users.len(), 3);\n}\n\n#[test]\nfn test_storage_find_empty_prefix() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage.put(\u0026ctx, b\"key2\", b\"value2\");\n\n    let all = storage.find(\u0026ctx, b\"\");\n    assert_eq!(all.len(), 2);\n}\n\n#[test]\nfn test_storage_find_no_match() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n\n    let results = storage.find(\u0026ctx, b\"nonexistent:\");\n    assert_eq!(results.len(), 0);\n}\n\n// ============================================================================\n// Merkle Root Tests\n// ============================================================================\n\n#[test]\nfn test_merkle_root_empty() {\n    let storage = MemoryStorage::new();\n    let root = storage.merkle_root();\n    assert_eq!(root, [0u8; 32]);\n}\n\n#[test]\nfn test_merkle_root_single_item() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value\");\n    let root = storage.merkle_root();\n\n    assert_ne!(root, [0u8; 32]);\n}\n\n#[test]\nfn test_merkle_root_changes_on_update() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value1\");\n    let root1 = storage.merkle_root();\n\n    storage.put(\u0026ctx, b\"key\", b\"value2\");\n    let root2 = storage.merkle_root();\n\n    assert_ne!(root1, root2);\n}\n\n#[test]\nfn test_merkle_root_deterministic() {\n    let mut storage1 = MemoryStorage::new();\n    let mut storage2 = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage1.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage1.put(\u0026ctx, b\"key2\", b\"value2\");\n\n    storage2.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage2.put(\u0026ctx, b\"key2\", b\"value2\");\n\n    assert_eq!(storage1.merkle_root(), storage2.merkle_root());\n}\n\n// ============================================================================\n// Tracked Storage Tests\n// ============================================================================\n\n#[test]\nfn test_tracked_storage_records_changes() {\n    let mut storage = TrackedStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key1\", b\"value1\");\n    storage.put(\u0026ctx, b\"key2\", b\"value2\");\n\n    let changes = storage.changes();\n    assert_eq!(changes.len(), 2);\n}\n\n#[test]\nfn test_tracked_storage_records_old_value() {\n    let mut storage = TrackedStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value1\");\n    storage.put(\u0026ctx, b\"key\", b\"value2\");\n\n    let changes = storage.changes();\n    assert_eq!(changes.len(), 2);\n    assert_eq!(changes[0].old_value, None);\n    assert_eq!(changes[1].old_value, Some(b\"value1\".to_vec()));\n}\n\n#[test]\nfn test_tracked_storage_records_delete() {\n    let mut storage = TrackedStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value\");\n    storage.delete(\u0026ctx, b\"key\");\n\n    let changes = storage.changes();\n    assert_eq!(changes.len(), 2);\n    assert_eq!(changes[1].new_value, None);\n}\n\n#[test]\nfn test_tracked_storage_merkle_root() {\n    let mut storage = TrackedStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value\");\n    let root = storage.merkle_root();\n\n    assert_ne!(root, [0u8; 32]);\n}\n\n// ============================================================================\n// Storage Edge Cases and Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_storage_empty_context() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [0u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value\");\n    let result = storage.get(\u0026ctx, b\"key\");\n\n    assert_eq!(result, Some(b\"value\".to_vec()));\n}\n\n#[test]\nfn test_storage_empty_key() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"\", b\"value\");\n    let result = storage.get(\u0026ctx, b\"\");\n\n    assert_eq!(result, Some(b\"value\".to_vec()));\n}\n\n#[test]\nfn test_storage_empty_value() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"\");\n    let result = storage.get(\u0026ctx, b\"key\");\n\n    assert_eq!(result, Some(b\"\".to_vec()));\n}\n\n#[test]\nfn test_storage_hundred_items() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    // Put 100 key-value pairs\n    for i in 0..100 {\n        let key = format!(\"key{}\", i);\n        let value = format!(\"value{}\", i);\n        storage.put(\u0026ctx, key.as_bytes(), value.as_bytes());\n    }\n\n    // Verify all values\n    for i in 0..100 {\n        let key = format!(\"key{}\", i);\n        let expected = format!(\"value{}\", i);\n        let result = storage.get(\u0026ctx, key.as_bytes());\n        assert_eq!(result, Some(expected.into_bytes()));\n    }\n}\n\n#[test]\nfn test_storage_key_overwrite() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value1\");\n    storage.put(\u0026ctx, b\"key\", b\"value2\");\n    storage.put(\u0026ctx, b\"key\", b\"value3\");\n\n    let result = storage.get(\u0026ctx, b\"key\");\n    assert_eq!(result, Some(b\"value3\".to_vec()));\n}\n\n#[test]\nfn test_merkle_root_empty_storage() {\n    let storage = MemoryStorage::new();\n    let root = storage.merkle_root();\n\n    assert_eq!(root, [0u8; 32]);\n}\n\n#[test]\nfn test_merkle_root_single_entry() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    storage.put(\u0026ctx, b\"key\", b\"value\");\n    let root = storage.merkle_root();\n\n    assert_ne!(root, [0u8; 32]);\n    // Same input should produce same root\n    let root2 = storage.merkle_root();\n    assert_eq!(root, root2);\n}\n\n#[test]\nfn test_merkle_root_1000_items() {\n    let mut storage = MemoryStorage::new();\n    let ctx = StorageContext {\n        script_hash: [1u8; 20],\n        read_only: false,\n    };\n\n    // Add 1000 items\n    for i in 0..1000 {\n        let key = format!(\"key{:04}\", i);\n        let value = format!(\"value{:04}\", i);\n        storage.put(\u0026ctx, key.as_bytes(), value.as_bytes());\n    }\n\n    let root = storage.merkle_root();\n\n    // Root should be non-zero for non-empty storage\n    assert_ne!(root, [0u8; 32]);\n    // Root should be deterministic\n    let root2 = storage.merkle_root();\n    assert_eq!(root, root2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-core","tests","vm_tests.rs"],"content":"//! Unit tests for Neo VM Core\n\n#[cfg(test)]\nmod tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_push_operations() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x11, 0x12, 0x13, 0x40]); // PUSH1, PUSH2, PUSH3, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert!(matches!(vm.state, VMState::Halt));\n        assert_eq!(vm.eval_stack.len(), 3);\n    }\n\n    #[test]\n    fn test_add_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x12, 0x13, 0x9E, 0x40]); // PUSH2, PUSH3, ADD, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n\n    #[test]\n    fn test_sub_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x12, 0x9F, 0x40]); // PUSH5, PUSH2, SUB, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n}\n\n#[cfg(test)]\nmod arithmetic_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_mul_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x13, 0x14, 0xA0, 0x40]); // PUSH3, PUSH4, MUL, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(12)));\n    }\n\n    #[test]\n    fn test_div_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x18, 0x12, 0xA1, 0x40]); // PUSH8, PUSH2, DIV, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(4)));\n    }\n\n    #[test]\n    fn test_mod_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x17, 0x13, 0xA2, 0x40]); // PUSH7, PUSH3, MOD, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n    }\n\n    #[test]\n    fn test_negate_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x9B, 0x40]); // PUSH5, NEGATE, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(-5)));\n    }\n\n    #[test]\n    fn test_inc_dec_operations() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x9C, 0x9C, 0x9D, 0x40]); // PUSH5, INC, INC, DEC, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(6)));\n    }\n\n    #[test]\n    fn test_abs_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x0F, 0x15, 0x9F, 0x9A, 0x40]); // PUSHM1, PUSH5, SUB, ABS, RET (-6 -\u003e 6)\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(6)));\n    }\n\n    #[test]\n    fn test_sign_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x99, 0x40]); // PUSH5, SIGN, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(1)));\n    }\n\n    #[test]\n    fn test_min_max_operations() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x13, 0x17, 0xB9, 0x40]); // PUSH3, PUSH7, MIN, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n}\n\n#[cfg(test)]\nmod stack_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_dup_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x4A, 0x40]); // PUSH5, DUP, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.len(), 2);\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n\n    #[test]\n    fn test_drop_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x45, 0x40]); // PUSH5, PUSH6, DROP, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.len(), 1);\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n\n    #[test]\n    fn test_swap_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x50, 0x40]); // PUSH5, PUSH6, SWAP, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(6)));\n    }\n\n    #[test]\n    fn test_over_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x4B, 0x40]); // PUSH5, PUSH6, OVER, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.len(), 3);\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n\n    #[test]\n    fn test_nip_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x46, 0x40]); // PUSH5, PUSH6, NIP, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.len(), 1);\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(6)));\n    }\n\n    #[test]\n    fn test_clear_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x17, 0x49, 0x40]); // PUSH5, PUSH6, PUSH7, CLEAR, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.len(), 0);\n    }\n\n    #[test]\n    fn test_depth_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x16, 0x17, 0x43, 0x40]); // PUSH5, PUSH6, PUSH7, DEPTH, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n}\n\n#[cfg(test)]\nmod comparison_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_lt_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x13, 0x15, 0xB5, 0x40]); // PUSH3, PUSH5, LT, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n\n    #[test]\n    fn test_gt_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x13, 0xB7, 0x40]); // PUSH5, PUSH3, GT, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n\n    #[test]\n    fn test_equal_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0x15, 0x97, 0x40]); // PUSH5, PUSH5, EQUAL, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n}\n\n#[cfg(test)]\nmod bitwise_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_and_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        // 0x0F (15) AND 0x03 (3) = 0x03 (3)\n        let _ = vm.load_script(vec![0x1F, 0x13, 0x91, 0x40]); // PUSH15, PUSH3, AND, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n\n    #[test]\n    fn test_or_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        // 0x08 (8) OR 0x03 (3) = 0x0B (11)\n        let _ = vm.load_script(vec![0x18, 0x13, 0x92, 0x40]); // PUSH8, PUSH3, OR, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(11)));\n    }\n\n    #[test]\n    fn test_xor_operation() {\n        let mut vm = NeoVM::new(1_000_000);\n        // 0x0F (15) XOR 0x03 (3) = 0x0C (12)\n        let _ = vm.load_script(vec![0x1F, 0x13, 0x93, 0x40]); // PUSH15, PUSH3, XOR, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(12)));\n    }\n}\n\n#[cfg(test)]\nmod array_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_newarray0() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0xC2, 0x40]); // NEWARRAY0, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Array(vec![])));\n    }\n\n    #[test]\n    fn test_newarray_with_size() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x13, 0xC3, 0xCA, 0x40]); // PUSH3, NEWARRAY, SIZE, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(3)));\n    }\n\n    #[test]\n    fn test_isnull() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x0B, 0xD8, 0x40]); // PUSHNULL, ISNULL, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n\n    #[test]\n    fn test_nz() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x15, 0xB1, 0x40]); // PUSH5, NZ, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Boolean(true)));\n    }\n}\n\n#[cfg(test)]\nmod control_flow_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_nop() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x21, 0x15, 0x40]); // NOP, PUSH5, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n}\n\n#[cfg(test)]\nmod pushdata_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_pushint8() {\n        let mut vm = NeoVM::new(1_000_000);\n        let _ = vm.load_script(vec![0x00, 0x7F, 0x40]); // PUSHINT8 127, RET\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(127)));\n    }\n}\n\n#[cfg(test)]\nmod slot_tests {\n    use neo_vm_core::{NeoVM, StackItem, VMState};\n\n    #[test]\n    fn test_initslot() {\n        let mut vm = NeoVM::new(1_000_000);\n        // PUSH5, INITSLOT(1 local, 1 arg), LDARG0, RET\n        let _ = vm.load_script(vec![0x15, 0x57, 0x01, 0x01, 0x74, 0x40]);\n\n        while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n            vm.execute_next().unwrap();\n        }\n\n        assert_eq!(vm.eval_stack.pop(), Some(StackItem::Integer(5)));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-vm-guest","src","lib.rs"],"content":"//! Neo VM Guest Program for zkVM proving\n\nuse neo_vm_core::{NeoVM, StackItem, VMState};\nuse serde::{Deserialize, Serialize};\n\n/// Input for zkVM proving\n#[derive(Serialize, Deserialize, Clone)]\npub struct ProofInput {\n    pub script: Vec\u003cu8\u003e,\n    pub arguments: Vec\u003cStackItem\u003e,\n    pub gas_limit: u64,\n}\n\n/// Output from zkVM execution\n#[derive(Serialize, Deserialize)]\npub struct ProofOutput {\n    pub state: u8,\n    pub result: Option\u003cStackItem\u003e,\n    pub gas_consumed: u64,\n    pub error: Option\u003cString\u003e,\n}\n\n/// Execute Neo VM and return proof output\npub fn execute(input: ProofInput) -\u003e ProofOutput {\n    let mut vm = NeoVM::new(input.gas_limit);\n    if let Err(e) = vm.load_script(input.script) {\n        return ProofOutput {\n            state: 1,\n            gas_consumed: vm.gas_consumed,\n            result: Some(StackItem::Boolean(false)),\n            error: Some(e.to_string()),\n        };\n    }\n\n    // Push arguments\n    for arg in input.arguments {\n        vm.eval_stack.push(arg);\n    }\n\n    // Execute until halt or fault\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            vm.state = VMState::Fault;\n            break;\n        }\n    }\n\n    let state = match vm.state {\n        VMState::Halt =\u003e 0,\n        VMState::Fault =\u003e 1,\n        _ =\u003e 2,\n    };\n\n    ProofOutput {\n        state,\n        result: vm.eval_stack.pop(),\n        gas_consumed: vm.gas_consumed,\n        error: None,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-cli","src","assembler.rs"],"content":"//! Neo zkVM Assembler with macro support and syntax sugar\n//!\n//! Features:\n//! - Full Neo N3 opcode support\n//! - Macro definitions and expansion\n//! - Labels and symbolic jumps\n//! - Syntax sugar for common patterns\n//! - Comprehensive error messages\n\n#![allow(dead_code)]\n\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone)]\npub enum AssemblerError {\n    UnknownOpcode(String, usize),\n    InvalidOperand(String, usize),\n    UndefinedLabel(String, usize),\n    DuplicateLabel(String, usize),\n    UndefinedMacro(String, usize),\n    InvalidMacroDefinition(String, usize),\n    SyntaxError(String, usize),\n}\n\nimpl std::fmt::Display for AssemblerError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::UnknownOpcode(op, line) =\u003e write!(f, \"Unknown opcode '{}' at line {}\", op, line),\n            Self::InvalidOperand(msg, line) =\u003e {\n                write!(f, \"Invalid operand at line {}: {}\", line, msg)\n            }\n            Self::UndefinedLabel(label, line) =\u003e {\n                write!(f, \"Undefined label '{}' at line {}\", label, line)\n            }\n            Self::DuplicateLabel(label, line) =\u003e {\n                write!(f, \"Duplicate label '{}' at line {}\", label, line)\n            }\n            Self::UndefinedMacro(name, line) =\u003e {\n                write!(f, \"Undefined macro '{}' at line {}\", name, line)\n            }\n            Self::InvalidMacroDefinition(msg, line) =\u003e {\n                write!(f, \"Invalid macro at line {}: {}\", line, msg)\n            }\n            Self::SyntaxError(msg, line) =\u003e write!(f, \"Syntax error at line {}: {}\", line, msg),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct Macro {\n    params: Vec\u003cString\u003e,\n    body: Vec\u003cString\u003e,\n}\n\nconst MAX_MACRO_DEPTH: usize = 100;\n\npub struct Assembler {\n    labels: HashMap\u003cString, usize\u003e,\n    macros: HashMap\u003cString, Macro\u003e,\n    pending_labels: Vec\u003c(usize, String, usize, bool)\u003e,\n    warnings: Vec\u003cString\u003e,\n    macro_depth: usize,\n}\n\nimpl Assembler {\n    pub fn new() -\u003e Self {\n        Self {\n            labels: HashMap::new(),\n            macros: HashMap::new(),\n            pending_labels: Vec::new(),\n            warnings: Vec::new(),\n            macro_depth: 0,\n        }\n    }\n\n    pub fn warnings(\u0026self) -\u003e \u0026[String] {\n        \u0026self.warnings\n    }\n\n    pub fn assemble(\u0026mut self, source: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e, String\u003e {\n        // First pass: collect macros and labels\n        let expanded = self.preprocess(source)?;\n\n        // Second pass: generate bytecode\n        let mut bytecode = Vec::new();\n\n        for (line_num, line) in expanded.iter().enumerate() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with(';') || line.starts_with('#') {\n                continue;\n            }\n\n            // Handle labels\n            if line.ends_with(':') {\n                let label = line.trim_end_matches(':').to_string();\n                if self.labels.contains_key(\u0026label) {\n                    return Err(AssemblerError::DuplicateLabel(label, line_num + 1).to_string());\n                }\n                self.labels.insert(label, bytecode.len());\n                continue;\n            }\n\n            self.assemble_line(line, \u0026mut bytecode, line_num + 1)?;\n        }\n\n        // Resolve pending label references\n        self.resolve_labels(\u0026mut bytecode)?;\n\n        Ok(bytecode)\n    }\n\n    fn preprocess(\u0026mut self, source: \u0026str) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        let mut result = Vec::new();\n        let mut in_macro = false;\n        let mut current_macro_name = String::new();\n        let mut current_macro_params = Vec::new();\n        let mut current_macro_body = Vec::new();\n\n        for (line_num, line) in source.lines().enumerate() {\n            let trimmed = line.trim();\n\n            // Macro definition start\n            if trimmed.starts_with(\".macro\") || trimmed.starts_with(\"%macro\") {\n                in_macro = true;\n                let parts: Vec\u003c\u0026str\u003e = trimmed.split_whitespace().collect();\n                if parts.len() \u003c 2 {\n                    return Err(AssemblerError::InvalidMacroDefinition(\n                        \"Missing macro name\".to_string(),\n                        line_num + 1,\n                    )\n                    .to_string());\n                }\n                current_macro_name = parts[1].to_string();\n                current_macro_params = parts[2..].iter().map(|s| s.to_string()).collect();\n                current_macro_body.clear();\n                continue;\n            }\n\n            // Macro definition end\n            if trimmed == \".endmacro\" || trimmed == \"%endmacro\" {\n                in_macro = false;\n                self.macros.insert(\n                    current_macro_name.clone(),\n                    Macro {\n                        params: current_macro_params.clone(),\n                        body: current_macro_body.clone(),\n                    },\n                );\n                continue;\n            }\n\n            if in_macro {\n                current_macro_body.push(line.to_string());\n                continue;\n            }\n\n            // Macro invocation\n            if trimmed.starts_with('%') \u0026\u0026 !trimmed.starts_with(\"%macro\") {\n                let expanded = self.expand_macro(trimmed, line_num + 1)?;\n                result.extend(expanded);\n                continue;\n            }\n\n            // Syntax sugar expansion\n            let expanded = self.expand_sugar(trimmed, line_num + 1)?;\n            result.extend(expanded);\n        }\n\n        Ok(result)\n    }\n\n    fn expand_macro(\u0026mut self, line: \u0026str, line_num: usize) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        if self.macro_depth \u003e= MAX_MACRO_DEPTH {\n            return Err(format!(\n                \"Macro expansion exceeded maximum depth {} at line {}\",\n                MAX_MACRO_DEPTH, line_num\n            )\n            .to_string());\n        }\n        self.macro_depth += 1;\n\n        let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n        let name = parts[0].trim_start_matches('%');\n\n        let macro_def = self.macros.get(name).ok_or_else(|| {\n            AssemblerError::UndefinedMacro(name.to_string(), line_num).to_string()\n        })?;\n\n        let args: Vec\u003c\u0026str\u003e = parts[1..].to_vec();\n\n        if args.len() \u003c macro_def.params.len() {\n            self.macro_depth -= 1;\n            return Err(format!(\n                \"Macro '{}' requires {} arguments but got {} at line {}\",\n                name,\n                macro_def.params.len(),\n                args.len(),\n                line_num\n            )\n            .to_string());\n        }\n\n        let mut result = Vec::new();\n\n        for body_line in \u0026macro_def.body {\n            let mut expanded = body_line.clone();\n            for (i, param) in macro_def.params.iter().enumerate() {\n                if i \u003c args.len() {\n                    expanded = expanded.replace(param, args[i]);\n                }\n            }\n            result.push(expanded);\n        }\n\n        self.macro_depth -= 1;\n        Ok(result)\n    }\n\n    fn expand_sugar(\u0026self, line: \u0026str, _line_num: usize) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n        if parts.is_empty() {\n            return Ok(vec![line.to_string()]);\n        }\n\n        // Check if this looks like multiple simple opcodes on one line\n        // (all parts are valid simple opcodes without operands)\n        if parts.len() \u003e 1 \u0026\u0026 parts.iter().all(|p| self.is_simple_opcode(p)) {\n            return Ok(parts.iter().map(|s| s.to_uppercase()).collect());\n        }\n\n        let op = parts[0].to_uppercase();\n\n        // Syntax sugar expansions\n        match op.as_str() {\n            // PUSH \u003cn\u003e - auto-select optimal push instruction\n            \"PUSH\" if parts.len() \u003e 1 =\u003e {\n                if let Ok(n) = parts[1].parse::\u003ci128\u003e() {\n                    return Ok(vec![self.optimal_push(n)]);\n                }\n            }\n            // INC2, INC3, etc. - multiple increments\n            s if s.starts_with(\"INC\") \u0026\u0026 s.len() \u003e 3 =\u003e {\n                if let Ok(n) = s[3..].parse::\u003cusize\u003e() {\n                    return Ok(vec![\"INC\".to_string(); n]);\n                }\n            }\n            // DEC2, DEC3, etc. - multiple decrements\n            s if s.starts_with(\"DEC\") \u0026\u0026 s.len() \u003e 3 =\u003e {\n                if let Ok(n) = s[3..].parse::\u003cusize\u003e() {\n                    return Ok(vec![\"DEC\".to_string(); n]);\n                }\n            }\n            // DUP2, DUP3, etc. - multiple duplicates\n            s if s.starts_with(\"DUP\") \u0026\u0026 s.len() \u003e 3 =\u003e {\n                if let Ok(n) = s[3..].parse::\u003cusize\u003e() {\n                    return Ok(vec![\"DUP\".to_string(); n]);\n                }\n            }\n            // DROP2, DROP3, etc. - multiple drops\n            s if s.starts_with(\"DROP\") \u0026\u0026 s.len() \u003e 4 =\u003e {\n                if let Ok(n) = s[4..].parse::\u003cusize\u003e() {\n                    return Ok(vec![\"DROP\".to_string(); n]);\n                }\n            }\n            // NOP2, NOP3, etc. - multiple nops\n            s if s.starts_with(\"NOP\") \u0026\u0026 s.len() \u003e 3 =\u003e {\n                if let Ok(n) = s[3..].parse::\u003cusize\u003e() {\n                    return Ok(vec![\"NOP\".to_string(); n]);\n                }\n            }\n            _ =\u003e {}\n        }\n\n        Ok(vec![line.to_string()])\n    }\n\n    fn is_simple_opcode(\u0026self, s: \u0026str) -\u003e bool {\n        let op = s.to_uppercase();\n        matches!(\n            op.as_str(),\n            \"PUSH0\"\n                | \"PUSH1\"\n                | \"PUSH2\"\n                | \"PUSH3\"\n                | \"PUSH4\"\n                | \"PUSH5\"\n                | \"PUSH6\"\n                | \"PUSH7\"\n                | \"PUSH8\"\n                | \"PUSH9\"\n                | \"PUSH10\"\n                | \"PUSH11\"\n                | \"PUSH12\"\n                | \"PUSH13\"\n                | \"PUSH14\"\n                | \"PUSH15\"\n                | \"PUSH16\"\n                | \"PUSHM1\"\n                | \"PUSHNULL\"\n                | \"TRUE\"\n                | \"FALSE\"\n                | \"NOP\"\n                | \"RET\"\n                | \"ABORT\"\n                | \"ASSERT\"\n                | \"THROW\"\n                | \"DEPTH\"\n                | \"DROP\"\n                | \"NIP\"\n                | \"CLEAR\"\n                | \"DUP\"\n                | \"OVER\"\n                | \"PICK\"\n                | \"TUCK\"\n                | \"SWAP\"\n                | \"ROT\"\n                | \"ROLL\"\n                | \"REVERSE3\"\n                | \"REVERSE4\"\n                | \"REVERSEN\"\n                | \"XDROP\"\n                | \"ADD\"\n                | \"SUB\"\n                | \"MUL\"\n                | \"DIV\"\n                | \"MOD\"\n                | \"POW\"\n                | \"SQRT\"\n                | \"SHL\"\n                | \"SHR\"\n                | \"INC\"\n                | \"DEC\"\n                | \"SIGN\"\n                | \"ABS\"\n                | \"NEGATE\"\n                | \"NEG\"\n                | \"INVERT\"\n                | \"AND\"\n                | \"OR\"\n                | \"XOR\"\n                | \"EQUAL\"\n                | \"NOTEQUAL\"\n                | \"NOT\"\n                | \"BOOLAND\"\n                | \"BOOLOR\"\n                | \"NZ\"\n                | \"LT\"\n                | \"LE\"\n                | \"GT\"\n                | \"GE\"\n                | \"MIN\"\n                | \"MAX\"\n                | \"WITHIN\"\n                | \"NUMEQUAL\"\n                | \"NUMNOTEQUAL\"\n                | \"NEWARRAY0\"\n                | \"NEWARRAY\"\n                | \"NEWSTRUCT0\"\n                | \"NEWSTRUCT\"\n                | \"NEWMAP\"\n                | \"SIZE\"\n                | \"HASKEY\"\n                | \"KEYS\"\n                | \"VALUES\"\n                | \"PICKITEM\"\n                | \"APPEND\"\n                | \"SETITEM\"\n                | \"REVERSEITEMS\"\n                | \"REMOVE\"\n                | \"CLEARITEMS\"\n                | \"POPITEM\"\n                | \"PACK\"\n                | \"UNPACK\"\n                | \"ISNULL\"\n                | \"SHA256\"\n                | \"RIPEMD160\"\n                | \"HASH160\"\n                | \"CHECKSIG\"\n                | \"LDLOC0\"\n                | \"LDLOC1\"\n                | \"LDLOC2\"\n                | \"LDLOC3\"\n                | \"LDLOC4\"\n                | \"LDLOC5\"\n                | \"STLOC0\"\n                | \"STLOC1\"\n                | \"STLOC2\"\n                | \"STLOC3\"\n                | \"STLOC4\"\n                | \"STLOC5\"\n                | \"LDARG0\"\n                | \"LDARG1\"\n                | \"LDARG2\"\n                | \"LDARG3\"\n                | \"LDARG4\"\n                | \"LDARG5\"\n        )\n    }\n\n    fn optimal_push(\u0026self, n: i128) -\u003e String {\n        match n {\n            -1 =\u003e \"PUSHM1\".to_string(),\n            0..=16 =\u003e format!(\"PUSH{}\", n),\n            -128..=127 =\u003e format!(\"PUSHINT8 {}\", n),\n            -32768..=32767 =\u003e format!(\"PUSHINT16 {}\", n),\n            _ =\u003e format!(\"PUSHINT32 {}\", n),\n        }\n    }\n\n    fn assemble_line(\n        \u0026mut self,\n        line: \u0026str,\n        bytecode: \u0026mut Vec\u003cu8\u003e,\n        line_num: usize,\n    ) -\u003e Result\u003c(), String\u003e {\n        let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n        if parts.is_empty() {\n            return Ok(());\n        }\n\n        let op = parts[0].to_uppercase();\n        let operands = \u0026parts[1..];\n\n        match op.as_str() {\n            // Constants\n            \"PUSHINT8\" =\u003e {\n                bytecode.push(0x00);\n                let val = self.parse_int(operands, line_num)? as i8;\n                bytecode.push(val as u8);\n            }\n            \"PUSHINT16\" =\u003e {\n                bytecode.push(0x01);\n                let val = self.parse_int(operands, line_num)? as i16;\n                bytecode.extend_from_slice(\u0026val.to_le_bytes());\n            }\n            \"PUSHINT32\" =\u003e {\n                bytecode.push(0x02);\n                let val = self.parse_int(operands, line_num)? as i32;\n                bytecode.extend_from_slice(\u0026val.to_le_bytes());\n            }\n            \"PUSHINT64\" =\u003e {\n                bytecode.push(0x03);\n                let val = self.parse_int(operands, line_num)?;\n                bytecode.extend_from_slice(\u0026val.to_le_bytes());\n            }\n            \"PUSHNULL\" =\u003e bytecode.push(0x0B),\n            \"PUSHDATA1\" =\u003e {\n                bytecode.push(0x0C);\n                let data = self.parse_data(operands, line_num)?;\n                let len = data.len();\n                if len \u003e 255 {\n                    return Err(format!(\n                        \"PUSHDATA1 length {} exceeds maximum 255 at line {}\",\n                        len, line_num\n                    )\n                    .to_string());\n                }\n                bytecode.push(len as u8);\n                bytecode.extend_from_slice(\u0026data);\n            }\n            \"PUSHDATA2\" =\u003e {\n                bytecode.push(0x0D);\n                let data = self.parse_data(operands, line_num)?;\n                let len = data.len();\n                if len \u003e u16::MAX as usize {\n                    return Err(format!(\n                        \"PUSHDATA2 length {} exceeds maximum {} at line {}\",\n                        len,\n                        u16::MAX,\n                        line_num\n                    )\n                    .to_string());\n                }\n                bytecode.extend_from_slice(\u0026(len as u16).to_le_bytes());\n                bytecode.extend_from_slice(\u0026data);\n            }\n            \"PUSHM1\" =\u003e bytecode.push(0x0F),\n            \"PUSH0\" | \"PUSHF\" | \"FALSE\" =\u003e bytecode.push(0x10),\n            \"PUSH1\" | \"PUSHT\" | \"TRUE\" =\u003e bytecode.push(0x11),\n            \"PUSH2\" =\u003e bytecode.push(0x12),\n            \"PUSH3\" =\u003e bytecode.push(0x13),\n            \"PUSH4\" =\u003e bytecode.push(0x14),\n            \"PUSH5\" =\u003e bytecode.push(0x15),\n            \"PUSH6\" =\u003e bytecode.push(0x16),\n            \"PUSH7\" =\u003e bytecode.push(0x17),\n            \"PUSH8\" =\u003e bytecode.push(0x18),\n            \"PUSH9\" =\u003e bytecode.push(0x19),\n            \"PUSH10\" =\u003e bytecode.push(0x1A),\n            \"PUSH11\" =\u003e bytecode.push(0x1B),\n            \"PUSH12\" =\u003e bytecode.push(0x1C),\n            \"PUSH13\" =\u003e bytecode.push(0x1D),\n            \"PUSH14\" =\u003e bytecode.push(0x1E),\n            \"PUSH15\" =\u003e bytecode.push(0x1F),\n            \"PUSH16\" =\u003e bytecode.push(0x20),\n\n            // Flow control\n            \"NOP\" =\u003e bytecode.push(0x21),\n            \"JMP\" =\u003e {\n                bytecode.push(0x22);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMP_L\" =\u003e {\n                bytecode.push(0x23);\n                self.emit_jump_offset_long(bytecode, operands, line_num)?;\n            }\n            \"JMPIF\" =\u003e {\n                bytecode.push(0x24);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPIFNOT\" =\u003e {\n                bytecode.push(0x26);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPEQ\" =\u003e {\n                bytecode.push(0x28);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPNE\" =\u003e {\n                bytecode.push(0x2A);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPGT\" =\u003e {\n                bytecode.push(0x2C);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPGE\" =\u003e {\n                bytecode.push(0x2E);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPLT\" =\u003e {\n                bytecode.push(0x30);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"JMPLE\" =\u003e {\n                bytecode.push(0x32);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"CALL\" =\u003e {\n                bytecode.push(0x34);\n                self.emit_jump_offset(bytecode, operands, line_num)?;\n            }\n            \"ABORT\" =\u003e bytecode.push(0x38),\n            \"ASSERT\" =\u003e bytecode.push(0x39),\n            \"THROW\" =\u003e bytecode.push(0x3A),\n            \"RET\" =\u003e bytecode.push(0x40),\n            \"SYSCALL\" =\u003e {\n                bytecode.push(0x41);\n                let id = self.parse_syscall_id(operands, line_num)?;\n                bytecode.extend_from_slice(\u0026id.to_le_bytes());\n            }\n\n            // Stack operations\n            \"DEPTH\" =\u003e bytecode.push(0x43),\n            \"DROP\" =\u003e bytecode.push(0x45),\n            \"NIP\" =\u003e bytecode.push(0x46),\n            \"XDROP\" =\u003e bytecode.push(0x48),\n            \"CLEAR\" =\u003e bytecode.push(0x49),\n            \"DUP\" =\u003e bytecode.push(0x4A),\n            \"OVER\" =\u003e bytecode.push(0x4B),\n            \"PICK\" =\u003e bytecode.push(0x4D),\n            \"TUCK\" =\u003e bytecode.push(0x4E),\n            \"SWAP\" =\u003e bytecode.push(0x50),\n            \"ROT\" =\u003e bytecode.push(0x51),\n            \"ROLL\" =\u003e bytecode.push(0x52),\n            \"REVERSE3\" =\u003e bytecode.push(0x53),\n            \"REVERSE4\" =\u003e bytecode.push(0x54),\n            \"REVERSEN\" =\u003e bytecode.push(0x55),\n\n            // Slot operations\n            \"INITSLOT\" =\u003e {\n                bytecode.push(0x57);\n                let (locals, args) = self.parse_slot_args(operands, line_num)?;\n                bytecode.push(locals);\n                bytecode.push(args);\n            }\n            \"LDLOC0\" =\u003e bytecode.push(0x66),\n            \"LDLOC1\" =\u003e bytecode.push(0x67),\n            \"LDLOC2\" =\u003e bytecode.push(0x68),\n            \"LDLOC3\" =\u003e bytecode.push(0x69),\n            \"LDLOC4\" =\u003e bytecode.push(0x6A),\n            \"LDLOC5\" =\u003e bytecode.push(0x6B),\n            \"LDLOC\" =\u003e {\n                bytecode.push(0x6C);\n                let idx = self.parse_u8(operands, line_num)?;\n                bytecode.push(idx);\n            }\n            \"STLOC0\" =\u003e bytecode.push(0x6D),\n            \"STLOC1\" =\u003e bytecode.push(0x6E),\n            \"STLOC2\" =\u003e bytecode.push(0x6F),\n            \"STLOC3\" =\u003e bytecode.push(0x70),\n            \"STLOC4\" =\u003e bytecode.push(0x71),\n            \"STLOC5\" =\u003e bytecode.push(0x72),\n            \"STLOC\" =\u003e {\n                bytecode.push(0x73);\n                let idx = self.parse_u8(operands, line_num)?;\n                bytecode.push(idx);\n            }\n            \"LDARG0\" =\u003e bytecode.push(0x74),\n            \"LDARG1\" =\u003e bytecode.push(0x75),\n            \"LDARG2\" =\u003e bytecode.push(0x76),\n            \"LDARG3\" =\u003e bytecode.push(0x77),\n            \"LDARG4\" =\u003e bytecode.push(0x78),\n            \"LDARG5\" =\u003e bytecode.push(0x79),\n            \"LDARG\" =\u003e {\n                bytecode.push(0x7A);\n                let idx = self.parse_u8(operands, line_num)?;\n                bytecode.push(idx);\n            }\n\n            // Bitwise operations\n            \"INVERT\" =\u003e bytecode.push(0x90),\n            \"AND\" =\u003e bytecode.push(0x91),\n            \"OR\" =\u003e bytecode.push(0x92),\n            \"XOR\" =\u003e bytecode.push(0x93),\n            \"EQUAL\" =\u003e bytecode.push(0x97),\n            \"NOTEQUAL\" =\u003e bytecode.push(0x98),\n\n            // Arithmetic\n            \"SIGN\" =\u003e bytecode.push(0x99),\n            \"ABS\" =\u003e bytecode.push(0x9A),\n            \"NEGATE\" | \"NEG\" =\u003e bytecode.push(0x9B),\n            \"INC\" =\u003e bytecode.push(0x9C),\n            \"DEC\" =\u003e bytecode.push(0x9D),\n            \"ADD\" =\u003e bytecode.push(0x9E),\n            \"SUB\" =\u003e bytecode.push(0x9F),\n            \"MUL\" =\u003e bytecode.push(0xA0),\n            \"DIV\" =\u003e bytecode.push(0xA1),\n            \"MOD\" =\u003e bytecode.push(0xA2),\n            \"POW\" =\u003e bytecode.push(0xA3),\n            \"SQRT\" =\u003e bytecode.push(0xA4),\n            \"SHL\" =\u003e bytecode.push(0xA8),\n            \"SHR\" =\u003e bytecode.push(0xA9),\n            \"NOT\" =\u003e bytecode.push(0xAA),\n            \"BOOLAND\" =\u003e bytecode.push(0xAB),\n            \"BOOLOR\" =\u003e bytecode.push(0xAC),\n            \"NZ\" =\u003e bytecode.push(0xB1),\n            \"NUMEQUAL\" =\u003e bytecode.push(0xB3),\n            \"NUMNOTEQUAL\" =\u003e bytecode.push(0xB4),\n            \"LT\" =\u003e bytecode.push(0xB5),\n            \"LE\" =\u003e bytecode.push(0xB6),\n            \"GT\" =\u003e bytecode.push(0xB7),\n            \"GE\" =\u003e bytecode.push(0xB8),\n            \"MIN\" =\u003e bytecode.push(0xB9),\n            \"MAX\" =\u003e bytecode.push(0xBA),\n            \"WITHIN\" =\u003e bytecode.push(0xBB),\n\n            // Compound types\n            \"PACK\" =\u003e bytecode.push(0xC0),\n            \"UNPACK\" =\u003e bytecode.push(0xC1),\n            \"NEWARRAY0\" =\u003e bytecode.push(0xC2),\n            \"NEWARRAY\" =\u003e bytecode.push(0xC3),\n            \"NEWSTRUCT0\" =\u003e bytecode.push(0xC5),\n            \"NEWSTRUCT\" =\u003e bytecode.push(0xC6),\n            \"NEWMAP\" =\u003e bytecode.push(0xC8),\n            \"SIZE\" =\u003e bytecode.push(0xCA),\n            \"HASKEY\" =\u003e bytecode.push(0xCB),\n            \"KEYS\" =\u003e bytecode.push(0xCC),\n            \"VALUES\" =\u003e bytecode.push(0xCD),\n            \"PICKITEM\" =\u003e bytecode.push(0xCE),\n            \"APPEND\" =\u003e bytecode.push(0xCF),\n            \"SETITEM\" =\u003e bytecode.push(0xD0),\n            \"REVERSEITEMS\" =\u003e bytecode.push(0xD1),\n            \"REMOVE\" =\u003e bytecode.push(0xD2),\n            \"CLEARITEMS\" =\u003e bytecode.push(0xD3),\n            \"POPITEM\" =\u003e bytecode.push(0xD4),\n\n            // Types\n            \"ISNULL\" =\u003e bytecode.push(0xD8),\n            \"ISTYPE\" =\u003e bytecode.push(0xD9),\n            \"CONVERT\" =\u003e bytecode.push(0xDB),\n\n            // Crypto\n            \"SHA256\" =\u003e bytecode.push(0xF0),\n            \"RIPEMD160\" =\u003e bytecode.push(0xF1),\n            \"HASH160\" =\u003e bytecode.push(0xF2),\n            \"CHECKSIG\" =\u003e bytecode.push(0xF3),\n\n            // Raw byte emission\n            \"DB\" | \".BYTE\" =\u003e {\n                for operand in operands {\n                    let byte = self.parse_byte(operand, line_num)?;\n                    bytecode.push(byte);\n                }\n            }\n\n            _ =\u003e {\n                return Err(AssemblerError::UnknownOpcode(op, line_num).to_string());\n            }\n        }\n\n        Ok(())\n    }\n\n    fn emit_jump_offset(\n        \u0026mut self,\n        bytecode: \u0026mut Vec\u003cu8\u003e,\n        operands: \u0026[\u0026str],\n        line_num: usize,\n    ) -\u003e Result\u003c(), String\u003e {\n        if operands.is_empty() {\n            return Err(AssemblerError::InvalidOperand(\n                \"Missing jump target\".to_string(),\n                line_num,\n            )\n            .to_string());\n        }\n\n        let target = operands[0];\n\n        // Check if it's a numeric offset\n        if let Ok(offset) = target.parse::\u003ci8\u003e() {\n            bytecode.push(offset as u8);\n        } else {\n            // It's a label - record for later resolution\n            self.pending_labels\n                .push((bytecode.len(), target.to_string(), line_num, false)); // false = short jump\n            bytecode.push(0); // Placeholder\n        }\n\n        Ok(())\n    }\n\n    fn emit_jump_offset_long(\n        \u0026mut self,\n        bytecode: \u0026mut Vec\u003cu8\u003e,\n        operands: \u0026[\u0026str],\n        line_num: usize,\n    ) -\u003e Result\u003c(), String\u003e {\n        if operands.is_empty() {\n            return Err(AssemblerError::InvalidOperand(\n                \"Missing jump target\".to_string(),\n                line_num,\n            )\n            .to_string());\n        }\n\n        let target = operands[0];\n\n        if let Ok(offset) = target.parse::\u003ci32\u003e() {\n            bytecode.extend_from_slice(\u0026offset.to_le_bytes());\n        } else {\n            self.pending_labels\n                .push((bytecode.len(), target.to_string(), line_num, true)); // true = long jump\n            bytecode.extend_from_slice(\u0026[0, 0, 0, 0]); // Placeholder\n        }\n\n        Ok(())\n    }\n\n    fn resolve_labels(\u0026self, bytecode: \u0026mut Vec\u003cu8\u003e) -\u003e Result\u003c(), String\u003e {\n        for (pos, label, line_num, is_long_jump) in \u0026self.pending_labels {\n            let target = self.labels.get(label).ok_or_else(|| {\n                AssemblerError::UndefinedLabel(label.clone(), *line_num).to_string()\n            })?;\n\n            let instr_start = pos - 1;\n            let offset = (*target as isize) - (instr_start as isize);\n\n            if *is_long_jump {\n                if i32::MIN as isize \u003c= offset \u0026\u0026 offset \u003c= i32::MAX as isize {\n                    let offset_bytes = (offset as i32).to_le_bytes();\n                    bytecode[*pos] = offset_bytes[0];\n                    bytecode[*pos + 1] = offset_bytes[1];\n                    bytecode[*pos + 2] = offset_bytes[2];\n                    bytecode[*pos + 3] = offset_bytes[3];\n                } else {\n                    return Err(format!(\n                        \"Jump offset {} too large for long jump at line {}\",\n                        offset, line_num\n                    ));\n                }\n            } else if (-128..=127).contains(\u0026offset) {\n                bytecode[*pos] = offset as i8 as u8;\n            } else {\n                return Err(format!(\n                    \"Jump offset {} too large for short jump at line {}\",\n                    offset, line_num\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    fn parse_int(\u0026self, operands: \u0026[\u0026str], line_num: usize) -\u003e Result\u003ci64, String\u003e {\n        if operands.is_empty() {\n            return Err(AssemblerError::InvalidOperand(\n                \"Missing integer value\".to_string(),\n                line_num,\n            )\n            .to_string());\n        }\n\n        let s = operands[0];\n        if s.starts_with(\"0x\") || s.starts_with(\"0X\") {\n            i64::from_str_radix(\u0026s[2..], 16)\n        } else {\n            s.parse()\n        }\n        .map_err(|_| {\n            AssemblerError::InvalidOperand(format!(\"Invalid integer: {}\", s), line_num).to_string()\n        })\n    }\n\n    fn parse_u8(\u0026self, operands: \u0026[\u0026str], line_num: usize) -\u003e Result\u003cu8, String\u003e {\n        let val = self.parse_int(operands, line_num)?;\n        if !(0..=255).contains(\u0026val) {\n            return Err(AssemblerError::InvalidOperand(\n                format!(\"Value {} out of u8 range\", val),\n                line_num,\n            )\n            .to_string());\n        }\n        Ok(val as u8)\n    }\n\n    fn parse_byte(\u0026self, s: \u0026str, line_num: usize) -\u003e Result\u003cu8, String\u003e {\n        let s = s.trim_start_matches(\"0x\").trim_start_matches(\"0X\");\n        u8::from_str_radix(s, 16)\n            .or_else(|_| s.parse())\n            .map_err(|_| {\n                AssemblerError::InvalidOperand(format!(\"Invalid byte: {}\", s), line_num).to_string()\n            })\n    }\n\n    fn parse_data(\u0026self, operands: \u0026[\u0026str], line_num: usize) -\u003e Result\u003cVec\u003cu8\u003e, String\u003e {\n        if operands.is_empty() {\n            return Err(\n                AssemblerError::InvalidOperand(\"Missing data\".to_string(), line_num).to_string(),\n            );\n        }\n\n        let s = operands.join(\" \");\n\n        // String literal\n        if s.starts_with('\"') \u0026\u0026 s.ends_with('\"') {\n            return Ok(s.as_bytes()[1..s.len() - 1].to_vec());\n        }\n\n        // Hex data\n        let hex_str = s.trim_start_matches(\"0x\").replace(\" \", \"\");\n        hex::decode(\u0026hex_str).map_err(|_| {\n            AssemblerError::InvalidOperand(format!(\"Invalid hex data: {}\", s), line_num).to_string()\n        })\n    }\n\n    fn parse_slot_args(\u0026self, operands: \u0026[\u0026str], line_num: usize) -\u003e Result\u003c(u8, u8), String\u003e {\n        if operands.len() \u003c 2 {\n            return Err(AssemblerError::InvalidOperand(\n                \"INITSLOT requires two arguments: \u003clocals\u003e \u003cargs\u003e\".to_string(),\n                line_num,\n            )\n            .to_string());\n        }\n\n        let locals = operands[0].parse().map_err(|_| {\n            AssemblerError::InvalidOperand(\"Invalid locals count\".to_string(), line_num).to_string()\n        })?;\n        let args = operands[1].parse().map_err(|_| {\n            AssemblerError::InvalidOperand(\"Invalid args count\".to_string(), line_num).to_string()\n        })?;\n\n        Ok((locals, args))\n    }\n\n    fn parse_syscall_id(\u0026self, operands: \u0026[\u0026str], line_num: usize) -\u003e Result\u003cu32, String\u003e {\n        if operands.is_empty() {\n            return Err(\n                AssemblerError::InvalidOperand(\"Missing syscall ID\".to_string(), line_num)\n                    .to_string(),\n            );\n        }\n\n        let s = operands[0];\n\n        // Named syscalls\n        match s.to_uppercase().as_str() {\n            \"LOG\" | \"SYSTEM.RUNTIME.LOG\" =\u003e return Ok(0x01),\n            \"NOTIFY\" | \"SYSTEM.RUNTIME.NOTIFY\" =\u003e return Ok(0x02),\n            \"GETTIME\" | \"SYSTEM.RUNTIME.GETTIME\" =\u003e return Ok(0x03),\n            \"STORAGE.GET\" | \"SYSTEM.STORAGE.GET\" =\u003e return Ok(0x10),\n            \"STORAGE.PUT\" | \"SYSTEM.STORAGE.PUT\" =\u003e return Ok(0x11),\n            \"STORAGE.DELETE\" | \"SYSTEM.STORAGE.DELETE\" =\u003e return Ok(0x12),\n            _ =\u003e {}\n        }\n\n        // Numeric ID\n        if s.starts_with(\"0x\") || s.starts_with(\"0X\") {\n            u32::from_str_radix(\u0026s[2..], 16)\n        } else {\n            s.parse()\n        }\n        .map_err(|_| {\n            AssemblerError::InvalidOperand(format!(\"Invalid syscall ID: {}\", s), line_num)\n                .to_string()\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-cli","src","disassembler.rs"],"content":"//! Neo zkVM Disassembler with enhanced formatting\n//!\n//! Features:\n//! - Full Neo N3 opcode support\n//! - Colored output (when terminal supports it)\n//! - Jump target annotations\n//! - Operand decoding\n\npub struct Disassembler\u003c'a\u003e {\n    script: \u0026'a [u8],\n}\n\nimpl\u003c'a\u003e Disassembler\u003c'a\u003e {\n    pub fn new(script: \u0026'a [u8]) -\u003e Self {\n        Self { script }\n    }\n\n    pub fn disassemble(\u0026self) -\u003e String {\n        let mut output = String::new();\n        let mut ip = 0;\n\n        while ip \u003c self.script.len() {\n            let (name, size) = self.decode_instruction(ip);\n            let bytes = \u0026self.script[ip..ip + size.min(self.script.len() - ip)];\n            let hex_bytes = bytes\n                .iter()\n                .map(|b| format!(\"{:02X}\", b))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\" \");\n\n            output.push_str(\u0026format!(\"{:04X}:  {:16}  {}\\n\", ip, hex_bytes, name));\n\n            ip += size;\n        }\n\n        output\n    }\n\n    pub fn decode_instruction(\u0026self, ip: usize) -\u003e (String, usize) {\n        if ip \u003e= self.script.len() {\n            return (\"???\".to_string(), 1);\n        }\n\n        let op = self.script[ip];\n\n        match op {\n            // Constants with operands\n            0x00 =\u003e {\n                let val = self.read_i8(ip + 1);\n                (format!(\"PUSHINT8 {}\", val), 2)\n            }\n            0x01 =\u003e {\n                let val = self.read_i16(ip + 1);\n                (format!(\"PUSHINT16 {}\", val), 3)\n            }\n            0x02 =\u003e {\n                let val = self.read_i32(ip + 1);\n                (format!(\"PUSHINT32 {}\", val), 5)\n            }\n            0x03 =\u003e {\n                let val = self.read_i64(ip + 1);\n                (format!(\"PUSHINT64 {}\", val), 9)\n            }\n            0x04 =\u003e (\"PUSHINT128\".to_string(), 17),\n            0x05 =\u003e (\"PUSHINT256\".to_string(), 33),\n            0x0A =\u003e {\n                let offset = self.read_i32(ip + 1);\n                (format!(\"PUSHA {:+}\", offset), 5)\n            }\n            0x0B =\u003e (\"PUSHNULL\".to_string(), 1),\n            0x0C =\u003e {\n                let len = self.read_u8(ip + 1) as usize;\n                let data = self.read_bytes(ip + 2, len);\n                (format!(\"PUSHDATA1 0x{}\", hex::encode(\u0026data)), 2 + len)\n            }\n            0x0D =\u003e {\n                let len = self.read_u16(ip + 1) as usize;\n                let data = self.read_bytes(ip + 3, len.min(32));\n                let suffix = if len \u003e 32 { \"...\" } else { \"\" };\n                (\n                    format!(\"PUSHDATA2 0x{}{}\", hex::encode(\u0026data), suffix),\n                    3 + len,\n                )\n            }\n            0x0E =\u003e {\n                let len = self.read_u32(ip + 1) as usize;\n                (format!(\"PUSHDATA4 [{}B]\", len), 5 + len)\n            }\n            0x0F =\u003e (\"PUSHM1\".to_string(), 1),\n            0x10 =\u003e (\"PUSH0\".to_string(), 1),\n            0x11 =\u003e (\"PUSH1\".to_string(), 1),\n            0x12 =\u003e (\"PUSH2\".to_string(), 1),\n            0x13 =\u003e (\"PUSH3\".to_string(), 1),\n            0x14 =\u003e (\"PUSH4\".to_string(), 1),\n            0x15 =\u003e (\"PUSH5\".to_string(), 1),\n            0x16 =\u003e (\"PUSH6\".to_string(), 1),\n            0x17 =\u003e (\"PUSH7\".to_string(), 1),\n            0x18 =\u003e (\"PUSH8\".to_string(), 1),\n            0x19 =\u003e (\"PUSH9\".to_string(), 1),\n            0x1A =\u003e (\"PUSH10\".to_string(), 1),\n            0x1B =\u003e (\"PUSH11\".to_string(), 1),\n            0x1C =\u003e (\"PUSH12\".to_string(), 1),\n            0x1D =\u003e (\"PUSH13\".to_string(), 1),\n            0x1E =\u003e (\"PUSH14\".to_string(), 1),\n            0x1F =\u003e (\"PUSH15\".to_string(), 1),\n            0x20 =\u003e (\"PUSH16\".to_string(), 1),\n\n            // Flow control\n            0x21 =\u003e (\"NOP\".to_string(), 1),\n            0x22 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMP {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x23 =\u003e {\n                let offset = self.read_i32(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMP_L {:+} -\u003e 0x{:04X}\", offset, target), 5)\n            }\n            0x24 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPIF {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x25 =\u003e {\n                let offset = self.read_i32(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPIF_L {:+} -\u003e 0x{:04X}\", offset, target), 5)\n            }\n            0x26 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPIFNOT {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x27 =\u003e {\n                let offset = self.read_i32(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPIFNOT_L {:+} -\u003e 0x{:04X}\", offset, target), 5)\n            }\n            0x28 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPEQ {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x2A =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPNE {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x2C =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPGT {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x2E =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPGE {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x30 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPLT {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x32 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"JMPLE {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x34 =\u003e {\n                let offset = self.read_i8(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"CALL {:+} -\u003e 0x{:04X}\", offset, target), 2)\n            }\n            0x35 =\u003e {\n                let offset = self.read_i32(ip + 1);\n                let target = (ip as isize + offset as isize) as usize;\n                (format!(\"CALL_L {:+} -\u003e 0x{:04X}\", offset, target), 5)\n            }\n            0x36 =\u003e (\"CALLA\".to_string(), 1),\n            0x37 =\u003e {\n                let token = self.read_u16(ip + 1);\n                (format!(\"CALLT {}\", token), 3)\n            }\n            0x38 =\u003e (\"ABORT\".to_string(), 1),\n            0x39 =\u003e (\"ASSERT\".to_string(), 1),\n            0x3A =\u003e (\"THROW\".to_string(), 1),\n            0x3B =\u003e {\n                let catch = self.read_i8(ip + 1);\n                let finally = self.read_i8(ip + 2);\n                (format!(\"TRY catch:{:+} finally:{:+}\", catch, finally), 3)\n            }\n            0x3D =\u003e {\n                let offset = self.read_i8(ip + 1);\n                (format!(\"ENDTRY {:+}\", offset), 2)\n            }\n            0x3F =\u003e (\"ENDFINALLY\".to_string(), 1),\n            0x40 =\u003e (\"RET\".to_string(), 1),\n            0x41 =\u003e {\n                let id = self.read_u32(ip + 1);\n                let name = self.syscall_name(id);\n                (format!(\"SYSCALL {} (0x{:08X})\", name, id), 5)\n            }\n\n            // Stack operations\n            0x43 =\u003e (\"DEPTH\".to_string(), 1),\n            0x45 =\u003e (\"DROP\".to_string(), 1),\n            0x46 =\u003e (\"NIP\".to_string(), 1),\n            0x48 =\u003e (\"XDROP\".to_string(), 1),\n            0x49 =\u003e (\"CLEAR\".to_string(), 1),\n            0x4A =\u003e (\"DUP\".to_string(), 1),\n            0x4B =\u003e (\"OVER\".to_string(), 1),\n            0x4D =\u003e (\"PICK\".to_string(), 1),\n            0x4E =\u003e (\"TUCK\".to_string(), 1),\n            0x50 =\u003e (\"SWAP\".to_string(), 1),\n            0x51 =\u003e (\"ROT\".to_string(), 1),\n            0x52 =\u003e (\"ROLL\".to_string(), 1),\n            0x53 =\u003e (\"REVERSE3\".to_string(), 1),\n            0x54 =\u003e (\"REVERSE4\".to_string(), 1),\n            0x55 =\u003e (\"REVERSEN\".to_string(), 1),\n\n            // Slot operations\n            0x56 =\u003e {\n                let count = self.read_u8(ip + 1);\n                (format!(\"INITSSLOT {}\", count), 2)\n            }\n            0x57 =\u003e {\n                let locals = self.read_u8(ip + 1);\n                let args = self.read_u8(ip + 2);\n                (format!(\"INITSLOT locals:{} args:{}\", locals, args), 3)\n            }\n            0x58 =\u003e (\"LDSFLD0\".to_string(), 1),\n            0x59 =\u003e (\"LDSFLD1\".to_string(), 1),\n            0x5A =\u003e (\"LDSFLD2\".to_string(), 1),\n            0x5B =\u003e (\"LDSFLD3\".to_string(), 1),\n            0x5C =\u003e (\"LDSFLD4\".to_string(), 1),\n            0x5D =\u003e (\"LDSFLD5\".to_string(), 1),\n            0x5E =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"LDSFLD {}\", idx), 2)\n            }\n            0x5F =\u003e (\"STSFLD0\".to_string(), 1),\n            0x60 =\u003e (\"STSFLD1\".to_string(), 1),\n            0x61 =\u003e (\"STSFLD2\".to_string(), 1),\n            0x62 =\u003e (\"STSFLD3\".to_string(), 1),\n            0x63 =\u003e (\"STSFLD4\".to_string(), 1),\n            0x64 =\u003e (\"STSFLD5\".to_string(), 1),\n            0x65 =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"STSFLD {}\", idx), 2)\n            }\n            0x66 =\u003e (\"LDLOC0\".to_string(), 1),\n            0x67 =\u003e (\"LDLOC1\".to_string(), 1),\n            0x68 =\u003e (\"LDLOC2\".to_string(), 1),\n            0x69 =\u003e (\"LDLOC3\".to_string(), 1),\n            0x6A =\u003e (\"LDLOC4\".to_string(), 1),\n            0x6B =\u003e (\"LDLOC5\".to_string(), 1),\n            0x6C =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"LDLOC {}\", idx), 2)\n            }\n            0x6D =\u003e (\"STLOC0\".to_string(), 1),\n            0x6E =\u003e (\"STLOC1\".to_string(), 1),\n            0x6F =\u003e (\"STLOC2\".to_string(), 1),\n            0x70 =\u003e (\"STLOC3\".to_string(), 1),\n            0x71 =\u003e (\"STLOC4\".to_string(), 1),\n            0x72 =\u003e (\"STLOC5\".to_string(), 1),\n            0x73 =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"STLOC {}\", idx), 2)\n            }\n            0x74 =\u003e (\"LDARG0\".to_string(), 1),\n            0x75 =\u003e (\"LDARG1\".to_string(), 1),\n            0x76 =\u003e (\"LDARG2\".to_string(), 1),\n            0x77 =\u003e (\"LDARG3\".to_string(), 1),\n            0x78 =\u003e (\"LDARG4\".to_string(), 1),\n            0x79 =\u003e (\"LDARG5\".to_string(), 1),\n            0x7A =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"LDARG {}\", idx), 2)\n            }\n            0x7B =\u003e (\"STARG0\".to_string(), 1),\n            0x7C =\u003e (\"STARG1\".to_string(), 1),\n            0x7D =\u003e (\"STARG2\".to_string(), 1),\n            0x7E =\u003e (\"STARG3\".to_string(), 1),\n            0x7F =\u003e (\"STARG4\".to_string(), 1),\n            0x80 =\u003e (\"STARG5\".to_string(), 1),\n            0x81 =\u003e {\n                let idx = self.read_u8(ip + 1);\n                (format!(\"STARG {}\", idx), 2)\n            }\n\n            // Splice\n            0x88 =\u003e (\"NEWBUFFER\".to_string(), 1),\n            0x89 =\u003e (\"MEMCPY\".to_string(), 1),\n            0x8B =\u003e (\"CAT\".to_string(), 1),\n            0x8C =\u003e (\"SUBSTR\".to_string(), 1),\n            0x8D =\u003e (\"LEFT\".to_string(), 1),\n            0x8E =\u003e (\"RIGHT\".to_string(), 1),\n\n            // Bitwise\n            0x90 =\u003e (\"INVERT\".to_string(), 1),\n            0x91 =\u003e (\"AND\".to_string(), 1),\n            0x92 =\u003e (\"OR\".to_string(), 1),\n            0x93 =\u003e (\"XOR\".to_string(), 1),\n            0x97 =\u003e (\"EQUAL\".to_string(), 1),\n            0x98 =\u003e (\"NOTEQUAL\".to_string(), 1),\n\n            // Arithmetic\n            0x99 =\u003e (\"SIGN\".to_string(), 1),\n            0x9A =\u003e (\"ABS\".to_string(), 1),\n            0x9B =\u003e (\"NEGATE\".to_string(), 1),\n            0x9C =\u003e (\"INC\".to_string(), 1),\n            0x9D =\u003e (\"DEC\".to_string(), 1),\n            0x9E =\u003e (\"ADD\".to_string(), 1),\n            0x9F =\u003e (\"SUB\".to_string(), 1),\n            0xA0 =\u003e (\"MUL\".to_string(), 1),\n            0xA1 =\u003e (\"DIV\".to_string(), 1),\n            0xA2 =\u003e (\"MOD\".to_string(), 1),\n            0xA3 =\u003e (\"POW\".to_string(), 1),\n            0xA4 =\u003e (\"SQRT\".to_string(), 1),\n            0xA5 =\u003e (\"MODMUL\".to_string(), 1),\n            0xA6 =\u003e (\"MODPOW\".to_string(), 1),\n            0xA8 =\u003e (\"SHL\".to_string(), 1),\n            0xA9 =\u003e (\"SHR\".to_string(), 1),\n            0xAA =\u003e (\"NOT\".to_string(), 1),\n            0xAB =\u003e (\"BOOLAND\".to_string(), 1),\n            0xAC =\u003e (\"BOOLOR\".to_string(), 1),\n            0xB1 =\u003e (\"NZ\".to_string(), 1),\n            0xB3 =\u003e (\"NUMEQUAL\".to_string(), 1),\n            0xB4 =\u003e (\"NUMNOTEQUAL\".to_string(), 1),\n            0xB5 =\u003e (\"LT\".to_string(), 1),\n            0xB6 =\u003e (\"LE\".to_string(), 1),\n            0xB7 =\u003e (\"GT\".to_string(), 1),\n            0xB8 =\u003e (\"GE\".to_string(), 1),\n            0xB9 =\u003e (\"MIN\".to_string(), 1),\n            0xBA =\u003e (\"MAX\".to_string(), 1),\n            0xBB =\u003e (\"WITHIN\".to_string(), 1),\n\n            // Compound types\n            0xBE =\u003e (\"PACKMAP\".to_string(), 1),\n            0xBF =\u003e (\"PACKSTRUCT\".to_string(), 1),\n            0xC0 =\u003e (\"PACK\".to_string(), 1),\n            0xC1 =\u003e (\"UNPACK\".to_string(), 1),\n            0xC2 =\u003e (\"NEWARRAY0\".to_string(), 1),\n            0xC3 =\u003e (\"NEWARRAY\".to_string(), 1),\n            0xC4 =\u003e {\n                let t = self.read_u8(ip + 1);\n                (format!(\"NEWARRAY_T {}\", self.type_name(t)), 2)\n            }\n            0xC5 =\u003e (\"NEWSTRUCT0\".to_string(), 1),\n            0xC6 =\u003e (\"NEWSTRUCT\".to_string(), 1),\n            0xC8 =\u003e (\"NEWMAP\".to_string(), 1),\n            0xCA =\u003e (\"SIZE\".to_string(), 1),\n            0xCB =\u003e (\"HASKEY\".to_string(), 1),\n            0xCC =\u003e (\"KEYS\".to_string(), 1),\n            0xCD =\u003e (\"VALUES\".to_string(), 1),\n            0xCE =\u003e (\"PICKITEM\".to_string(), 1),\n            0xCF =\u003e (\"APPEND\".to_string(), 1),\n            0xD0 =\u003e (\"SETITEM\".to_string(), 1),\n            0xD1 =\u003e (\"REVERSEITEMS\".to_string(), 1),\n            0xD2 =\u003e (\"REMOVE\".to_string(), 1),\n            0xD3 =\u003e (\"CLEARITEMS\".to_string(), 1),\n            0xD4 =\u003e (\"POPITEM\".to_string(), 1),\n\n            // Types\n            0xD8 =\u003e (\"ISNULL\".to_string(), 1),\n            0xD9 =\u003e {\n                let t = self.read_u8(ip + 1);\n                (format!(\"ISTYPE {}\", self.type_name(t)), 2)\n            }\n            0xDB =\u003e {\n                let t = self.read_u8(ip + 1);\n                (format!(\"CONVERT {}\", self.type_name(t)), 2)\n            }\n            0xE0 =\u003e (\"ABORTMSG\".to_string(), 1),\n            0xE1 =\u003e (\"ASSERTMSG\".to_string(), 1),\n\n            // Crypto\n            0xF0 =\u003e (\"SHA256\".to_string(), 1),\n            0xF1 =\u003e (\"RIPEMD160\".to_string(), 1),\n            0xF2 =\u003e (\"HASH160\".to_string(), 1),\n            0xF3 =\u003e (\"CHECKSIG\".to_string(), 1),\n\n            _ =\u003e (format!(\"??? (0x{:02X})\", op), 1),\n        }\n    }\n\n    fn read_u8(\u0026self, pos: usize) -\u003e u8 {\n        self.script.get(pos).copied().unwrap_or(0)\n    }\n\n    fn read_i8(\u0026self, pos: usize) -\u003e i8 {\n        self.read_u8(pos) as i8\n    }\n\n    fn read_u16(\u0026self, pos: usize) -\u003e u16 {\n        let b0 = self.read_u8(pos) as u16;\n        let b1 = self.read_u8(pos + 1) as u16;\n        b0 | (b1 \u003c\u003c 8)\n    }\n\n    fn read_i16(\u0026self, pos: usize) -\u003e i16 {\n        self.read_u16(pos) as i16\n    }\n\n    fn read_u32(\u0026self, pos: usize) -\u003e u32 {\n        let b0 = self.read_u8(pos) as u32;\n        let b1 = self.read_u8(pos + 1) as u32;\n        let b2 = self.read_u8(pos + 2) as u32;\n        let b3 = self.read_u8(pos + 3) as u32;\n        b0 | (b1 \u003c\u003c 8) | (b2 \u003c\u003c 16) | (b3 \u003c\u003c 24)\n    }\n\n    fn read_i32(\u0026self, pos: usize) -\u003e i32 {\n        self.read_u32(pos) as i32\n    }\n\n    fn read_i64(\u0026self, pos: usize) -\u003e i64 {\n        let lo = self.read_u32(pos) as u64;\n        let hi = self.read_u32(pos + 4) as u64;\n        (lo | (hi \u003c\u003c 32)) as i64\n    }\n\n    fn read_bytes(\u0026self, pos: usize, len: usize) -\u003e Vec\u003cu8\u003e {\n        let end = (pos + len).min(self.script.len());\n        self.script.get(pos..end).unwrap_or(\u0026[]).to_vec()\n    }\n\n    fn syscall_name(\u0026self, id: u32) -\u003e \u0026'static str {\n        match id {\n            0x01 =\u003e \"System.Runtime.Log\",\n            0x02 =\u003e \"System.Runtime.Notify\",\n            0x03 =\u003e \"System.Runtime.GetTime\",\n            0x10 =\u003e \"System.Storage.Get\",\n            0x11 =\u003e \"System.Storage.Put\",\n            0x12 =\u003e \"System.Storage.Delete\",\n            _ =\u003e \"Unknown\",\n        }\n    }\n\n    fn type_name(\u0026self, t: u8) -\u003e \u0026'static str {\n        match t {\n            0x00 =\u003e \"Any\",\n            0x10 =\u003e \"Pointer\",\n            0x20 =\u003e \"Boolean\",\n            0x21 =\u003e \"Integer\",\n            0x28 =\u003e \"ByteString\",\n            0x30 =\u003e \"Buffer\",\n            0x40 =\u003e \"Array\",\n            0x41 =\u003e \"Struct\",\n            0x48 =\u003e \"Map\",\n            0x60 =\u003e \"InteropInterface\",\n            _ =\u003e \"Unknown\",\n        }\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":344},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-cli","src","main.rs"],"content":"#![allow(clippy::ptr_arg)]\n\n//! Neo zkVM CLI - Complete development toolkit\n//!\n//! A comprehensive command-line interface for Neo zkVM development,\n//! including execution, debugging, assembly, and proof generation.\n\nuse neo_vm_core::{NeoVM, VMState};\nuse neo_vm_guest::ProofInput;\nuse neo_zkvm_prover::{NeoProver, ProverConfig};\nuse neo_zkvm_verifier::verify;\nuse std::collections::HashMap;\nuse std::env;\nuse std::fs;\nuse std::io::{self, BufRead, Write};\n\nmod assembler;\nmod disassembler;\n\nuse assembler::Assembler;\nuse disassembler::Disassembler;\n\nconst VERSION: \u0026str = \"0.2.0\";\n\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() \u003c 2 {\n        print_help();\n        std::process::exit(1);\n    }\n\n    let result = match args[1].as_str() {\n        \"run\" =\u003e cmd_run(\u0026args[2..]),\n        \"prove\" =\u003e cmd_prove(\u0026args[2..]),\n        \"asm\" =\u003e cmd_assemble(\u0026args[2..]),\n        \"disasm\" =\u003e cmd_disassemble(\u0026args[2..]),\n        \"debug\" =\u003e cmd_debug(\u0026args[2..]),\n        \"inspect\" =\u003e cmd_inspect(\u0026args[2..]),\n        \"version\" | \"-v\" | \"--version\" =\u003e {\n            println!(\"neo-zkvm v{}\", VERSION);\n            Ok(())\n        }\n        \"help\" | \"-h\" | \"--help\" =\u003e {\n            print_help();\n            Ok(())\n        }\n        cmd =\u003e {\n            eprintln!(\"Error: Unknown command '{}'\\n\", cmd);\n            eprintln!(\"Run 'neo-zkvm help' for usage information.\");\n            std::process::exit(1);\n        }\n    };\n\n    if let Err(e) = result {\n        eprintln!(\"Error: {}\", e);\n        std::process::exit(1);\n    }\n}\n\nfn print_help() {\n    println!(\n        r#\"Neo zkVM CLI v{}\n\nA comprehensive toolkit for Neo zkVM development.\n\nUSAGE:\n    neo-zkvm \u003cCOMMAND\u003e [OPTIONS] [ARGS]\n\nCOMMANDS:\n    run \u003cscript\u003e        Execute a script and show results\n    prove \u003cscript\u003e      Generate ZK proof for script execution\n    asm \u003csource\u003e        Assemble source code to bytecode\n    disasm \u003chex\u003e        Disassemble bytecode to readable format\n    debug \u003cscript\u003e      Interactive step-by-step debugger\n    inspect \u003cscript\u003e    Analyze and display script information\n    version             Show version information\n    help                Show this help message\n\nSCRIPT INPUT FORMATS:\n    - Hex string:       12139E40 or 0x12139E40\n    - Binary file:      script.bin or script.nef\n    - Assembly file:    script.neoasm (for asm command)\n\nEXAMPLES:\n    # Execute a simple addition (PUSH2 PUSH3 ADD RET)\n    neo-zkvm run 12139E40\n\n    # Assemble source code\n    neo-zkvm asm \"PUSH2 PUSH3 ADD RET\"\n    neo-zkvm asm program.neoasm\n\n    # Disassemble bytecode\n    neo-zkvm disasm 12139E40\n\n    # Debug interactively\n    neo-zkvm debug 12139E40\n\n    # Inspect script structure\n    neo-zkvm inspect 12139E40\n\n    # Generate ZK proof\n    neo-zkvm prove 12139E40\n\nFor more information, visit: https://github.com/neonlabsorg/neo-zkvm\"#,\n        VERSION\n    );\n}\n\nfn cmd_run(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing script argument.\\n\\nUsage: neo-zkvm run \u003cscript\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm run 12139E40\\n  neo-zkvm run script.bin\"\n                .to_string(),\n        );\n    }\n\n    let script = parse_script(\u0026args[0])?;\n    let gas_limit = parse_gas_limit(args)?;\n\n    let mut vm = NeoVM::new(gas_limit);\n    let _ = vm.load_script(script);\n\n    println!(\"Executing script...\\n\");\n\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if let Err(e) = vm.execute_next() {\n            return Err(format!(\"Execution failed: {}\", e));\n        }\n    }\n\n    println!(\"\");\n    println!(\"  EXECUTION RESULT\");\n    println!(\"\");\n    println!(\"  State:        {:?}\", vm.state);\n    println!(\"  Gas consumed: {}\", vm.gas_consumed);\n    println!(\"  Stack depth:  {}\", vm.eval_stack.len());\n    println!(\"\");\n\n    if !vm.eval_stack.is_empty() {\n        println!(\"  Stack (top  bottom):\");\n        for (i, item) in vm.eval_stack.iter().rev().enumerate() {\n            println!(\"    [{}] {:?}\", i, item);\n        }\n    } else {\n        println!(\"  Stack: (empty)\");\n    }\n\n    if !vm.logs.is_empty() {\n        println!(\"\");\n        println!(\"  Logs:\");\n        for log in \u0026vm.logs {\n            println!(\"    {}\", log);\n        }\n    }\n\n    println!(\"\");\n\n    Ok(())\n}\n\nfn cmd_prove(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing script argument.\\n\\nUsage: neo-zkvm prove \u003cscript\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm prove 12139E40\\n  neo-zkvm prove script.bin\"\n                .to_string(),\n        );\n    }\n\n    let script = parse_script(\u0026args[0])?;\n    let gas_limit = parse_gas_limit(args)?;\n\n    println!(\"Generating ZK proof...\\n\");\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    println!(\"\");\n    println!(\"  PROOF GENERATION RESULT\");\n    println!(\"\");\n    println!(\"  Result:   {:?}\", proof.output.result);\n    println!(\"  Verified: {}\", verify(\u0026proof));\n    println!(\"\");\n\n    Ok(())\n}\n\nfn cmd_assemble(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing source argument.\\n\\nUsage: neo-zkvm asm \u003csource\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm asm \\\"PUSH2 PUSH3 ADD RET\\\"\\n  neo-zkvm asm program.neoasm\"\n                .to_string(),\n        );\n    }\n\n    let source = if args[0].ends_with(\".neoasm\") {\n        fs::read_to_string(\u0026args[0]).map_err(|e| format!(\"Failed to read file: {}\", e))?\n    } else {\n        args[0].clone()\n    };\n\n    let mut assembler = Assembler::new();\n    let bytecode = assembler.assemble(\u0026source)?;\n\n    println!(\"{}\", hex::encode(\u0026bytecode));\n\n    // Show warnings if any\n    for warning in assembler.warnings() {\n        eprintln!(\"Warning: {}\", warning);\n    }\n\n    Ok(())\n}\n\nfn cmd_disassemble(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing bytecode argument.\\n\\nUsage: neo-zkvm disasm \u003chex\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm disasm 12139E40\\n  neo-zkvm disasm script.bin\"\n                .to_string(),\n        );\n    }\n\n    let script = parse_script(\u0026args[0])?;\n    let disasm = Disassembler::new(\u0026script);\n\n    println!(\"{}\", disasm.disassemble());\n\n    Ok(())\n}\n\nfn cmd_debug(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing script argument.\\n\\nUsage: neo-zkvm debug \u003cscript\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm debug 12139E40\\n  neo-zkvm debug script.bin\"\n                .to_string(),\n        );\n    }\n\n    let script = parse_script(\u0026args[0])?;\n    let gas_limit = parse_gas_limit(args)?;\n\n    let mut debugger = Debugger::new(script, gas_limit);\n    debugger.run()?;\n\n    Ok(())\n}\n\nfn cmd_inspect(args: \u0026[String]) -\u003e Result\u003c(), String\u003e {\n    if args.is_empty() {\n        return Err(\n            \"Missing script argument.\\n\\nUsage: neo-zkvm inspect \u003cscript\u003e\\n\\nExamples:\\n  \\\n             neo-zkvm inspect 12139E40\\n  neo-zkvm inspect script.bin\"\n                .to_string(),\n        );\n    }\n\n    let script = parse_script(\u0026args[0])?;\n    let inspector = Inspector::new(\u0026script);\n\n    println!(\"{}\", inspector.analyze());\n\n    Ok(())\n}\n\nconst MAX_SCRIPT_SIZE: usize = 1024 * 1024; // 1MB\n\nfn parse_script(input: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e, String\u003e {\n    if input.ends_with(\".nef\") || input.ends_with(\".bin\") {\n        let metadata =\n            fs::metadata(input).map_err(|e| format!(\"Failed to read file '{}': {}\", input, e))?;\n        if metadata.len() \u003e MAX_SCRIPT_SIZE as u64 {\n            return Err(format!(\n                \"Script file exceeds maximum size of {} bytes\",\n                MAX_SCRIPT_SIZE\n            ));\n        }\n        let content =\n            fs::read(input).map_err(|e| format!(\"Failed to read file '{}': {}\", input, e))?;\n        if content.len() \u003e MAX_SCRIPT_SIZE {\n            return Err(format!(\n                \"Script content exceeds maximum size of {} bytes\",\n                MAX_SCRIPT_SIZE\n            ));\n        }\n        Ok(content)\n    } else {\n        let hex_str = input.trim_start_matches(\"0x\");\n        let decoded = hex::decode(hex_str).map_err(|e| format!(\"Invalid hex string: {}\", e))?;\n        if decoded.len() \u003e MAX_SCRIPT_SIZE {\n            return Err(format!(\n                \"Script exceeds maximum size of {} bytes\",\n                MAX_SCRIPT_SIZE\n            ));\n        }\n        Ok(decoded)\n    }\n}\n\nfn parse_gas_limit(args: \u0026[String]) -\u003e Result\u003cu64, String\u003e {\n    for (i, arg) in args.iter().enumerate() {\n        if (arg == \"--gas\" || arg == \"-g\") \u0026\u0026 i + 1 \u003c args.len() {\n            return args[i + 1]\n                .parse()\n                .map_err(|_| \"Invalid gas limit value\".to_string());\n        }\n    }\n    Ok(1_000_000) // Default gas limit\n}\n\n// ============================================================================\n// Debugger\n// ============================================================================\n\nstruct Debugger {\n    vm: NeoVM,\n    script: Vec\u003cu8\u003e,\n    breakpoints: Vec\u003cusize\u003e,\n    history: Vec\u003cString\u003e,\n}\n\nimpl Debugger {\n    fn new(script: Vec\u003cu8\u003e, gas_limit: u64) -\u003e Self {\n        let mut vm = NeoVM::new(gas_limit);\n        let _ = vm.load_script(script.clone());\n        Self {\n            vm,\n            script,\n            breakpoints: Vec::new(),\n            history: Vec::new(),\n        }\n    }\n\n    fn run(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        println!(\"Neo zkVM Debugger v{}\", VERSION);\n        println!(\"Type 'help' for available commands.\\n\");\n\n        self.print_current_state();\n\n        let stdin = io::stdin();\n        let mut stdout = io::stdout();\n\n        loop {\n            print!(\"(neodbg) \");\n            stdout.flush().unwrap();\n\n            let mut line = String::new();\n            if stdin.lock().read_line(\u0026mut line).is_err() {\n                break;\n            }\n\n            let line = line.trim();\n            if line.is_empty() {\n                // Repeat last command\n                if let Some(last) = self.history.last().cloned() {\n                    self.execute_command(\u0026last)?;\n                }\n                continue;\n            }\n\n            self.history.push(line.to_string());\n\n            if self.execute_command(line)? {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute_command(\u0026mut self, cmd: \u0026str) -\u003e Result\u003cbool, String\u003e {\n        let parts: Vec\u003c\u0026str\u003e = cmd.split_whitespace().collect();\n        if parts.is_empty() {\n            return Ok(false);\n        }\n\n        match parts[0] {\n            \"help\" | \"h\" =\u003e self.cmd_help(),\n            \"step\" | \"s\" | \"n\" =\u003e self.cmd_step(),\n            \"continue\" | \"c\" =\u003e self.cmd_continue(),\n            \"run\" | \"r\" =\u003e self.cmd_run_to_end(),\n            \"break\" | \"b\" =\u003e self.cmd_breakpoint(\u0026parts[1..]),\n            \"delete\" | \"d\" =\u003e self.cmd_delete_breakpoint(\u0026parts[1..]),\n            \"info\" | \"i\" =\u003e self.cmd_info(\u0026parts[1..]),\n            \"print\" | \"p\" =\u003e self.cmd_print(\u0026parts[1..]),\n            \"stack\" =\u003e self.cmd_stack(),\n            \"disasm\" =\u003e self.cmd_disasm(),\n            \"reset\" =\u003e self.cmd_reset(),\n            \"quit\" | \"q\" | \"exit\" =\u003e return Ok(true),\n            _ =\u003e {\n                println!(\n                    \"Unknown command: '{}'. Type 'help' for available commands.\",\n                    parts[0]\n                );\n            }\n        }\n\n        Ok(false)\n    }\n\n    fn cmd_help(\u0026self) {\n        println!(\n            r#\"\nAvailable commands:\n  step, s, n          Execute next instruction\n  continue, c         Continue until breakpoint or halt\n  run, r              Run to completion\n  break \u003caddr\u003e, b     Set breakpoint at address (hex)\n  delete \u003caddr\u003e, d    Delete breakpoint\n  info breakpoints    List all breakpoints\n  info registers      Show VM state\n  print \u003cn\u003e, p        Print stack item at index n\n  stack               Show full stack\n  disasm              Disassemble current script\n  reset               Reset VM to initial state\n  quit, q, exit       Exit debugger\n\"#\n        );\n    }\n\n    fn cmd_step(\u0026mut self) {\n        if matches!(self.vm.state, VMState::Halt | VMState::Fault) {\n            println!(\"Program has terminated. Use 'reset' to restart.\");\n            return;\n        }\n\n        if let Err(e) = self.vm.execute_next() {\n            println!(\"Error: {}\", e);\n        }\n\n        self.print_current_state();\n    }\n\n    fn cmd_continue(\u0026mut self) {\n        while !matches!(self.vm.state, VMState::Halt | VMState::Fault) {\n            let ip = self.get_current_ip();\n            if self.breakpoints.contains(\u0026ip)\n                \u0026\u0026 !self\n                    .history\n                    .last()\n                    .map(|s| s.starts_with(\"continue\"))\n                    .unwrap_or(false)\n            {\n                println!(\"Breakpoint hit at 0x{:04X}\", ip);\n                break;\n            }\n\n            if let Err(e) = self.vm.execute_next() {\n                println!(\"Error: {}\", e);\n                break;\n            }\n\n            // Check breakpoint after execution\n            let new_ip = self.get_current_ip();\n            if self.breakpoints.contains(\u0026new_ip) {\n                println!(\"Breakpoint hit at 0x{:04X}\", new_ip);\n                self.print_current_state();\n                return;\n            }\n        }\n\n        self.print_current_state();\n    }\n\n    fn cmd_run_to_end(\u0026mut self) {\n        while !matches!(self.vm.state, VMState::Halt | VMState::Fault) {\n            if let Err(e) = self.vm.execute_next() {\n                println!(\"Error: {}\", e);\n                break;\n            }\n        }\n\n        self.print_current_state();\n    }\n\n    fn cmd_breakpoint(\u0026mut self, args: \u0026[\u0026str]) {\n        if args.is_empty() {\n            println!(\"Usage: break \u003caddress\u003e\");\n            return;\n        }\n\n        let addr_str = args[0].trim_start_matches(\"0x\");\n        match usize::from_str_radix(addr_str, 16) {\n            Ok(addr) =\u003e {\n                if !self.breakpoints.contains(\u0026addr) {\n                    self.breakpoints.push(addr);\n                    println!(\"Breakpoint set at 0x{:04X}\", addr);\n                } else {\n                    println!(\"Breakpoint already exists at 0x{:04X}\", addr);\n                }\n            }\n            Err(_) =\u003e println!(\"Invalid address: {}\", args[0]),\n        }\n    }\n\n    fn cmd_delete_breakpoint(\u0026mut self, args: \u0026[\u0026str]) {\n        if args.is_empty() {\n            println!(\"Usage: delete \u003caddress\u003e\");\n            return;\n        }\n\n        let addr_str = args[0].trim_start_matches(\"0x\");\n        match usize::from_str_radix(addr_str, 16) {\n            Ok(addr) =\u003e {\n                if let Some(pos) = self.breakpoints.iter().position(|\u0026x| x == addr) {\n                    self.breakpoints.remove(pos);\n                    println!(\"Breakpoint removed at 0x{:04X}\", addr);\n                } else {\n                    println!(\"No breakpoint at 0x{:04X}\", addr);\n                }\n            }\n            Err(_) =\u003e println!(\"Invalid address: {}\", args[0]),\n        }\n    }\n\n    fn cmd_info(\u0026self, args: \u0026[\u0026str]) {\n        if args.is_empty() {\n            println!(\"Usage: info \u003cbreakpoints|registers\u003e\");\n            return;\n        }\n\n        match args[0] {\n            \"breakpoints\" | \"b\" =\u003e {\n                if self.breakpoints.is_empty() {\n                    println!(\"No breakpoints set.\");\n                } else {\n                    println!(\"Breakpoints:\");\n                    for (i, bp) in self.breakpoints.iter().enumerate() {\n                        println!(\"  {}: 0x{:04X}\", i + 1, bp);\n                    }\n                }\n            }\n            \"registers\" | \"r\" =\u003e {\n                println!(\"VM State:\");\n                println!(\"  State:        {:?}\", self.vm.state);\n                println!(\"  IP:           0x{:04X}\", self.get_current_ip());\n                println!(\"  Gas consumed: {}\", self.vm.gas_consumed);\n                println!(\"  Gas limit:    {}\", self.vm.gas_limit);\n                println!(\"  Stack depth:  {}\", self.vm.eval_stack.len());\n            }\n            _ =\u003e println!(\"Unknown info type: {}\", args[0]),\n        }\n    }\n\n    fn cmd_print(\u0026self, args: \u0026[\u0026str]) {\n        if args.is_empty() {\n            if let Some(top) = self.vm.eval_stack.last() {\n                println!(\"Top: {:?}\", top);\n            } else {\n                println!(\"Stack is empty.\");\n            }\n            return;\n        }\n\n        match args[0].parse::\u003cusize\u003e() {\n            Ok(idx) =\u003e {\n                let len = self.vm.eval_stack.len();\n                if idx \u003c len {\n                    println!(\"[{}]: {:?}\", idx, self.vm.eval_stack[len - 1 - idx]);\n                } else {\n                    println!(\"Index out of range (stack depth: {})\", len);\n                }\n            }\n            Err(_) =\u003e println!(\"Invalid index: {}\", args[0]),\n        }\n    }\n\n    fn cmd_stack(\u0026self) {\n        if self.vm.eval_stack.is_empty() {\n            println!(\"Stack is empty.\");\n        } else {\n            println!(\"Stack (top  bottom):\");\n            for (i, item) in self.vm.eval_stack.iter().rev().enumerate() {\n                println!(\"  [{}] {:?}\", i, item);\n            }\n        }\n    }\n\n    fn cmd_disasm(\u0026self) {\n        let disasm = Disassembler::new(\u0026self.script);\n        println!(\"{}\", disasm.disassemble());\n    }\n\n    fn cmd_reset(\u0026mut self) {\n        self.vm = NeoVM::new(self.vm.gas_limit);\n        let _ = self.vm.load_script(self.script.clone());\n        println!(\"VM reset to initial state.\");\n        self.print_current_state();\n    }\n\n    fn get_current_ip(\u0026self) -\u003e usize {\n        self.vm\n            .invocation_stack\n            .last()\n            .map(|ctx| ctx.ip)\n            .unwrap_or(0)\n    }\n\n    fn print_current_state(\u0026self) {\n        if matches!(self.vm.state, VMState::Halt) {\n            println!(\"Program halted. Gas consumed: {}\", self.vm.gas_consumed);\n            return;\n        }\n\n        if matches!(self.vm.state, VMState::Fault) {\n            println!(\"Program faulted!\");\n            return;\n        }\n\n        let ip = self.get_current_ip();\n        if ip \u003c self.script.len() {\n            let op = self.script[ip];\n            let disasm = Disassembler::new(\u0026self.script);\n            let (name, _) = disasm.decode_instruction(ip);\n            println!(\n                \" 0x{:04X}: {:02X}  {}    [gas: {}]\",\n                ip, op, name, self.vm.gas_consumed\n            );\n        }\n    }\n}\n\n// ============================================================================\n// Inspector\n// ============================================================================\n\nstruct Inspector\u003c'a\u003e {\n    script: \u0026'a [u8],\n}\n\nimpl\u003c'a\u003e Inspector\u003c'a\u003e {\n    fn new(script: \u0026'a [u8]) -\u003e Self {\n        Self { script }\n    }\n\n    fn analyze(\u0026self) -\u003e String {\n        let mut output = String::new();\n\n        output.push_str(\"\\n\");\n        output.push_str(\"  SCRIPT ANALYSIS\\n\");\n        output.push_str(\"\\n\\n\");\n\n        // Basic info\n        output.push_str(\u0026format!(\"  Size:         {} bytes\\n\", self.script.len()));\n        output.push_str(\u0026format!(\"  Hash (hex):   {}\\n\", hex::encode(self.script)));\n\n        // Opcode statistics\n        let stats = self.collect_opcode_stats();\n        output.push_str(\"\\n\\n\");\n        output.push_str(\"  OPCODE STATISTICS\\n\");\n        output.push_str(\"\\n\");\n\n        let mut sorted_stats: Vec\u003c_\u003e = stats.iter().collect();\n        sorted_stats.sort_by(|a, b| b.1.cmp(a.1));\n\n        for (name, count) in sorted_stats.iter().take(10) {\n            output.push_str(\u0026format!(\"    {:12} {:3}\\n\", name, count));\n        }\n\n        // Control flow analysis\n        let jumps = self.find_jump_targets();\n        if !jumps.is_empty() {\n            output.push_str(\"\\n\\n\");\n            output.push_str(\"  JUMP TARGETS\\n\");\n            output.push_str(\"\\n\");\n            for target in \u0026jumps {\n                output.push_str(\u0026format!(\"    0x{:04X}\\n\", target));\n            }\n        }\n\n        // Gas estimation\n        let estimated_gas = self.estimate_gas();\n        output.push_str(\"\\n\\n\");\n        output.push_str(\"  GAS ESTIMATION\\n\");\n        output.push_str(\"\\n\");\n        output.push_str(\u0026format!(\"    Minimum:    {}\\n\", estimated_gas.0));\n        output.push_str(\u0026format!(\"    Maximum:    {}\\n\", estimated_gas.1));\n\n        // Disassembly\n        output.push_str(\"\\n\\n\");\n        output.push_str(\"  DISASSEMBLY\\n\");\n        output.push_str(\"\\n\");\n        let disasm = Disassembler::new(self.script);\n        output.push_str(\u0026disasm.disassemble());\n\n        output.push_str(\"\\n\\n\");\n\n        output\n    }\n\n    fn collect_opcode_stats(\u0026self) -\u003e HashMap\u003cString, usize\u003e {\n        let mut stats = HashMap::new();\n        let disasm = Disassembler::new(self.script);\n        let mut ip = 0;\n\n        while ip \u003c self.script.len() {\n            let (name, size) = disasm.decode_instruction(ip);\n            *stats.entry(name).or_insert(0) += 1;\n            ip += size;\n        }\n\n        stats\n    }\n\n    fn find_jump_targets(\u0026self) -\u003e Vec\u003cusize\u003e {\n        let mut targets = Vec::new();\n        let mut ip = 0;\n\n        while ip \u003c self.script.len() {\n            let op = self.script[ip];\n            match op {\n                0x22 | 0x24 | 0x26 | 0x28 | 0x2A | 0x2C | 0x2E | 0x30 | 0x32 | 0x34 =\u003e {\n                    // 1-byte offset jumps\n                    if ip + 1 \u003c self.script.len() {\n                        let offset = self.script[ip + 1] as i8;\n                        let target = (ip as isize + offset as isize) as usize;\n                        if !targets.contains(\u0026target) {\n                            targets.push(target);\n                        }\n                    }\n                    ip += 2;\n                }\n                0x23 | 0x25 | 0x27 | 0x29 | 0x2B | 0x2D | 0x2F | 0x31 | 0x33 | 0x35 =\u003e {\n                    // 4-byte offset jumps\n                    if ip + 4 \u003c self.script.len() {\n                        let offset = i32::from_le_bytes([\n                            self.script[ip + 1],\n                            self.script[ip + 2],\n                            self.script[ip + 3],\n                            self.script[ip + 4],\n                        ]);\n                        let target = (ip as isize + offset as isize) as usize;\n                        if !targets.contains(\u0026target) {\n                            targets.push(target);\n                        }\n                    }\n                    ip += 5;\n                }\n                _ =\u003e ip += 1,\n            }\n        }\n\n        targets.sort();\n        targets\n    }\n\n    fn estimate_gas(\u0026self) -\u003e (u64, u64) {\n        let mut min_gas = 0u64;\n        let mut max_gas = 0u64;\n        let mut ip = 0;\n\n        while ip \u003c self.script.len() {\n            let op = self.script[ip];\n            let cost = match op {\n                0x0B..=0x20 =\u003e 1,\n                0x43..=0x55 =\u003e 2,\n                0x90..=0xBB =\u003e 8,\n                0x21..=0x40 =\u003e 2,\n                0xF0..=0xF2 =\u003e 512,\n                0xF3 =\u003e 32768,\n                0x41 =\u003e 16,\n                _ =\u003e 1,\n            };\n            min_gas += cost;\n            max_gas += cost;\n            ip += 1;\n        }\n\n        // Account for potential loops (rough estimate)\n        max_gas *= 10;\n\n        (min_gas, max_gas)\n    }\n}\n","traces":[{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-cli","tests","integration_tests.rs"],"content":"//! Integration tests for Neo zkVM\n\nuse neo_vm_core::StackItem;\nuse neo_vm_guest::{execute, ProofInput};\nuse neo_zkvm_prover::{NeoProver, ProverConfig};\nuse neo_zkvm_verifier::verify;\n\n#[test]\nfn test_full_prove_verify_cycle() {\n    let script = vec![\n        0x12, // PUSH2\n        0x13, // PUSH3\n        0x9E, // ADD\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert_eq!(proof.output.state, 0);\n    assert!(verify(\u0026proof));\n}\n\n#[test]\nfn test_complex_arithmetic() {\n    let script = vec![\n        0x14, // PUSH4\n        0x15, // PUSH5\n        0xA0, // MUL (4*5=20)\n        0x12, // PUSH2\n        0xA1, // DIV (20/2=10)\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(10)));\n}\n\n#[test]\nfn test_comparison_operations() {\n    let script = vec![\n        0x13, // PUSH3\n        0x15, // PUSH5\n        0xB5, // LT (3 \u003c 5 = true)\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let output = execute(input);\n    assert_eq!(output.result, Some(StackItem::Boolean(true)));\n}\n\n// ============================================================================\n// End-to-End Proof Generation and Verification Tests\n// ============================================================================\n\n#[test]\nfn test_prove_verify_with_arguments() {\n    let script = vec![\n        0x57, 0x00, 0x02, // INITSLOT 0 locals, 2 args\n        0x74, // LDARG0\n        0x75, // LDARG1\n        0x9E, // ADD\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![StackItem::Integer(10), StackItem::Integer(20)],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert_eq!(proof.output.state, 0);\n    assert_eq!(proof.output.result, Some(StackItem::Integer(30)));\n    assert!(verify(\u0026proof));\n}\n\n#[test]\nfn test_prove_verify_hash_operation() {\n    let script = vec![\n        0x0C, 0x05, b'h', b'e', b'l', b'l', b'o', 0xF0, // SHA256\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert_eq!(proof.output.state, 0);\n    assert!(verify(\u0026proof));\n}\n\n#[test]\nfn test_prove_verify_array_operations() {\n    let script = vec![\n        0x13, // PUSH3\n        0xC3, // NEWARRAY\n        0xCA, // SIZE\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert_eq!(proof.output.state, 0);\n    assert_eq!(proof.output.result, Some(StackItem::Integer(3)));\n    assert!(verify(\u0026proof));\n}\n\n#[test]\nfn test_prove_verify_control_flow() {\n    let script = vec![\n        0x15, // PUSH5\n        0x13, // PUSH3\n        0xB7, // GT (5 \u003e 3)\n        0x24, 0x03, // JMPIF +3\n        0x10, // PUSH0\n        0x22, 0x02, // JMP +2\n        0x11, // PUSH1\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert_eq!(proof.output.state, 0);\n    assert!(verify(\u0026proof));\n}\n\n#[test]\nfn test_execute_faulted_script() {\n    let script = vec![\n        0x15, // PUSH5\n        0x10, // PUSH0\n        0xA1, // DIV (5/0 = fault)\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Fault state\n}\n\n#[test]\nfn test_gas_tracking_in_proof() {\n    let script = vec![\n        0x15, 0x13, 0x9E, // 5 + 3\n        0x12, 0xA0, // * 2\n        0x40, // RET\n    ];\n\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n\n    let prover = NeoProver::new(ProverConfig::default());\n    let proof = prover.prove(input);\n\n    assert!(proof.output.gas_consumed \u003e 0);\n    assert!(proof.public_inputs.gas_consumed \u003e 0);\n}\n\n// ============================================================================\n// Security and Boundary Tests\n// ============================================================================\n\n#[test]\nfn test_script_size_limit() {\n    let script = vec![0x42; 1024 * 1024 + 1]; // 1MB + 1 byte\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault - script too large\n}\n\n#[test]\nfn test_stack_underflow_handling() {\n    let script = vec![0x45, 0x40]; // DROP on empty stack\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault - stack underflow\n}\n\n#[test]\nfn test_division_by_zero() {\n    let script = vec![0x15, 0x10, 0xA1, 0x40]; // 5, 0, DIV\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault - division by zero\n}\n\n#[test]\nfn test_gas_exhaustion() {\n    let script = vec![0x42; 100]; // 100 NOPs\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 10, // Very low gas limit\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault - out of gas\n}\n\n#[test]\nfn test_pushdata_boundary() {\n    // PUSHDATA1 with exact length matching remaining bytes\n    let mut script = vec![0x0C, 0x05]; // PUSHDATA1, length 5\n    script.extend_from_slice(b\"hello\");\n    script.push(0x40); // RET\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0); // Should succeed\n}\n\n#[test]\nfn test_pushdata_truncated() {\n    // PUSHDATA1 claims 10 bytes but only 5 available\n    let script = vec![0x0C, 0x0A, 0x42, 0x42, 0x42, 0x42, 0x42]; // 7 bytes total\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault - truncated data\n}\n\n#[test]\nfn test_loop_detection_by_gas() {\n    // Test that a loop consumes gas and eventually halts\n    let script = vec![0x22, 0xFE]; // JMP -2 (infinite loop)\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 100,\n    };\n    let output = execute(input);\n    // Should either fault (out of gas) or halt after some iterations\n    assert!(output.state == 0 || output.state == 1);\n    assert!(output.gas_consumed \u003e 0);\n}\n\n#[test]\nfn test_control_flow_jump_valid() {\n    // Simple NOP and RET test\n    let script = vec![\n        0x21, // NOP\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n}\n\n#[test]\nfn test_control_flow_abort() {\n    // Test ABORT instruction\n    let script = vec![\n        0x15, // PUSH5\n        0x38, // ABORT\n        0x40, // RET (unreachable)\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault\n}\n\n#[test]\nfn test_control_flow_assert() {\n    // Test ASSERT - fails when condition is false\n    let script = vec![\n        0x10, // PUSH0 (false)\n        0x39, // ASSERT (fails)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 1); // Should fault\n}\n\n#[test]\nfn test_control_flow_jump_backward() {\n    // Test backward jump (loop)\n    let script = vec![\n        0x10, // PUSH0 (counter)\n        0x22, 0x03, // JMP +3 (jump to INC)\n        0x9C, // INC (increment)\n        0x22, 0xFB, // JMP -5 (jump back to counter)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n}\n\n#[test]\nfn test_bitwise_operations() {\n    let script = vec![\n        0x14, // PUSH4\n        0x13, // PUSH3\n        0x91, // AND (4 \u0026 3 = 0)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(0)));\n}\n\n#[test]\nfn test_shift_operations() {\n    let script = vec![\n        0x12, // PUSH2\n        0x11, // PUSH1\n        0xA8, // SHL (2 \u003c\u003c 1 = 4)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(4)));\n}\n\n#[test]\nfn test_modulo_operations() {\n    let script = vec![\n        0x17, // PUSH7\n        0x13, // PUSH3\n        0xA2, // MOD (7 % 3 = 1)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(1)));\n}\n\n#[test]\nfn test_power_operations() {\n    let script = vec![\n        0x12, // PUSH2\n        0x11, // PUSH1\n        0xA3, // POW (2^1 = 2)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(2)));\n}\n\n#[test]\nfn test_min_max_operations() {\n    let script = vec![\n        0x0F, // PUSHM1 (-1)\n        0x11, // PUSH1 (1)\n        0xB9, // MIN (-1 \u003c 1 = -1)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(-1)));\n}\n\n#[test]\nfn test_within_range_check() {\n    let script = vec![\n        0x15, // PUSH5\n        0x10, // PUSH0\n        0x17, // PUSH7\n        0xBB, // WITHIN (0 \u003c= 5 \u003c 7 = true)\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Boolean(true)));\n}\n\n// ============================================================================\n// Native Contract Tests\n// ============================================================================\n\n#[test]\nfn test_native_stdlib_serialize() {\n    // This would require syscall support, skip for now\n}\n\n#[test]\nfn test_native_crypto_sha256() {\n    let script = vec![\n        0x0C, 0x04, b't', b'e', b's', b't', // PUSHDATA1 \"test\" (4 bytes)\n        0xF0, // SHA256\n        0xCA, // SIZE\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    assert_eq!(output.result, Some(StackItem::Integer(32))); // SHA256 produces 32 bytes\n}\n\n#[test]\nfn test_native_crypto_ripemd160() {\n    let script = vec![\n        0x0C, 0x03, b'a', b'b', b'c', // PUSHDATA1 \"abc\"\n        0xF1, // RIPEMD160\n        0x40, // RET\n    ];\n    let input = ProofInput {\n        script,\n        arguments: vec![],\n        gas_limit: 1_000_000,\n    };\n    let output = execute(input);\n    assert_eq!(output.state, 0);\n    if let Some(StackItem::ByteString(hash)) = \u0026output.result {\n        assert_eq!(hash.len(), 20); // RIPEMD160 produces 20 bytes\n    } else {\n        panic!(\"Expected ByteString result\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-program","src","main.rs"],"content":"//! Neo zkVM SP1 Guest Program - Production Grade\n//!\n//! Full Neo N3 VM implementation for zero-knowledge proving.\n\n#![no_main]\nsp1_zkvm::entrypoint!(main);\n\nuse serde::{Deserialize, Serialize};\n\n/// Input for zkVM proving\n#[derive(Serialize, Deserialize, Clone)]\npub struct GuestInput {\n    pub script: Vec\u003cu8\u003e,\n    pub arguments: Vec\u003cStackItem\u003e,\n    pub gas_limit: u64,\n}\n\n/// Stack item types matching Neo VM\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum StackItem {\n    Null,\n    Boolean(bool),\n    Integer(i128),\n    ByteString(Vec\u003cu8\u003e),\n    Array(Vec\u003cStackItem\u003e),\n    Map(Vec\u003c(StackItem, StackItem)\u003e),\n    Struct(Vec\u003cStackItem\u003e),\n}\n\nimpl StackItem {\n    fn to_bool(\u0026self) -\u003e bool {\n        match self {\n            StackItem::Boolean(b) =\u003e *b,\n            StackItem::Integer(i) =\u003e *i != 0,\n            StackItem::ByteString(b) =\u003e !b.is_empty() \u0026\u0026 b.iter().any(|\u0026x| x != 0),\n            StackItem::Null =\u003e false,\n            _ =\u003e true,\n        }\n    }\n\n    fn to_integer(\u0026self) -\u003e Option\u003ci128\u003e {\n        match self {\n            StackItem::Integer(i) =\u003e Some(*i),\n            StackItem::Boolean(b) =\u003e Some(*b as i128),\n            StackItem::ByteString(b) if b.len() \u003c= 16 =\u003e {\n                let mut arr = [0u8; 16];\n                arr[..b.len()].copy_from_slice(b);\n                Some(i128::from_le_bytes(arr))\n            }\n            _ =\u003e None,\n        }\n    }\n\n    fn to_bytes(\u0026self) -\u003e Vec\u003cu8\u003e {\n        match self {\n            StackItem::ByteString(b) =\u003e b.clone(),\n            StackItem::Integer(i) =\u003e i.to_le_bytes().to_vec(),\n            StackItem::Boolean(b) =\u003e vec![*b as u8],\n            _ =\u003e vec![],\n        }\n    }\n}\n\n/// Public values committed to the proof\n#[derive(Serialize, Deserialize)]\npub struct PublicValues {\n    pub script_hash: [u8; 32],\n    pub input_hash: [u8; 32],\n    pub output_hash: [u8; 32],\n    pub gas_consumed: u64,\n    pub execution_success: bool,\n}\n\n/// VM execution state\n#[derive(Debug, Clone, Copy, PartialEq)]\nenum VMState {\n    Running,\n    Halt,\n    Fault,\n}\n\n/// Execution context for call stack\nstruct ExecutionContext {\n    script: Vec\u003cu8\u003e,\n    ip: usize,\n}\n\n/// Neo VM implementation for zkVM guest\nstruct NeoVM {\n    state: VMState,\n    eval_stack: Vec\u003cStackItem\u003e,\n    invocation_stack: Vec\u003cExecutionContext\u003e,\n    gas_consumed: u64,\n    gas_limit: u64,\n    local_slots: Vec\u003cStackItem\u003e,\n    argument_slots: Vec\u003cStackItem\u003e,\n    static_slots: Vec\u003cStackItem\u003e,\n}\n\nimpl NeoVM {\n    fn new(gas_limit: u64) -\u003e Self {\n        Self {\n            state: VMState::Running,\n            eval_stack: Vec::new(),\n            invocation_stack: Vec::new(),\n            gas_consumed: 0,\n            gas_limit,\n            local_slots: Vec::new(),\n            argument_slots: Vec::new(),\n            static_slots: Vec::new(),\n        }\n    }\n\n    fn load_script(\u0026mut self, script: Vec\u003cu8\u003e) {\n        self.invocation_stack\n            .push(ExecutionContext { script, ip: 0 });\n    }\n\n    fn current_context(\u0026mut self) -\u003e Option\u003c\u0026mut ExecutionContext\u003e {\n        self.invocation_stack.last_mut()\n    }\n\n    fn consume_gas(\u0026mut self, amount: u64) -\u003e bool {\n        self.gas_consumed += amount;\n        self.gas_consumed \u003c= self.gas_limit\n    }\n\n    fn pop(\u0026mut self) -\u003e Option\u003cStackItem\u003e {\n        self.eval_stack.pop()\n    }\n\n    fn push(\u0026mut self, item: StackItem) {\n        self.eval_stack.push(item);\n    }\n\n    fn peek(\u0026self, index: usize) -\u003e Option\u003c\u0026StackItem\u003e {\n        let len = self.eval_stack.len();\n        if index \u003c len {\n            Some(\u0026self.eval_stack[len - 1 - index])\n        } else {\n            None\n        }\n    }\n\n    fn read_byte(\u0026mut self) -\u003e Option\u003cu8\u003e {\n        let ctx = self.current_context()?;\n        if ctx.ip \u003c ctx.script.len() {\n            let b = ctx.script[ctx.ip];\n            ctx.ip += 1;\n            Some(b)\n        } else {\n            None\n        }\n    }\n\n    fn read_i8(\u0026mut self) -\u003e Option\u003ci8\u003e {\n        self.read_byte().map(|b| b as i8)\n    }\n\n    fn read_i16(\u0026mut self) -\u003e Option\u003ci16\u003e {\n        let lo = self.read_byte()? as i16;\n        let hi = self.read_byte()? as i16;\n        Some(lo | (hi \u003c\u003c 8))\n    }\n\n    fn read_i32(\u0026mut self) -\u003e Option\u003ci32\u003e {\n        let b0 = self.read_byte()? as i32;\n        let b1 = self.read_byte()? as i32;\n        let b2 = self.read_byte()? as i32;\n        let b3 = self.read_byte()? as i32;\n        Some(b0 | (b1 \u003c\u003c 8) | (b2 \u003c\u003c 16) | (b3 \u003c\u003c 24))\n    }\n\n    fn read_bytes(\u0026mut self, count: usize) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        let mut result = Vec::with_capacity(count);\n        for _ in 0..count {\n            result.push(self.read_byte()?);\n        }\n        Some(result)\n    }\n\n    fn execute(\u0026mut self) {\n        while self.state == VMState::Running {\n            if !self.execute_next() {\n                break;\n            }\n        }\n    }\n\n    fn execute_next(\u0026mut self) -\u003e bool {\n        let opcode = match self.read_byte() {\n            Some(op) =\u003e op,\n            None =\u003e {\n                self.state = VMState::Halt;\n                return false;\n            }\n        };\n\n        if !self.consume_gas(1) {\n            self.state = VMState::Fault;\n            return false;\n        }\n\n        self.execute_opcode(opcode)\n    }\n\n    fn execute_opcode(\u0026mut self, opcode: u8) -\u003e bool {\n        match opcode {\n            // === Constants ===\n            0x00 =\u003e self.op_pushint8(),\n            0x01 =\u003e self.op_pushint16(),\n            0x02 =\u003e self.op_pushint32(),\n            0x03 =\u003e self.op_pushint64(),\n            0x04 =\u003e self.op_pushint128(),\n            0x05 =\u003e self.op_pushint256(),\n            0x0B =\u003e {\n                self.push(StackItem::Null);\n                true\n            }\n            0x0C =\u003e self.op_pushdata1(),\n            0x0D =\u003e self.op_pushdata2(),\n            0x0E =\u003e self.op_pushdata4(),\n            0x0F =\u003e {\n                self.push(StackItem::Integer(-1));\n                true\n            }\n            0x10..=0x20 =\u003e {\n                self.push(StackItem::Integer((opcode - 0x10) as i128));\n                true\n            }\n\n            // === Flow Control ===\n            0x21 =\u003e true, // NOP\n            0x22 =\u003e self.op_jmp(),\n            0x23 =\u003e self.op_jmp_l(),\n            0x24 =\u003e self.op_jmpif(),\n            0x25 =\u003e self.op_jmpif_l(),\n            0x26 =\u003e self.op_jmpifnot(),\n            0x27 =\u003e self.op_jmpifnot_l(),\n            0x28 =\u003e self.op_jmpeq(),\n            0x29 =\u003e self.op_jmpeq_l(),\n            0x2A =\u003e self.op_jmpne(),\n            0x2B =\u003e self.op_jmpne_l(),\n            0x2C =\u003e self.op_jmpgt(),\n            0x2D =\u003e self.op_jmpgt_l(),\n            0x2E =\u003e self.op_jmpge(),\n            0x2F =\u003e self.op_jmpge_l(),\n            0x30 =\u003e self.op_jmplt(),\n            0x31 =\u003e self.op_jmplt_l(),\n            0x32 =\u003e self.op_jmple(),\n            0x33 =\u003e self.op_jmple_l(),\n            0x34 =\u003e self.op_call(),\n            0x35 =\u003e self.op_call_l(),\n            0x38 =\u003e {\n                self.state = VMState::Fault;\n                false\n            } // ABORT\n            0x39 =\u003e self.op_assert(),\n            0x40 =\u003e self.op_ret(),\n\n            // === Stack Operations ===\n            0x43 =\u003e {\n                self.push(StackItem::Integer(self.eval_stack.len() as i128));\n                true\n            }\n            0x45 =\u003e {\n                self.pop();\n                true\n            } // DROP\n            0x46 =\u003e self.op_nip(),\n            0x48 =\u003e self.op_xdrop(),\n            0x49 =\u003e {\n                self.eval_stack.clear();\n                true\n            } // CLEAR\n            0x4A =\u003e self.op_dup(),\n            0x4B =\u003e self.op_over(),\n            0x4D =\u003e self.op_pick(),\n            0x4E =\u003e self.op_tuck(),\n            0x50 =\u003e self.op_swap(),\n            0x51 =\u003e self.op_rot(),\n            0x52 =\u003e self.op_roll(),\n            0x53 =\u003e self.op_reverse3(),\n            0x54 =\u003e self.op_reverse4(),\n            0x55 =\u003e self.op_reversen(),\n\n            // === Slot Operations ===\n            0x56 =\u003e self.op_initsslot(),\n            0x57 =\u003e self.op_initslot(),\n            0x58..=0x5D =\u003e self.op_ldsfld_n(opcode - 0x58),\n            0x5E =\u003e self.op_ldsfld(),\n            0x5F..=0x64 =\u003e self.op_stsfld_n(opcode - 0x5F),\n            0x65 =\u003e self.op_stsfld(),\n            0x66..=0x6B =\u003e self.op_ldloc_n(opcode - 0x66),\n            0x6C =\u003e self.op_ldloc(),\n            0x6D..=0x72 =\u003e self.op_stloc_n(opcode - 0x6D),\n            0x73 =\u003e self.op_stloc(),\n            0x74..=0x79 =\u003e self.op_ldarg_n(opcode - 0x74),\n            0x7A =\u003e self.op_ldarg(),\n            0x7B..=0x80 =\u003e self.op_starg_n(opcode - 0x7B),\n            0x81 =\u003e self.op_starg(),\n\n            // === Splice Operations ===\n            0x88 =\u003e self.op_newbuffer(),\n            0x8B =\u003e self.op_cat(),\n            0x8C =\u003e self.op_substr(),\n            0x8D =\u003e self.op_left(),\n            0x8E =\u003e self.op_right(),\n\n            // === Bitwise Operations ===\n            0x90 =\u003e self.op_invert(),\n            0x91 =\u003e self.op_and(),\n            0x92 =\u003e self.op_or(),\n            0x93 =\u003e self.op_xor(),\n            0x97 =\u003e self.op_equal(),\n            0x98 =\u003e self.op_notequal(),\n\n            // === Arithmetic Operations ===\n            0x99 =\u003e self.op_sign(),\n            0x9A =\u003e self.op_abs(),\n            0x9B =\u003e self.op_negate(),\n            0x9C =\u003e self.op_inc(),\n            0x9D =\u003e self.op_dec(),\n            0x9E =\u003e self.op_add(),\n            0x9F =\u003e self.op_sub(),\n            0xA0 =\u003e self.op_mul(),\n            0xA1 =\u003e self.op_div(),\n            0xA2 =\u003e self.op_mod(),\n            0xA3 =\u003e self.op_pow(),\n            0xA4 =\u003e self.op_sqrt(),\n            0xA8 =\u003e self.op_shl(),\n            0xA9 =\u003e self.op_shr(),\n            0xAA =\u003e self.op_not(),\n            0xAB =\u003e self.op_booland(),\n            0xAC =\u003e self.op_boolor(),\n            0xB1 =\u003e self.op_nz(),\n            0xB3 =\u003e self.op_numequal(),\n            0xB4 =\u003e self.op_numnotequal(),\n            0xB5 =\u003e self.op_lt(),\n            0xB6 =\u003e self.op_le(),\n            0xB7 =\u003e self.op_gt(),\n            0xB8 =\u003e self.op_ge(),\n            0xB9 =\u003e self.op_min(),\n            0xBA =\u003e self.op_max(),\n            0xBB =\u003e self.op_within(),\n\n            // === Compound Types ===\n            0xC0 =\u003e self.op_pack(),\n            0xC1 =\u003e self.op_unpack(),\n            0xC2 =\u003e {\n                self.push(StackItem::Array(vec![]));\n                true\n            }\n            0xC3 =\u003e self.op_newarray(),\n            0xC5 =\u003e {\n                self.push(StackItem::Struct(vec![]));\n                true\n            }\n            0xC6 =\u003e self.op_newstruct(),\n            0xC8 =\u003e {\n                self.push(StackItem::Map(vec![]));\n                true\n            }\n            0xCA =\u003e self.op_size(),\n            0xCB =\u003e self.op_haskey(),\n            0xCE =\u003e self.op_pickitem(),\n            0xCF =\u003e self.op_append(),\n            0xD0 =\u003e self.op_setitem(),\n            0xD2 =\u003e self.op_remove(),\n            0xD3 =\u003e self.op_clearitems(),\n\n            // === Type Operations ===\n            0xD8 =\u003e self.op_isnull(),\n            0xD9 =\u003e self.op_istype(),\n\n            _ =\u003e {\n                self.state = VMState::Fault;\n                false\n            }\n        }\n    }\n\n    // === Push Operations ===\n    fn op_pushint8(\u0026mut self) -\u003e bool {\n        let v = self.read_i8().unwrap_or(0) as i128;\n        self.push(StackItem::Integer(v));\n        true\n    }\n\n    fn op_pushint16(\u0026mut self) -\u003e bool {\n        let v = self.read_i16().unwrap_or(0) as i128;\n        self.push(StackItem::Integer(v));\n        true\n    }\n\n    fn op_pushint32(\u0026mut self) -\u003e bool {\n        let v = self.read_i32().unwrap_or(0) as i128;\n        self.push(StackItem::Integer(v));\n        true\n    }\n\n    fn op_pushint64(\u0026mut self) -\u003e bool {\n        let mut bytes = [0u8; 8];\n        for b in \u0026mut bytes {\n            *b = self.read_byte().unwrap_or(0);\n        }\n        self.push(StackItem::Integer(i64::from_le_bytes(bytes) as i128));\n        true\n    }\n\n    fn op_pushint128(\u0026mut self) -\u003e bool {\n        let mut bytes = [0u8; 16];\n        for b in \u0026mut bytes {\n            *b = self.read_byte().unwrap_or(0);\n        }\n        self.push(StackItem::Integer(i128::from_le_bytes(bytes)));\n        true\n    }\n\n    fn op_pushint256(\u0026mut self) -\u003e bool {\n        let bytes = self.read_bytes(32).unwrap_or_default();\n        let mut arr = [0u8; 16];\n        arr.copy_from_slice(\u0026bytes[..16]);\n        self.push(StackItem::Integer(i128::from_le_bytes(arr)));\n        true\n    }\n\n    fn op_pushdata1(\u0026mut self) -\u003e bool {\n        let len = self.read_byte().unwrap_or(0) as usize;\n        let data = self.read_bytes(len).unwrap_or_default();\n        self.push(StackItem::ByteString(data));\n        true\n    }\n\n    fn op_pushdata2(\u0026mut self) -\u003e bool {\n        let len = self.read_i16().unwrap_or(0) as usize;\n        let data = self.read_bytes(len).unwrap_or_default();\n        self.push(StackItem::ByteString(data));\n        true\n    }\n\n    fn op_pushdata4(\u0026mut self) -\u003e bool {\n        let len = self.read_i32().unwrap_or(0) as usize;\n        let data = self.read_bytes(len).unwrap_or_default();\n        self.push(StackItem::ByteString(data));\n        true\n    }\n\n    // === Flow Control ===\n    fn op_jmp(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        self.jump(offset - 2)\n    }\n\n    fn op_jmp_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        self.jump(offset - 5)\n    }\n\n    fn op_jmpif(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        if self.pop().map(|i| i.to_bool()).unwrap_or(false) {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpif_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        if self.pop().map(|i| i.to_bool()).unwrap_or(false) {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpifnot(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        if !self.pop().map(|i| i.to_bool()).unwrap_or(true) {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpifnot_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        if !self.pop().map(|i| i.to_bool()).unwrap_or(true) {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn jump(\u0026mut self, offset: isize) -\u003e bool {\n        if let Some(ctx) = self.current_context() {\n            let new_ip = (ctx.ip as isize + offset) as usize;\n            if new_ip \u003c= ctx.script.len() {\n                ctx.ip = new_ip;\n                return true;\n            }\n        }\n        self.state = VMState::Fault;\n        false\n    }\n\n    fn op_jmpeq(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a == b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpeq_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a == b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpne(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a != b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpne_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a != b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpgt(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003e b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpgt_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003e b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpge(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003e= b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmpge_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003e= b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmplt(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003c b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmplt_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003c b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmple(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003c= b {\n            self.jump(offset - 2)\n        } else {\n            true\n        }\n    }\n\n    fn op_jmple_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003c= b {\n            self.jump(offset - 5)\n        } else {\n            true\n        }\n    }\n\n    fn op_call(\u0026mut self) -\u003e bool {\n        let offset = self.read_i8().unwrap_or(0) as isize;\n        if let Some(ctx) = self.current_context() {\n            let target = (ctx.ip as isize + offset - 2) as usize;\n            let script = ctx.script.clone();\n            self.invocation_stack\n                .push(ExecutionContext { script, ip: target });\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_call_l(\u0026mut self) -\u003e bool {\n        let offset = self.read_i32().unwrap_or(0) as isize;\n        if let Some(ctx) = self.current_context() {\n            let target = (ctx.ip as isize + offset - 5) as usize;\n            let script = ctx.script.clone();\n            self.invocation_stack\n                .push(ExecutionContext { script, ip: target });\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_ret(\u0026mut self) -\u003e bool {\n        self.invocation_stack.pop();\n        if self.invocation_stack.is_empty() {\n            self.state = VMState::Halt;\n        }\n        true\n    }\n\n    fn op_assert(\u0026mut self) -\u003e bool {\n        if !self.pop().map(|i| i.to_bool()).unwrap_or(false) {\n            self.state = VMState::Fault;\n            false\n        } else {\n            true\n        }\n    }\n\n    // === Stack Operations ===\n    fn op_nip(\u0026mut self) -\u003e bool {\n        if self.eval_stack.len() \u003e= 2 {\n            let top = self.pop().unwrap();\n            self.pop();\n            self.push(top);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_xdrop(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        if n \u003c self.eval_stack.len() {\n            let idx = self.eval_stack.len() - 1 - n;\n            self.eval_stack.remove(idx);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_dup(\u0026mut self) -\u003e bool {\n        if let Some(item) = self.peek(0).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_over(\u0026mut self) -\u003e bool {\n        if let Some(item) = self.peek(1).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_pick(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        if let Some(item) = self.peek(n).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_tuck(\u0026mut self) -\u003e bool {\n        if self.eval_stack.len() \u003e= 2 {\n            let top = self.peek(0).cloned().unwrap();\n            let len = self.eval_stack.len();\n            self.eval_stack.insert(len - 2, top);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_swap(\u0026mut self) -\u003e bool {\n        let len = self.eval_stack.len();\n        if len \u003e= 2 {\n            self.eval_stack.swap(len - 1, len - 2);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_rot(\u0026mut self) -\u003e bool {\n        let len = self.eval_stack.len();\n        if len \u003e= 3 {\n            let item = self.eval_stack.remove(len - 3);\n            self.eval_stack.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_roll(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let len = self.eval_stack.len();\n        if n \u003c len {\n            let item = self.eval_stack.remove(len - 1 - n);\n            self.eval_stack.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_reverse3(\u0026mut self) -\u003e bool {\n        let len = self.eval_stack.len();\n        if len \u003e= 3 {\n            self.eval_stack[len - 3..].reverse();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_reverse4(\u0026mut self) -\u003e bool {\n        let len = self.eval_stack.len();\n        if len \u003e= 4 {\n            self.eval_stack[len - 4..].reverse();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_reversen(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let len = self.eval_stack.len();\n        if n \u003c= len {\n            self.eval_stack[len - n..].reverse();\n            true\n        } else {\n            false\n        }\n    }\n\n    // === Slot Operations ===\n    fn op_initsslot(\u0026mut self) -\u003e bool {\n        let count = self.read_byte().unwrap_or(0) as usize;\n        self.static_slots = vec![StackItem::Null; count];\n        true\n    }\n\n    fn op_initslot(\u0026mut self) -\u003e bool {\n        let locals = self.read_byte().unwrap_or(0) as usize;\n        let args = self.read_byte().unwrap_or(0) as usize;\n        self.local_slots = vec![StackItem::Null; locals];\n        self.argument_slots = (0..args).filter_map(|_| self.pop()).collect();\n        self.argument_slots.reverse();\n        true\n    }\n\n    fn op_ldsfld_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.static_slots.get(n as usize).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_ldsfld(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.static_slots.get(n).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_stsfld_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.pop() {\n            let n = n as usize;\n            if n \u003c self.static_slots.len() {\n                self.static_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    fn op_stsfld(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.pop() {\n            if n \u003c self.static_slots.len() {\n                self.static_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    fn op_ldloc_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.local_slots.get(n as usize).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_ldloc(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.local_slots.get(n).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_stloc_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.pop() {\n            let n = n as usize;\n            if n \u003c self.local_slots.len() {\n                self.local_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    fn op_stloc(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.pop() {\n            if n \u003c self.local_slots.len() {\n                self.local_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    fn op_ldarg_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.argument_slots.get(n as usize).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_ldarg(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.argument_slots.get(n).cloned() {\n            self.push(item);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_starg_n(\u0026mut self, n: u8) -\u003e bool {\n        if let Some(item) = self.pop() {\n            let n = n as usize;\n            if n \u003c self.argument_slots.len() {\n                self.argument_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    fn op_starg(\u0026mut self) -\u003e bool {\n        let n = self.read_byte().unwrap_or(0) as usize;\n        if let Some(item) = self.pop() {\n            if n \u003c self.argument_slots.len() {\n                self.argument_slots[n] = item;\n                true\n            } else {\n                false\n            }\n        } else {\n            false\n        }\n    }\n\n    // === Arithmetic Operations ===\n    fn op_add(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.wrapping_add(b)));\n        true\n    }\n\n    fn op_sub(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.wrapping_sub(b)));\n        true\n    }\n\n    fn op_mul(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.wrapping_mul(b)));\n        true\n    }\n\n    fn op_div(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if b == 0 {\n            self.state = VMState::Fault;\n            false\n        } else {\n            self.push(StackItem::Integer(a / b));\n            true\n        }\n    }\n\n    fn op_mod(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if b == 0 {\n            self.state = VMState::Fault;\n            false\n        } else {\n            self.push(StackItem::Integer(a % b));\n            true\n        }\n    }\n\n    fn op_pow(\u0026mut self) -\u003e bool {\n        let exp = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let base = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let result = if exp \u003e= 0 { base.pow(exp as u32) } else { 0 };\n        self.push(StackItem::Integer(result));\n        true\n    }\n\n    fn op_sqrt(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        if a \u003c 0 {\n            self.state = VMState::Fault;\n            false\n        } else {\n            self.push(StackItem::Integer((a as f64).sqrt() as i128));\n            true\n        }\n    }\n\n    fn op_sign(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.signum()));\n        true\n    }\n\n    fn op_abs(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.abs()));\n        true\n    }\n\n    fn op_negate(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(-a));\n        true\n    }\n\n    fn op_inc(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a + 1));\n        true\n    }\n\n    fn op_dec(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a - 1));\n        true\n    }\n\n    // === Bitwise Operations ===\n    fn op_and(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a \u0026 b));\n        true\n    }\n\n    fn op_or(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a | b));\n        true\n    }\n\n    fn op_xor(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a ^ b));\n        true\n    }\n\n    fn op_invert(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(!a));\n        true\n    }\n\n    fn op_shl(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as u32;\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a \u003c\u003c n));\n        true\n    }\n\n    fn op_shr(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as u32;\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a \u003e\u003e n));\n        true\n    }\n\n    fn op_not(\u0026mut self) -\u003e bool {\n        let a = self.pop().map(|i| i.to_bool()).unwrap_or(false);\n        self.push(StackItem::Boolean(!a));\n        true\n    }\n\n    fn op_booland(\u0026mut self) -\u003e bool {\n        let b = self.pop().map(|i| i.to_bool()).unwrap_or(false);\n        let a = self.pop().map(|i| i.to_bool()).unwrap_or(false);\n        self.push(StackItem::Boolean(a \u0026\u0026 b));\n        true\n    }\n\n    fn op_boolor(\u0026mut self) -\u003e bool {\n        let b = self.pop().map(|i| i.to_bool()).unwrap_or(false);\n        let a = self.pop().map(|i| i.to_bool()).unwrap_or(false);\n        self.push(StackItem::Boolean(a || b));\n        true\n    }\n\n    fn op_nz(\u0026mut self) -\u003e bool {\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a != 0));\n        true\n    }\n\n    fn op_numequal(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a == b));\n        true\n    }\n\n    fn op_numnotequal(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a != b));\n        true\n    }\n\n    fn op_lt(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a \u003c b));\n        true\n    }\n\n    fn op_le(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a \u003c= b));\n        true\n    }\n\n    fn op_gt(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a \u003e b));\n        true\n    }\n\n    fn op_ge(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a \u003e= b));\n        true\n    }\n\n    fn op_min(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.min(b)));\n        true\n    }\n\n    fn op_max(\u0026mut self) -\u003e bool {\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Integer(a.max(b)));\n        true\n    }\n\n    fn op_within(\u0026mut self) -\u003e bool {\n        let c = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let b = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        let a = self.pop().and_then(|i| i.to_integer()).unwrap_or(0);\n        self.push(StackItem::Boolean(a \u003e= b \u0026\u0026 a \u003c c));\n        true\n    }\n\n    // === Splice Operations ===\n    fn op_newbuffer(\u0026mut self) -\u003e bool {\n        let size = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        self.push(StackItem::ByteString(vec![0u8; size]));\n        true\n    }\n\n    fn op_cat(\u0026mut self) -\u003e bool {\n        let b = self.pop().map(|i| i.to_bytes()).unwrap_or_default();\n        let mut a = self.pop().map(|i| i.to_bytes()).unwrap_or_default();\n        a.extend(b);\n        self.push(StackItem::ByteString(a));\n        true\n    }\n\n    fn op_substr(\u0026mut self) -\u003e bool {\n        let count = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let index = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let s = self.pop().map(|i| i.to_bytes()).unwrap_or_default();\n        let end = (index + count).min(s.len());\n        self.push(StackItem::ByteString(s[index..end].to_vec()));\n        true\n    }\n\n    fn op_left(\u0026mut self) -\u003e bool {\n        let count = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let s = self.pop().map(|i| i.to_bytes()).unwrap_or_default();\n        self.push(StackItem::ByteString(s[..count.min(s.len())].to_vec()));\n        true\n    }\n\n    fn op_right(\u0026mut self) -\u003e bool {\n        let count = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let s = self.pop().map(|i| i.to_bytes()).unwrap_or_default();\n        let start = s.len().saturating_sub(count);\n        self.push(StackItem::ByteString(s[start..].to_vec()));\n        true\n    }\n\n    fn op_equal(\u0026mut self) -\u003e bool {\n        let b = self.pop();\n        let a = self.pop();\n        self.push(StackItem::Boolean(a == b));\n        true\n    }\n\n    fn op_notequal(\u0026mut self) -\u003e bool {\n        let b = self.pop();\n        let a = self.pop();\n        self.push(StackItem::Boolean(a != b));\n        true\n    }\n\n    // === Compound Type Operations ===\n    fn op_pack(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        let mut items = Vec::with_capacity(n);\n        for _ in 0..n {\n            if let Some(item) = self.pop() {\n                items.push(item);\n            }\n        }\n        items.reverse();\n        self.push(StackItem::Array(items));\n        true\n    }\n\n    fn op_unpack(\u0026mut self) -\u003e bool {\n        if let Some(StackItem::Array(items)) = self.pop() {\n            let len = items.len();\n            for item in items {\n                self.push(item);\n            }\n            self.push(StackItem::Integer(len as i128));\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_newarray(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        self.push(StackItem::Array(vec![StackItem::Null; n]));\n        true\n    }\n\n    fn op_newstruct(\u0026mut self) -\u003e bool {\n        let n = self.pop().and_then(|i| i.to_integer()).unwrap_or(0) as usize;\n        self.push(StackItem::Struct(vec![StackItem::Null; n]));\n        true\n    }\n\n    fn op_size(\u0026mut self) -\u003e bool {\n        let size = match self.pop() {\n            Some(StackItem::ByteString(b)) =\u003e b.len(),\n            Some(StackItem::Array(a)) =\u003e a.len(),\n            Some(StackItem::Map(m)) =\u003e m.len(),\n            Some(StackItem::Struct(s)) =\u003e s.len(),\n            _ =\u003e 0,\n        };\n        self.push(StackItem::Integer(size as i128));\n        true\n    }\n\n    fn op_haskey(\u0026mut self) -\u003e bool {\n        let key = self.pop();\n        let container = self.pop();\n        let has = match (container, key) {\n            (Some(StackItem::Array(a)), Some(StackItem::Integer(i))) =\u003e (i as usize) \u003c a.len(),\n            (Some(StackItem::Map(m)), Some(k)) =\u003e m.iter().any(|(mk, _)| *mk == k),\n            _ =\u003e false,\n        };\n        self.push(StackItem::Boolean(has));\n        true\n    }\n\n    fn op_pickitem(\u0026mut self) -\u003e bool {\n        let key = self.pop();\n        let container = self.pop();\n        match (container, key) {\n            (Some(StackItem::Array(a)), Some(StackItem::Integer(i))) =\u003e {\n                if let Some(item) = a.get(i as usize).cloned() {\n                    self.push(item);\n                    true\n                } else {\n                    false\n                }\n            }\n            (Some(StackItem::Map(m)), Some(k)) =\u003e {\n                if let Some((_, v)) = m.iter().find(|(mk, _)| *mk == k) {\n                    self.push(v.clone());\n                    true\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false,\n        }\n    }\n\n    fn op_append(\u0026mut self) -\u003e bool {\n        let item = self.pop();\n        if let (Some(StackItem::Array(mut a)), Some(i)) = (self.pop(), item) {\n            a.push(i);\n            self.push(StackItem::Array(a));\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_setitem(\u0026mut self) -\u003e bool {\n        let value = self.pop();\n        let key = self.pop();\n        let container = self.pop();\n        match (container, key, value) {\n            (Some(StackItem::Array(mut a)), Some(StackItem::Integer(i)), Some(v)) =\u003e {\n                let idx = i as usize;\n                if idx \u003c a.len() {\n                    a[idx] = v;\n                    self.push(StackItem::Array(a));\n                    true\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false,\n        }\n    }\n\n    fn op_remove(\u0026mut self) -\u003e bool {\n        let key = self.pop();\n        let container = self.pop();\n        match (container, key) {\n            (Some(StackItem::Array(mut a)), Some(StackItem::Integer(i))) =\u003e {\n                let idx = i as usize;\n                if idx \u003c a.len() {\n                    a.remove(idx);\n                    self.push(StackItem::Array(a));\n                    true\n                } else {\n                    false\n                }\n            }\n            _ =\u003e false,\n        }\n    }\n\n    fn op_clearitems(\u0026mut self) -\u003e bool {\n        match self.pop() {\n            Some(StackItem::Array(_)) =\u003e {\n                self.push(StackItem::Array(vec![]));\n                true\n            }\n            Some(StackItem::Map(_)) =\u003e {\n                self.push(StackItem::Map(vec![]));\n                true\n            }\n            _ =\u003e false,\n        }\n    }\n\n    fn op_isnull(\u0026mut self) -\u003e bool {\n        let is_null = matches!(self.pop(), Some(StackItem::Null) | None);\n        self.push(StackItem::Boolean(is_null));\n        true\n    }\n\n    fn op_istype(\u0026mut self) -\u003e bool {\n        let type_id = self.read_byte().unwrap_or(0);\n        let item = self.pop();\n        let matches = matches!(\n            (item, type_id),\n            (Some(StackItem::Boolean(_)), 0x20)\n                | (Some(StackItem::Integer(_)), 0x21)\n                | (Some(StackItem::ByteString(_)), 0x28)\n                | (Some(StackItem::Array(_)), 0x40)\n                | (Some(StackItem::Struct(_)), 0x41)\n                | (Some(StackItem::Map(_)), 0x48)\n        );\n        self.push(StackItem::Boolean(matches));\n        true\n    }\n}\n\n/// SHA256 hash for zkVM (deterministic)\nfn sha256_hash(data: \u0026[u8]) -\u003e [u8; 32] {\n    // Simple SHA256-like hash for zkVM guest\n    let mut h: [u32; 8] = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,\n        0x5be0cd19,\n    ];\n\n    for chunk in data.chunks(64) {\n        for (i, \u0026byte) in chunk.iter().enumerate() {\n            h[i % 8] = h[i % 8].wrapping_add(byte as u32);\n            h[(i + 1) % 8] = h[(i + 1) % 8].rotate_left(5) ^ h[i % 8];\n        }\n    }\n\n    let mut result = [0u8; 32];\n    for (i, \u0026word) in h.iter().enumerate() {\n        result[i * 4..(i + 1) * 4].copy_from_slice(\u0026word.to_be_bytes());\n    }\n    result\n}\n\n/// Main entry point for SP1 guest program\npub fn main() {\n    // Read input from host\n    let input: GuestInput = sp1_zkvm::io::read();\n\n    // Compute input hashes\n    let script_hash = sha256_hash(\u0026input.script);\n    let input_bytes = bincode::serialize(\u0026input.arguments).unwrap_or_default();\n    let input_hash = sha256_hash(\u0026input_bytes);\n\n    // Execute the Neo VM script\n    let mut vm = NeoVM::new(input.gas_limit);\n    vm.load_script(input.script);\n\n    // Push arguments to stack\n    for arg in input.arguments {\n        vm.push(arg);\n    }\n\n    // Execute\n    vm.execute();\n\n    // Compute output hash\n    let result_bytes = bincode::serialize(\u0026vm.eval_stack).unwrap_or_default();\n    let output_hash = sha256_hash(\u0026result_bytes);\n\n    // Create public values\n    let public_values = PublicValues {\n        script_hash,\n        input_hash,\n        output_hash,\n        gas_consumed: vm.gas_consumed,\n        execution_success: vm.state == VMState::Halt,\n    };\n\n    // Commit public values to the proof\n    sp1_zkvm::io::commit(\u0026public_values);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-prover","build.rs"],"content":"//! Build script to embed SP1 guest program ELF\n//!\n//! This build script compiles the neo-zkvm-program and embeds the resulting\n//! ELF binary into the prover crate for use with SP1 zkVM.\n//!\n//! To build the guest program:\n//!   cargo build --package neo-zkvm-program --release\n//!\n//! The ELF will be copied to the prover's out directory and embedded.\n\nuse std::env;\nuse std::path::PathBuf;\nuse std::process::Command;\n\nfn main() {\n    // Get the package directory\n    let package_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n\n    // Path to the guest program\n    let guest_program = package_dir.parent().unwrap().join(\"neo-zkvm-program\");\n\n    let out_dir = env::var(\"OUT_DIR\").unwrap_or_else(|_| \"target/out\".to_string());\n    let out_dir = PathBuf::from(out_dir);\n\n    // Create output directory\n    std::fs::create_dir_all(\u0026out_dir).unwrap_or_default();\n\n    let elf_path = out_dir.join(\"neo-zkvm-program.bin\");\n\n    // Try to build the guest program\n    println!(\"Checking for neo-zkvm-program build...\");\n\n    let status = Command::new(\"cargo\")\n        .args(vec![\n            \"build\",\n            \"--package\",\n            \"neo-zkvm-program\",\n            \"--release\",\n            \"--manifest-path\",\n            guest_program\n                .join(\"Cargo.toml\")\n                .to_str()\n                .unwrap_or(\"Cargo.toml\"),\n        ])\n        .current_dir(\u0026package_dir)\n        .status();\n\n    match status {\n        Ok(s) if s.success() =\u003e {\n            // Copy the ELF binary\n            let release_elf = guest_program\n                .join(\"target\")\n                .join(\"release\")\n                .join(\"neo-zkvm-program\");\n\n            // Try different possible binary names\n            let source_elf = if release_elf.exists() {\n                release_elf\n            } else {\n                guest_program\n                    .join(\"target\")\n                    .join(\"release\")\n                    .join(\"neo_zkvm_program\")\n            };\n\n            if source_elf.exists() {\n                if let Err(e) = std::fs::copy(\u0026source_elf, \u0026elf_path) {\n                    println!(\"Warning: Could not copy ELF: {}\", e);\n                } else {\n                    println!(\"ELF binary embedded at: {:?}\", elf_path);\n                }\n            } else {\n                println!(\n                    \"Warning: Guest program binary not found at {:?}\",\n                    source_elf\n                );\n                println!(\"SP1 proof generation will use mock proofs only.\");\n            }\n        }\n        _ =\u003e {\n            println!(\"Warning: Failed to build neo-zkvm-program\");\n            println!(\"SP1 proof generation will use mock proofs only.\");\n        }\n    }\n\n    // Tell cargo to rerun if the guest program source changes\n    println!(\"cargo:rerun-if-changed={}\", guest_program.display());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-prover","src","lib.rs"],"content":"//! Neo zkVM Prover with SP1 Integration\n//!\n//! Production-grade prover using SP1 zkVM for generating zero-knowledge proofs.\n//!\n//! ## Quick Start\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig, ProveMode};\n//! use neo_vm_guest::ProofInput;\n//! use neo_vm_core::StackItem;\n//!\n//! // Create a prover with default config\n//! let prover = NeoProver::new(ProverConfig::default());\n//!\n//! // Define a script: 2 + 3 = 5\n//! let input = ProofInput {\n//!     script: vec![0x12, 0x13, 0x9E, 0x40],\n//!     arguments: vec![],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! // Generate proof\n//! let proof = prover.prove(input);\n//!\n//! // Check execution was successful\n//! assert_eq!(proof.output.state, 0);\n//! assert_eq!(proof.output.result, Some(StackItem::Integer(5)));\n//! ```\n//!\n//! ## Proving with Arguments\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig};\n//! use neo_vm_guest::ProofInput;\n//! use neo_vm_core::StackItem;\n//!\n//! let prover = NeoProver::new(ProverConfig::default());\n//!\n//! // Script that adds two arguments: a + b\n//! let script = vec![\n//!     0x57, 0x00, 0x02, // INITSLOT 0 locals, 2 args\n//!     0x74,             // LDARG0\n//!     0x75,             // LDARG1\n//!     0x9E,             // ADD\n//!     0x40,             // RET\n//! ];\n//!\n//! let input = ProofInput {\n//!     script,\n//!     arguments: vec![StackItem::Integer(10), StackItem::Integer(20)],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! let proof = prover.prove(input);\n//!\n//! assert_eq!(proof.output.state, 0);\n//! assert_eq!(proof.output.result, Some(StackItem::Integer(30)));\n//! ```\n//!\n//! ## Mock vs Real Proofs\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig, ProveMode};\n//! use neo_vm_guest::ProofInput;\n//!\n//! // Mock proof (fast, for testing)\n//! let mock_prover = NeoProver::new(ProverConfig {\n//!     max_cycles: 1_000_000,\n//!     prove_mode: ProveMode::Mock,\n//! });\n//!\n//! let input = ProofInput {\n//!     script: vec![0x12, 0x13, 0x9E, 0x40],\n//!     arguments: vec![],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! let mock_proof = mock_prover.prove(input);\n//! assert!(mock_proof.proof_bytes.is_empty()); // Mock proof has no proof bytes\n//!\n//! // Note: Real SP1 proofs require the sp1 feature and ELF binary\n//! // Real proofs are generated with ProveMode::Sp1 or ProveMode::Sp1Plonk\n//! ```\n\nuse neo_vm_guest::{execute, ProofInput, ProofOutput};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\n/// ELF binary for the SP1 guest program\n/// This is embedded at compile time by build.rs after building neo-zkvm-program\n/// Falls back to empty if not built (mock mode will be used)\n#[cfg(feature = \"sp1\")]\npub const NEO_ZKVM_ELF: \u0026[u8] = \u0026[];\n\n/// ELF placeholder when SP1 feature is disabled\n#[cfg(not(feature = \"sp1\"))]\npub const NEO_ZKVM_ELF: \u0026[u8] = \u0026[];\n\n/// Check if the SP1 guest program ELF has been built\npub fn is_elf_available() -\u003e bool {\n    !NEO_ZKVM_ELF.is_empty()\n}\n\n/// Proof generated by the prover\n#[derive(Serialize, Deserialize)]\npub struct NeoProof {\n    pub output: ProofOutput,\n    pub proof_bytes: Vec\u003cu8\u003e,\n    pub public_inputs: PublicInputs,\n    pub vkey_hash: [u8; 32],\n}\n\n/// Public inputs for verification\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct PublicInputs {\n    pub script_hash: [u8; 32],\n    pub input_hash: [u8; 32],\n    pub output_hash: [u8; 32],\n    pub gas_consumed: u64,\n    pub execution_success: bool,\n}\n\n/// Prover configuration\n#[derive(Clone, Debug)]\npub struct ProverConfig {\n    /// Maximum number of cycles for SP1 execution\n    pub max_cycles: u64,\n    /// Mode for proof generation\n    pub prove_mode: ProveMode,\n}\n\n/// Guest input for SP1 program\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct GuestInput {\n    /// The script bytecode to execute\n    pub script: Vec\u003cu8\u003e,\n    /// Arguments to pass to the script\n    pub arguments: Vec\u003cGuestStackItem\u003e,\n    /// Gas limit for execution\n    pub gas_limit: u64,\n}\n\n/// Proving mode\n#[derive(Clone, Copy, Debug)]\npub enum ProveMode {\n    /// Execute only, no proof\n    Execute,\n    /// Generate mock proof (for testing)\n    Mock,\n    /// Generate real SP1 proof (compressed)\n    Sp1,\n    /// Generate SP1 PLONK proof (for on-chain verification)\n    Sp1Plonk,\n}\n\nimpl Default for ProverConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_cycles: 1_000_000,\n            prove_mode: ProveMode::Mock,\n        }\n    }\n}\n\n/// Simplified stack item for guest\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum GuestStackItem {\n    Null,\n    Boolean(bool),\n    Integer(i128),\n    ByteString(Vec\u003cu8\u003e),\n}\n\n/// Neo zkVM Prover\npub struct NeoProver {\n    config: ProverConfig,\n}\n\nimpl NeoProver {\n    pub fn new(config: ProverConfig) -\u003e Self {\n        Self { config }\n    }\n\n    /// Generate proof for script execution\n    pub fn prove(\u0026self, input: ProofInput) -\u003e NeoProof {\n        let script_hash = Self::hash_data(\u0026input.script);\n        let input_bytes = bincode::serialize(\u0026input.arguments).unwrap_or_default();\n        let input_hash = Self::hash_data(\u0026input_bytes);\n\n        let output = execute(input.clone());\n        let output_hash = Self::hash_data(\u0026output.gas_consumed.to_le_bytes());\n\n        let public_inputs = PublicInputs {\n            script_hash,\n            input_hash,\n            output_hash,\n            gas_consumed: output.gas_consumed,\n            execution_success: output.state == 0,\n        };\n\n        let (proof_bytes, vkey_hash) = match self.config.prove_mode {\n            ProveMode::Execute =\u003e (vec![], [0u8; 32]),\n            ProveMode::Mock =\u003e (self.generate_mock_proof(\u0026public_inputs), [0u8; 32]),\n            ProveMode::Sp1 =\u003e self.generate_sp1_proof(\u0026input),\n            ProveMode::Sp1Plonk =\u003e self.generate_sp1_plonk_proof(\u0026input),\n        };\n\n        NeoProof {\n            output,\n            proof_bytes,\n            public_inputs,\n            vkey_hash,\n        }\n    }\n\n    fn hash_data(data: \u0026[u8]) -\u003e [u8; 32] {\n        let mut hasher = Sha256::new();\n        hasher.update(data);\n        hasher.finalize().into()\n    }\n\n    fn generate_mock_proof(\u0026self, inputs: \u0026PublicInputs) -\u003e Vec\u003cu8\u003e {\n        let mock = MockProof {\n            public_inputs: inputs.clone(),\n            commitment: Self::compute_commitment(inputs),\n            signature: vec![0u8; 64],\n        };\n        bincode::serialize(\u0026mock).unwrap_or_default()\n    }\n\n    fn generate_sp1_proof(\u0026self, input: \u0026ProofInput) -\u003e (Vec\u003cu8\u003e, [u8; 32]) {\n        use sp1_sdk::{ProverClient, SP1Stdin};\n\n        // Initialize SP1 prover client\n        let client = ProverClient::from_env();\n\n        // Prepare stdin with input data\n        let mut stdin = SP1Stdin::new();\n        let guest_input = GuestInput {\n            script: input.script.clone(),\n            arguments: input.arguments.iter().map(stack_item_to_guest).collect(),\n            gas_limit: input.gas_limit,\n        };\n        stdin.write(\u0026guest_input);\n\n        // Setup and prove\n        let (pk, vk) = client.setup(NEO_ZKVM_ELF);\n        let proof = client\n            .prove(\u0026pk, \u0026stdin)\n            .compressed()\n            .run()\n            .expect(\"SP1 proving failed\");\n\n        // Verify the proof\n        client.verify(\u0026proof, \u0026vk).expect(\"SP1 verification failed\");\n\n        // Serialize proof using SP1's native serialization\n        let proof_bytes = proof.bytes().to_vec();\n        let vkey_hash = Self::hash_data(\u0026bincode::serialize(\u0026vk).unwrap_or_default());\n\n        (proof_bytes, vkey_hash)\n    }\n\n    fn generate_sp1_plonk_proof(\u0026self, input: \u0026ProofInput) -\u003e (Vec\u003cu8\u003e, [u8; 32]) {\n        use sp1_sdk::{ProverClient, SP1Stdin};\n\n        let client = ProverClient::from_env();\n\n        let mut stdin = SP1Stdin::new();\n        let guest_input = GuestInput {\n            script: input.script.clone(),\n            arguments: input.arguments.iter().map(stack_item_to_guest).collect(),\n            gas_limit: input.gas_limit,\n        };\n        stdin.write(\u0026guest_input);\n\n        let (pk, vk) = client.setup(NEO_ZKVM_ELF);\n\n        // Generate PLONK proof for on-chain verification\n        let proof = client\n            .prove(\u0026pk, \u0026stdin)\n            .plonk()\n            .run()\n            .expect(\"SP1 PLONK proving failed\");\n\n        client\n            .verify(\u0026proof, \u0026vk)\n            .expect(\"SP1 PLONK verification failed\");\n\n        // Serialize proof using SP1's native serialization\n        let proof_bytes = proof.bytes().to_vec();\n        let vkey_hash = Self::hash_data(\u0026bincode::serialize(\u0026vk).unwrap_or_default());\n\n        (proof_bytes, vkey_hash)\n    }\n\n    fn compute_commitment(inputs: \u0026PublicInputs) -\u003e [u8; 32] {\n        let mut hasher = Sha256::new();\n        hasher.update(inputs.script_hash);\n        hasher.update(inputs.input_hash);\n        hasher.update(inputs.output_hash);\n        hasher.update(inputs.gas_consumed.to_le_bytes());\n        hasher.update([inputs.execution_success as u8]);\n        hasher.finalize().into()\n    }\n}\n\n/// Convert StackItem to GuestStackItem\nfn stack_item_to_guest(item: \u0026neo_vm_core::StackItem) -\u003e GuestStackItem {\n    match item {\n        neo_vm_core::StackItem::Null =\u003e GuestStackItem::Null,\n        neo_vm_core::StackItem::Boolean(b) =\u003e GuestStackItem::Boolean(*b),\n        neo_vm_core::StackItem::Integer(i) =\u003e GuestStackItem::Integer(*i),\n        neo_vm_core::StackItem::ByteString(b) =\u003e GuestStackItem::ByteString(b.clone()),\n        _ =\u003e GuestStackItem::Null,\n    }\n}\n\n/// Mock proof structure\n#[derive(Serialize, Deserialize)]\npub struct MockProof {\n    pub public_inputs: PublicInputs,\n    pub commitment: [u8; 32],\n    pub signature: Vec\u003cu8\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","crates","neo-zkvm-verifier","src","lib.rs"],"content":"//! Neo zkVM Verifier with SP1 Integration\n//!\n//! Production-grade verifier for SP1 zero-knowledge proofs.\n//!\n//! ## Quick Start\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig};\n//! use neo_zkvm_verifier::{verify, verify_detailed, VerificationResult};\n//! use neo_vm_guest::ProofInput;\n//!\n//! // Create prover and generate proof\n//! let prover = NeoProver::new(ProverConfig::default());\n//! let input = ProofInput {\n//!     script: vec![0x12, 0x13, 0x9E, 0x40], // 2 + 3\n//!     arguments: vec![],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! let proof = prover.prove(input);\n//!\n//! // Simple verification\n//! let is_valid = verify(\u0026proof);\n//! assert!(is_valid);\n//! ```\n//!\n//! ## Detailed Verification\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig};\n//! use neo_zkvm_verifier::{verify_detailed, VerificationResult};\n//! use neo_vm_guest::ProofInput;\n//!\n//! let prover = NeoProver::new(ProverConfig::default());\n//! let input = ProofInput {\n//!     script: vec![0x12, 0x13, 0x9E, 0x40],\n//!     arguments: vec![],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! let proof = prover.prove(input);\n//!\n//! // Detailed verification with error info\n//! let result = verify_detailed(\u0026proof);\n//!\n//! match result {\n//!     VerificationResult { valid: true, error: None } =\u003e {\n//!         println!(\"Proof is valid!\");\n//!     }\n//!     VerificationResult { valid: false, error: Some(e) } =\u003e {\n//!         println!(\"Verification failed: {}\", e);\n//!     }\n//!     _ =\u003e {}\n//! }\n//! ```\n//!\n//! ## Verification with Public Inputs\n//!\n//! ```rust,ignore\n//! use neo_zkvm_prover::{NeoProver, ProverConfig};\n//! use neo_zkvm_verifier::verify;\n//! use neo_vm_guest::ProofInput;\n//! use neo_vm_core::StackItem;\n//!\n//! let prover = NeoProver::new(ProverConfig::default());\n//!\n//! // Script with arguments: a + b\n//! let script = vec![\n//!     0x57, 0x00, 0x02, // INITSLOT 0 locals, 2 args\n//!     0x74,             // LDARG0\n//!     0x75,             // LDARG1\n//!     0x9E,             // ADD\n//!     0x40,             // RET\n//! ];\n//!\n//! let input = ProofInput {\n//!     script,\n//!     arguments: vec![StackItem::Integer(100), StackItem::Integer(200)],\n//!     gas_limit: 1_000_000,\n//! };\n//!\n//! let proof = prover.prove(input);\n//!\n//! // Access public inputs for on-chain verification\n//! assert!(proof.public_inputs.execution_success);\n//! assert!(proof.public_inputs.gas_consumed \u003e 0);\n//!\n//! // Verify the proof\n//! assert!(verify(\u0026proof));\n//! ```\n\nuse bincode::Options;\nuse neo_zkvm_prover::{MockProof, NeoProof, PublicInputs, NEO_ZKVM_ELF};\nuse sha2::{Digest, Sha256};\nuse sp1_sdk::{ProverClient, SP1ProofWithPublicValues};\n\nconst BINCODE_LIMIT: u64 = 10 * 1024 * 1024; // 10MB limit\n\nfn bincode_options() -\u003e impl Options {\n    bincode::DefaultOptions::new()\n        .with_limit(BINCODE_LIMIT)\n        .with_fixint_encoding()\n}\n\n/// Verification result\n#[derive(Debug)]\npub struct VerificationResult {\n    pub valid: bool,\n    pub error: Option\u003cString\u003e,\n}\n\n/// Proof type detected during verification\n#[derive(Debug, Clone, Copy)]\npub enum ProofType {\n    Empty,\n    Mock,\n    Sp1Compressed,\n    Sp1Plonk,\n    Unknown,\n}\n\n/// Verify a Neo zkVM proof (simple interface)\npub fn verify(proof: \u0026NeoProof) -\u003e bool {\n    verify_detailed(proof).valid\n}\n\n/// Verify with detailed result\npub fn verify_detailed(proof: \u0026NeoProof) -\u003e VerificationResult {\n    // Check execution state\n    if proof.output.state != 0 {\n        return VerificationResult {\n            valid: false,\n            error: Some(\"Execution faulted\".to_string()),\n        };\n    }\n\n    // Empty proof is valid for execute-only mode\n    if proof.proof_bytes.is_empty() {\n        return VerificationResult {\n            valid: true,\n            error: None,\n        };\n    }\n\n    // Detect and verify proof type\n    let proof_type = detect_proof_type(\u0026proof.proof_bytes);\n\n    match proof_type {\n        ProofType::Mock =\u003e verify_mock_proof(\u0026proof.proof_bytes, \u0026proof.public_inputs),\n        ProofType::Sp1Compressed | ProofType::Sp1Plonk =\u003e {\n            verify_sp1_proof(\u0026proof.proof_bytes, \u0026proof.public_inputs, \u0026proof.vkey_hash)\n        }\n        ProofType::Empty =\u003e VerificationResult {\n            valid: true,\n            error: None,\n        },\n        ProofType::Unknown =\u003e VerificationResult {\n            valid: false,\n            error: Some(\"Unknown proof format\".to_string()),\n        },\n    }\n}\n\n/// Detect the type of proof from bytes\nfn detect_proof_type(proof_bytes: \u0026[u8]) -\u003e ProofType {\n    if proof_bytes.is_empty() {\n        return ProofType::Empty;\n    }\n\n    // Try to deserialize as MockProof\n    if bincode_options()\n        .deserialize::\u003cMockProof\u003e(proof_bytes)\n        .is_ok()\n    {\n        return ProofType::Mock;\n    }\n\n    // Try to deserialize as SP1 proof\n    if bincode_options()\n        .deserialize::\u003cSP1ProofWithPublicValues\u003e(proof_bytes)\n        .is_ok()\n    {\n        return ProofType::Sp1Compressed;\n    }\n\n    ProofType::Unknown\n}\n\n/// Verify mock proof (for testing)\nfn verify_mock_proof(proof_bytes: \u0026[u8], public_inputs: \u0026PublicInputs) -\u003e VerificationResult {\n    let mock: MockProof = match bincode_options().deserialize(proof_bytes) {\n        Ok(m) =\u003e m,\n        Err(_) =\u003e {\n            return VerificationResult {\n                valid: false,\n                error: Some(\"Failed to deserialize mock proof\".to_string()),\n            }\n        }\n    };\n\n    // Verify commitment\n    let expected = compute_commitment(public_inputs);\n    if mock.commitment != expected {\n        return VerificationResult {\n            valid: false,\n            error: Some(\"Commitment mismatch\".to_string()),\n        };\n    }\n\n    // Verify public inputs match\n    if mock.public_inputs.script_hash != public_inputs.script_hash {\n        return VerificationResult {\n            valid: false,\n            error: Some(\"Script hash mismatch\".to_string()),\n        };\n    }\n\n    VerificationResult {\n        valid: true,\n        error: None,\n    }\n}\n\n/// Verify SP1 proof using the SDK\nfn verify_sp1_proof(\n    proof_bytes: \u0026[u8],\n    _public_inputs: \u0026PublicInputs,\n    _vkey_hash: \u0026[u8; 32],\n) -\u003e VerificationResult {\n    let sp1_proof: SP1ProofWithPublicValues = match bincode_options().deserialize(proof_bytes) {\n        Ok(p) =\u003e p,\n        Err(_) =\u003e {\n            return VerificationResult {\n                valid: false,\n                error: Some(\"Failed to deserialize SP1 proof\".to_string()),\n            }\n        }\n    };\n\n    // Create client and get vkey\n    let client = ProverClient::from_env();\n    let (_, vk) = client.setup(NEO_ZKVM_ELF);\n\n    // Verify the proof\n    match client.verify(\u0026sp1_proof, \u0026vk) {\n        Ok(_) =\u003e VerificationResult {\n            valid: true,\n            error: None,\n        },\n        Err(e) =\u003e VerificationResult {\n            valid: false,\n            error: Some(format!(\"SP1 verification failed: {}\", e)),\n        },\n    }\n}\n\n/// Compute commitment hash from public inputs\nfn compute_commitment(inputs: \u0026PublicInputs) -\u003e [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(inputs.script_hash);\n    hasher.update(inputs.input_hash);\n    hasher.update(inputs.output_hash);\n    hasher.update(inputs.gas_consumed.to_le_bytes());\n    hasher.update([inputs.execution_success as u8]);\n    hasher.finalize().into()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","examples","basic.rs"],"content":"//! Basic VM usage example\nuse neo_vm_core::{NeoVM, VMState};\n\nfn main() {\n    let mut vm = NeoVM::new(1_000_000);\n    \n    // 2 + 3 = 5\n    vm.load_script(vec![0x12, 0x13, 0x9E, 0x40]);\n    \n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        vm.execute_next().unwrap();\n    }\n    \n    println!(\"Result: {:?}\", vm.eval_stack.pop());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","examples","native_contracts.rs"],"content":"//! Native Contracts Example - StdLib and CryptoLib\n//!\n//! This example demonstrates how to use Neo's built-in native contracts\n//! for common operations like serialization, encoding, and cryptography.\n//!\n//! # Native Contracts Covered\n//! - StdLib: Utility functions (serialize, base64, itoa/atoi)\n//! - CryptoLib: Cryptographic functions (SHA256, RIPEMD160, ECDSA)\n//!\n//! # Use Cases\n//! - Data serialization for storage\n//! - Base64 encoding for external APIs\n//! - Cryptographic hashing for verification\n//! - Number/string conversions\n\nuse neo_vm_core::{CryptoLib, NativeContract, NativeRegistry, StackItem, StdLib};\n\nfn main() {\n    println!(\"=== Neo zkVM Native Contracts Example ===\\n\");\n\n    // =========================================================================\n    // Part 1: StdLib - Serialization\n    // =========================================================================\n    println!(\"--- Part 1: StdLib Serialization ---\\n\");\n\n    let stdlib = StdLib::new();\n\n    // Serialize a complex value\n    let data = StackItem::Integer(12345);\n    let serialized = stdlib.invoke(\"serialize\", vec![data.clone()]).unwrap();\n    println!(\"Original: {:?}\", data);\n    if let StackItem::ByteString(bytes) = \u0026serialized {\n        println!(\"Serialized: {} bytes\", bytes.len());\n    }\n\n    // Deserialize back\n    let deserialized = stdlib.invoke(\"deserialize\", vec![serialized]).unwrap();\n    println!(\"Deserialized: {:?}\", deserialized);\n\n    // =========================================================================\n    // Part 2: StdLib - Base64 Encoding\n    // =========================================================================\n    println!(\"\\n--- Part 2: Base64 Encoding ---\\n\");\n\n    let message = StackItem::ByteString(b\"Hello, Neo zkVM!\".to_vec());\n    let encoded = stdlib.invoke(\"base64Encode\", vec![message.clone()]).unwrap();\n    \n    if let StackItem::ByteString(bytes) = \u0026encoded {\n        println!(\"Original: Hello, Neo zkVM!\");\n        println!(\"Base64:   {}\", String::from_utf8_lossy(bytes));\n    }\n\n    // Decode back\n    let decoded = stdlib.invoke(\"base64Decode\", vec![encoded]).unwrap();\n    if let StackItem::ByteString(bytes) = decoded {\n        println!(\"Decoded:  {}\", String::from_utf8_lossy(\u0026bytes));\n    }\n\n    // =========================================================================\n    // Part 3: StdLib - Number Conversions\n    // =========================================================================\n    println!(\"\\n--- Part 3: Number Conversions (itoa/atoi) ---\\n\");\n\n    // Integer to string (various bases)\n    let num = StackItem::Integer(255);\n    \n    // Decimal\n    let dec = stdlib.invoke(\"itoa\", vec![num.clone()]).unwrap();\n    if let StackItem::ByteString(b) = \u0026dec {\n        println!(\"255 in decimal: {}\", String::from_utf8_lossy(b));\n    }\n    \n    // Hexadecimal\n    let hex = stdlib.invoke(\"itoa\", vec![num.clone(), StackItem::Integer(16)]).unwrap();\n    if let StackItem::ByteString(b) = \u0026hex {\n        println!(\"255 in hex:     {}\", String::from_utf8_lossy(b));\n    }\n    \n    // Binary\n    let bin = stdlib.invoke(\"itoa\", vec![num.clone(), StackItem::Integer(2)]).unwrap();\n    if let StackItem::ByteString(b) = \u0026bin {\n        println!(\"255 in binary:  {}\", String::from_utf8_lossy(b));\n    }\n\n    // String to integer\n    let str_num = StackItem::ByteString(b\"42\".to_vec());\n    let parsed = stdlib.invoke(\"atoi\", vec![str_num]).unwrap();\n    println!(\"Parsed '42':    {:?}\", parsed);\n\n    // =========================================================================\n    // Part 4: CryptoLib - Hashing\n    // =========================================================================\n    println!(\"\\n--- Part 4: CryptoLib Hashing ---\\n\");\n\n    let cryptolib = CryptoLib::new();\n\n    let data_to_hash = StackItem::ByteString(b\"Neo zkVM\".to_vec());\n    \n    // SHA256 hash\n    let sha256_result = cryptolib.invoke(\"sha256\", vec![data_to_hash.clone()]).unwrap();\n    if let StackItem::ByteString(hash) = \u0026sha256_result {\n        println!(\"SHA256('Neo zkVM'):\");\n        println!(\"  {}\", hex_encode(hash));\n    }\n\n    // RIPEMD160 hash\n    let ripemd_result = cryptolib.invoke(\"ripemd160\", vec![data_to_hash]).unwrap();\n    if let StackItem::ByteString(hash) = \u0026ripemd_result {\n        println!(\"RIPEMD160('Neo zkVM'):\");\n        println!(\"  {}\", hex_encode(hash));\n    }\n\n    // =========================================================================\n    // Part 5: NativeRegistry - Unified Access\n    // =========================================================================\n    println!(\"\\n--- Part 5: NativeRegistry ---\\n\");\n\n    let registry = NativeRegistry::new();\n\n    // Get contract hashes\n    let stdlib_hash = stdlib.hash();\n    let crypto_hash = cryptolib.hash();\n\n    println!(\"StdLib hash:    0x{}\", hex_encode(\u0026stdlib_hash));\n    println!(\"CryptoLib hash: 0x{}\", hex_encode(\u0026crypto_hash));\n\n    // Invoke through registry using hash\n    let result = registry.invoke(\n        \u0026stdlib_hash,\n        \"itoa\",\n        vec![StackItem::Integer(100)]\n    ).unwrap();\n    \n    if let StackItem::ByteString(b) = result {\n        println!(\"\\nRegistry invoke StdLib.itoa(100): {}\", \n            String::from_utf8_lossy(\u0026b));\n    }\n\n    println!(\"\\n=== Native Contracts Example Complete ===\");\n}\n\n/// Helper function to encode bytes as hex string\nfn hex_encode(bytes: \u0026[u8]) -\u003e String {\n    bytes.iter().map(|b| format!(\"{:02x}\", b)).collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","examples","proof_generation.rs"],"content":"//! Complete Proof Generation and Verification Example\n//!\n//! This example demonstrates the full workflow of generating and verifying\n//! zero-knowledge proofs for Neo VM script execution.\n//!\n//! # Workflow\n//! 1. Create a Neo VM script\n//! 2. Prepare proof input with arguments\n//! 3. Generate proof using the prover\n//! 4. Verify the proof\n//!\n//! # Proof Modes\n//! - Execute: Run without proof (fastest, for testing)\n//! - Mock: Generate mock proof (for development)\n//! - SP1: Generate real ZK proof (production)\n//! - SP1Plonk: Generate PLONK proof (on-chain verification)\n\nuse neo_vm_core::StackItem;\nuse neo_vm_guest::ProofInput;\nuse neo_zkvm_prover::{NeoProver, ProveMode, ProverConfig};\nuse neo_zkvm_verifier::{verify, verify_detailed};\n\nfn main() {\n    println!(\"=== Neo zkVM Proof Generation Example ===\\n\");\n\n    // =========================================================================\n    // Part 1: Simple Arithmetic Proof\n    // =========================================================================\n    println!(\"--- Part 1: Simple Arithmetic (2 + 3 = 5) ---\\n\");\n\n    // Create a simple addition script: PUSH2, PUSH3, ADD, RET\n    // Opcodes: 0x12 = PUSH2, 0x13 = PUSH3, 0x9E = ADD, 0x40 = RET\n    let add_script = vec![0x12, 0x13, 0x9E, 0x40];\n\n    // Prepare proof input\n    let input = ProofInput {\n        script: add_script.clone(),\n        arguments: vec![], // No additional arguments needed\n        gas_limit: 100_000,\n    };\n\n    // Create prover with mock mode (for demonstration)\n    let config = ProverConfig {\n        max_cycles: 1_000_000,\n        prove_mode: ProveMode::Mock,\n    };\n    let prover = NeoProver::new(config);\n\n    // Generate proof\n    println!(\"Generating proof...\");\n    let proof = prover.prove(input);\n\n    // Display results\n    println!(\"Execution result: {:?}\", proof.output.result);\n    println!(\"Gas consumed: {}\", proof.output.gas_consumed);\n    println!(\"Proof size: {} bytes\", proof.proof_bytes.len());\n    println!(\"Script hash: 0x{}\", hex_encode(\u0026proof.public_inputs.script_hash[..8]));\n\n    // Verify the proof\n    let is_valid = verify(\u0026proof);\n    println!(\"Proof valid: {}\", is_valid);\n    assert!(is_valid, \"Proof should be valid\");\n\n    // =========================================================================\n    // Part 2: Proof with Arguments\n    // =========================================================================\n    println!(\"\\n--- Part 2: Proof with Stack Arguments ---\\n\");\n\n    // Script that multiplies two numbers from the stack\n    // DUP, MUL, RET (squares the top value)\n    let square_script = vec![0x4A, 0xA0, 0x40]; // DUP, MUL, RET\n\n    let input_with_args = ProofInput {\n        script: square_script,\n        arguments: vec![StackItem::Integer(7)], // 7 = 49\n        gas_limit: 100_000,\n    };\n\n    let proof2 = prover.prove(input_with_args);\n    println!(\"Input: 7\");\n    println!(\"Result (7): {:?}\", proof2.output.result);\n    println!(\"Verification: {}\", verify(\u0026proof2));\n\n    // =========================================================================\n    // Part 3: Detailed Verification\n    // =========================================================================\n    println!(\"\\n--- Part 3: Detailed Verification ---\\n\");\n\n    let result = verify_detailed(\u0026proof);\n    println!(\"Detailed verification result:\");\n    println!(\"  Valid: {}\", result.valid);\n    if let Some(err) = \u0026result.error {\n        println!(\"  Error: {}\", err);\n    }\n\n    // =========================================================================\n    // Part 4: Execute-Only Mode (No Proof)\n    // =========================================================================\n    println!(\"\\n--- Part 4: Execute-Only Mode ---\\n\");\n\n    let exec_config = ProverConfig {\n        max_cycles: 1_000_000,\n        prove_mode: ProveMode::Execute,\n    };\n    let exec_prover = NeoProver::new(exec_config);\n\n    let input3 = ProofInput {\n        script: vec![0x15, 0x14, 0xA0, 0x40], // PUSH5, PUSH4, MUL, RET = 20\n        arguments: vec![],\n        gas_limit: 100_000,\n    };\n\n    let exec_result = exec_prover.prove(input3);\n    println!(\"Execute-only result: {:?}\", exec_result.output.result);\n    println!(\"Proof bytes (should be empty): {} bytes\", exec_result.proof_bytes.len());\n\n    // =========================================================================\n    // Part 5: Public Inputs Analysis\n    // =========================================================================\n    println!(\"\\n--- Part 5: Public Inputs Analysis ---\\n\");\n\n    println!(\"Public inputs for verification:\");\n    println!(\"  Script hash:       0x{}\", hex_encode(\u0026proof.public_inputs.script_hash));\n    println!(\"  Input hash:        0x{}\", hex_encode(\u0026proof.public_inputs.input_hash));\n    println!(\"  Output hash:       0x{}\", hex_encode(\u0026proof.public_inputs.output_hash));\n    println!(\"  Gas consumed:      {}\", proof.public_inputs.gas_consumed);\n    println!(\"  Execution success: {}\", proof.public_inputs.execution_success);\n\n    println!(\"\\n=== Proof Generation Example Complete ===\");\n}\n\n/// Helper function to encode bytes as hex string\nfn hex_encode(bytes: \u0026[u8]) -\u003e String {\n    bytes.iter().map(|b| format!(\"{:02x}\", b)).collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","examples","storage_example.rs"],"content":"//! Storage Operations and Merkle Proof Example\n//!\n//! This example demonstrates how to use Neo zkVM's storage system with\n//! Merkle proof support for verifiable state transitions.\n//!\n//! # Features Demonstrated\n//! - Creating and using storage contexts\n//! - Basic CRUD operations (Create, Read, Update, Delete)\n//! - Tracked storage with change logging\n//! - Merkle root computation for state verification\n//! - Storage proofs for ZK verification\n//!\n//! # Use Cases\n//! - Smart contract state management\n//! - Verifiable key-value storage\n//! - State transition proofs\n\nuse neo_vm_core::{\n    MemoryStorage, StorageBackend, StorageContext, TrackedStorage,\n};\n\nfn main() {\n    println!(\"=== Neo zkVM Storage Example ===\\n\");\n\n    // =========================================================================\n    // Part 1: Basic Storage Operations\n    // =========================================================================\n    println!(\"--- Part 1: Basic Storage Operations ---\\n\");\n\n    // Create a storage context for a contract\n    // The script_hash identifies which contract owns this storage\n    let context = StorageContext {\n        script_hash: [0x01; 20], // Example contract hash\n        read_only: false,\n    };\n\n    // Create in-memory storage backend\n    let mut storage = MemoryStorage::new();\n\n    // Store some key-value pairs\n    storage.put(\u0026context, b\"name\", b\"Neo zkVM\");\n    storage.put(\u0026context, b\"version\", b\"1.0.0\");\n    storage.put(\u0026context, b\"counter\", \u002642u64.to_le_bytes());\n\n    println!(\"Stored values:\");\n    println!(\"  name    = {:?}\", String::from_utf8_lossy(\n        \u0026storage.get(\u0026context, b\"name\").unwrap()\n    ));\n    println!(\"  version = {:?}\", String::from_utf8_lossy(\n        \u0026storage.get(\u0026context, b\"version\").unwrap()\n    ));\n\n    // Read counter value\n    let counter_bytes = storage.get(\u0026context, b\"counter\").unwrap();\n    let counter = u64::from_le_bytes(counter_bytes.try_into().unwrap());\n    println!(\"  counter = {}\", counter);\n\n    // =========================================================================\n    // Part 2: Merkle Root Computation\n    // =========================================================================\n    println!(\"\\n--- Part 2: Merkle Root Computation ---\\n\");\n\n    // Compute Merkle root of current storage state\n    let root1 = storage.merkle_root();\n    println!(\"Merkle root (initial): 0x{}\", hex_encode(\u0026root1));\n\n    // Modify storage and observe root change\n    storage.put(\u0026context, b\"counter\", \u0026100u64.to_le_bytes());\n    let root2 = storage.merkle_root();\n    println!(\"Merkle root (after update): 0x{}\", hex_encode(\u0026root2));\n\n    // Roots should be different after modification\n    assert_ne!(root1, root2, \"Merkle root should change after modification\");\n    println!(\" Merkle root changed after state modification\");\n\n    // =========================================================================\n    // Part 3: Tracked Storage with Change Logging\n    // =========================================================================\n    println!(\"\\n--- Part 3: Tracked Storage ---\\n\");\n\n    // TrackedStorage records all changes for proof generation\n    let mut tracked = TrackedStorage::new();\n\n    let contract_ctx = StorageContext {\n        script_hash: [0x02; 20],\n        read_only: false,\n    };\n\n    // Perform operations - all changes are logged\n    tracked.put(\u0026contract_ctx, b\"balance:alice\", \u00261000u64.to_le_bytes());\n    tracked.put(\u0026contract_ctx, b\"balance:bob\", \u0026500u64.to_le_bytes());\n\n    // Simulate a transfer: Alice -\u003e Bob (200 tokens)\n    let alice_balance = 1000u64 - 200;\n    let bob_balance = 500u64 + 200;\n    tracked.put(\u0026contract_ctx, b\"balance:alice\", \u0026alice_balance.to_le_bytes());\n    tracked.put(\u0026contract_ctx, b\"balance:bob\", \u0026bob_balance.to_le_bytes());\n\n    // Review all changes\n    println!(\"Storage changes recorded:\");\n    for (i, change) in tracked.changes().iter().enumerate() {\n        println!(\"  Change #{}: key={:?}\", i + 1, \n            String::from_utf8_lossy(\u0026change.key));\n        if let Some(old) = \u0026change.old_value {\n            println!(\"    old: {} bytes\", old.len());\n        }\n        if let Some(new) = \u0026change.new_value {\n            println!(\"    new: {} bytes\", new.len());\n        }\n    }\n\n    // Get final Merkle root\n    let final_root = tracked.merkle_root();\n    println!(\"\\nFinal Merkle root: 0x{}\", hex_encode(\u0026final_root));\n\n    // =========================================================================\n    // Part 4: Prefix Search\n    // =========================================================================\n    println!(\"\\n--- Part 4: Prefix Search ---\\n\");\n\n    // Find all balances using prefix search\n    let balances = tracked.find(\u0026contract_ctx, b\"balance:\");\n    println!(\"All balances:\");\n    for (key, value) in balances {\n        let name = String::from_utf8_lossy(\u0026key);\n        let amount = u64::from_le_bytes(value.try_into().unwrap());\n        println!(\"  {} = {} tokens\", name, amount);\n    }\n\n    // =========================================================================\n    // Part 5: Read-Only Context\n    // =========================================================================\n    println!(\"\\n--- Part 5: Read-Only Context ---\\n\");\n\n    let readonly_ctx = StorageContext {\n        script_hash: [0x02; 20],\n        read_only: true, // Cannot modify storage\n    };\n\n    // Attempt to modify (will be silently ignored)\n    let before = tracked.get(\u0026readonly_ctx, b\"balance:alice\");\n    tracked.put(\u0026readonly_ctx, b\"balance:alice\", \u00260u64.to_le_bytes());\n    let after = tracked.get(\u0026readonly_ctx, b\"balance:alice\");\n\n    assert_eq!(before, after, \"Read-only context should prevent writes\");\n    println!(\" Read-only context correctly prevents modifications\");\n\n    println!(\"\\n=== Storage Example Complete ===\");\n}\n\n/// Helper function to encode bytes as hex string\nfn hex_encode(bytes: \u0026[u8]) -\u003e String {\n    bytes.iter().map(|b| format!(\"{:02x}\", b)).collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","fuzz","fuzz_targets","fuzz_script_parser.rs"],"content":"//! Fuzz target for script parsing\n//!\n//! Tests script parsing with arbitrary input.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse arbitrary::Arbitrary;\nuse neo_vm_core::{NeoVM, VMState, StackItem};\n\n#[derive(Arbitrary, Debug)]\nstruct FuzzInput {\n    script: Vec\u003cu8\u003e,\n    gas_limit: u32,\n    initial_stack: Vec\u003ci64\u003e,\n}\n\nfuzz_target!(|input: FuzzInput| {\n    // Limit gas to prevent long runs\n    let gas = (input.gas_limit % 10_000) as u64 + 100;\n    \n    let mut vm = NeoVM::new(gas);\n    \n    // Add initial stack items\n    for val in input.initial_stack.iter().take(10) {\n        vm.eval_stack.push(StackItem::Integer(*val as i128));\n    }\n    \n    // Append RET to script\n    let mut script = input.script;\n    if script.len() \u003e 1000 {\n        script.truncate(1000);\n    }\n    script.push(0x40);\n    \n    vm.load_script(script);\n\n    let mut steps = 0;\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            break;\n        }\n        steps += 1;\n        if steps \u003e 500 {\n            break;\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","neo","git","neo-zkvm","fuzz","fuzz_targets","fuzz_vm_execution.rs"],"content":"//! Fuzz target for VM execution\n//!\n//! Tests VM execution with arbitrary bytecode.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse neo_vm_core::{NeoVM, VMState};\n\nfuzz_target!(|data: \u0026[u8]| {\n    // Skip empty input\n    if data.is_empty() {\n        return;\n    }\n\n    // Create VM with limited gas to prevent infinite loops\n    let mut vm = NeoVM::new(10_000);\n    \n    // Append RET opcode to ensure termination\n    let mut script = data.to_vec();\n    script.push(0x40); // RET\n    \n    vm.load_script(script);\n\n    // Execute until halt or fault\n    let mut steps = 0;\n    while !matches!(vm.state, VMState::Halt | VMState::Fault) {\n        if vm.execute_next().is_err() {\n            break;\n        }\n        steps += 1;\n        if steps \u003e 1000 {\n            break;\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>