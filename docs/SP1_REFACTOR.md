# SP1 Refactoring Guide for Neo zkVM

This document describes how to properly refactor Neo zkVM to be built upon SP1 (Succinct Labs' zkVM).

## Current State

The project already has partial SP1 integration:

- ✅ SP1 dependencies in Cargo.toml
- ✅ Guest program structure exists
- ✅ Prover with SP1 integration code
- ❌ ELF binary not properly built/linked
- ❌ Missing SP1 precompile usage
- ❌ No Groth16 support

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    Neo zkVM on SP1                       │
├─────────────────────────────────────────────────────────┤
│  Host Side (Standard Rust)                              │
│  ├─ neo-zkvm-prover: Uses sp1-sdk to generate proofs   │
│  ├─ neo-zkvm-verifier: Uses sp1-sdk to verify proofs   │
│  └─ neo-zkvm-cli: User interface                        │
├─────────────────────────────────────────────────────────┤
│  Guest Side (SP1 zkVM)                                  │
│  └─ neo-zkvm-program: VM execution in zkVM             │
│     • Compiled to RISC-V ELF                            │
│     • Uses sp1-zkvm for IO and precompiles             │
│     • Commits public values                             │
├─────────────────────────────────────────────────────────┤
│  Shared                                                 │
│  ├─ neo-vm-core: Core VM types and logic               │
│  └─ neo-vm-guest: Proof input/output types             │
└─────────────────────────────────────────────────────────┘
```

## Key Changes Required

### 1. Build System

Use `sp1-build` instead of manual ELF copying:

```rust
// build.rs
use sp1_build;

fn main() {
    sp1_build::build_program(
        &format!("{}/../neo-zkvm-program", env!("CARGO_MANIFEST_DIR")),
        &sp1_build::BuildArgs::default(),
    );
}
```

### 2. ELF Embedding

Use `include_bytes!` with the correct path:

```rust
// This is generated by sp1-build
pub const NEO_ZKVM_ELF: &[u8] = 
    include_bytes!("../elf/riscv32im-succinct-zkvm-elf");
```

### 3. Guest Program Optimization

Use SP1 precompiles for cryptographic operations:

```rust
#[cfg(target_os = "zkvm")]
0xF0 => {
    // SHA256 - use SP1 precompile (much faster!)
    let data = self.eval_stack.pop().ok_or("Stack underflow")?;
    let result = sp1_zkvm::precompiles::sha256::sha256(&data.to_bytes());
    self.eval_stack.push(StackItem::ByteString(result.to_vec()));
}
```

### 4. Prover Modes

Support all SP1 proof modes:

- **Compressed**: Fast verification, larger proof
- **PLONK**: Medium verification cost, smaller proof  
- **Groth16**: Slowest verification, smallest proof (best for Ethereum)

```rust
pub enum ProofMode {
    Execute,    // No proof
    Mock,       // Test proof
    Sp1,        // Compressed
    Plonk,      // PLONK
    Groth16,    // Groth16
}
```

### 5. Prover Initialization

Initialize SP1 client once and reuse:

```rust
pub struct NeoProver {
    client: ProverClient,
    pk: SP1ProvingKey,
    vk: SP1VerifyingKey,
}

impl NeoProver {
    pub fn new(config: ProverConfig) -> Self {
        let client = ProverClient::from_env();
        let (pk, vk) = client.setup(NEO_ZKVM_ELF);
        Self { client, pk, vk, config }
    }
}
```

## Build Instructions

### Prerequisites

```bash
# Install SP1 toolchain
curl -L https://sp1.succinct.xyz | bash
sp1up
```

### Building

```bash
# Build the entire project
cargo build --release

# The build script will:
# 1. Compile neo-zkvm-program to RISC-V ELF
# 2. Embed the ELF in neo-zkvm-prover
# 3. Make it available via include_bytes!
```

### Running Tests

```bash
# Mock proofs (fast, no SP1 setup needed)
cargo test --package neo-zkvm-prover

# Real SP1 proofs (requires SP1 prover network or local setup)
SP1_PROVER=network cargo test --package neo-zkvm-prover
```

## Usage Examples

### Basic Proof Generation

```rust
use neo_zkvm_prover::{NeoProver, ProverConfig, ProofMode};
use neo_vm_guest::ProofInput;

// Create prover
let prover = NeoProver::new(ProverConfig {
    proof_mode: ProofMode::Sp1,
    ..Default::default()
});

// Prepare input
let input = ProofInput {
    script: vec![0x12, 0x13, 0x9E, 0x40], // 2 + 3
    arguments: vec![],
    gas_limit: 1_000_000,
};

// Generate proof
let proof = prover.prove(input);

// Verify
assert!(prover.verify(&proof));
```

### Groth16 for Ethereum

```rust
// Generate Groth16 proof for on-chain verification
let prover = NeoProver::new(ProverConfig {
    proof_mode: ProofMode::Groth16,
    ..Default::default()
});

let proof = prover.prove(input);
// proof.proof_bytes can be submitted to Ethereum
```

### Verification

```rust
use neo_zkvm_verifier::{verify, create_verifier};

// Simple verification
assert!(verify(&proof));

// With detailed results
let result = verify_detailed(&proof);
println!("Valid: {}", result.valid);
println!("Type: {:?}", result.proof_type);

// Using explicit vkey
let (client, vk) = create_verifier();
assert!(verify_with_vkey(&proof, &vk));
```

## Performance Considerations

### SP1 Precompiles

Always use SP1 precompiles when available:

| Operation | SP1 Precompile | Speedup |
|-----------|---------------|---------|
| SHA256 | `sha256::sha256` | ~100x |
| Keccak256 | `keccak256::keccak256` | ~100x |
| Ed25519 verify | `ed25519::verify` | ~10x |
| Secp256k1 verify | `secp256k1::verify` | ~10x |

### Proof Mode Selection

| Mode | Proof Size | Verification Time | Use Case |
|------|-----------|-------------------|----------|
| Execute | N/A | Instant | Development |
| Mock | ~200B | Instant | Testing |
| Compressed | ~50KB | ~100ms | Off-chain |
| PLONK | ~10KB | ~200ms | Bridge |
| Groth16 | ~1KB | ~3s | Ethereum |

## Testing Strategy

### Mock Mode (CI/CD)

```rust
#[test]
fn test_script_execution() {
    let prover = NeoProver::new(ProverConfig {
        proof_mode: ProofMode::Mock,
        ..Default::default()
    });
    
    let proof = prover.prove(input);
    assert!(prover.verify(&proof));
}
```

### Real Proofs (Integration Tests)

```rust
#[test]
#[ignore] // Run manually with SP1 setup
fn test_real_sp1_proof() {
    let prover = NeoProver::new(ProverConfig {
        proof_mode: ProofMode::Sp1,
        ..Default::default()
    });
    
    let proof = prover.prove(input);
    assert!(prover.verify(&proof));
}
```

## Common Issues

### ELF Not Found

**Error:** `include_bytes!` cannot find ELF file

**Solution:** 
- Ensure `sp1-build` is in build-dependencies
- Run `cargo clean` and rebuild
- Check that build.rs is executing

### SP1 Environment Not Set

**Error:** `SP1_PROVER` not set

**Solution:**
```bash
export SP1_PROVER=network  # Use Succinct's prover network
# OR
export SP1_PROVER=local    # Use local prover (requires setup)
```

### Out of Memory

**Error:** Guest program runs out of memory

**Solution:**
- Reduce stack allocations
- Use `Vec::with_capacity` instead of dynamic growth
- Stream large data instead of loading all at once

## Migration Checklist

- [ ] Update `build.rs` to use `sp1_build`
- [ ] Update ELF embedding with `include_bytes!`
- [ ] Add SP1 precompile usage in guest
- [ ] Implement all proof modes (Compressed, PLONK, Groth16)
- [ ] Update prover to initialize client once
- [ ] Update verifier for new proof structure
- [ ] Add comprehensive tests for each proof mode
- [ ] Document performance characteristics
- [ ] Set up CI/CD for mock proofs
- [ ] Test real proofs manually

## Benefits of SP1 Integration

1. **Performance**: SP1's precompiles make crypto operations 10-100x faster
2. **Proof Options**: Support for multiple proof systems (Compressed, PLONK, Groth16)
3. **Verification**: On-chain verification with Groth16
4. **Ecosystem**: Access to SP1's tooling and infrastructure
5. **Future-Proof**: Automatic upgrades as SP1 improves

## Conclusion

Refactoring Neo zkVM for SP1 is straightforward and provides significant benefits:
- Better performance through precompiles
- Multiple proof modes for different use cases
- Production-ready infrastructure

The key changes are:
1. Use `sp1-build` for ELF generation
2. Use SP1 precompiles in the guest
3. Support all proof modes
4. Initialize prover client once
