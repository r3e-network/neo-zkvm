//! Neo zkVM Prover with SP1 Integration
//!
//! Production-grade prover using SP1 zkVM for generating zero-knowledge proofs.
//!
//! ## Quick Start
//!
//! ```rust,ignore
//! use neo_zkvm_prover::{NeoProver, ProverConfig, ProveMode};
//! use neo_vm_guest::ProofInput;
//! use neo_vm_core::StackItem;
//!
//! // Create a prover with default config
//! let prover = NeoProver::new(ProverConfig::default());
//!
//! // Define a script: 2 + 3 = 5
//! let input = ProofInput {
//!     script: vec![0x12, 0x13, 0x9E, 0x40],
//!     arguments: vec![],
//!     gas_limit: 1_000_000,
//! };
//!
//! // Generate proof
//! let proof = prover.prove(input);
//!
//! // Check execution was successful
//! assert_eq!(proof.output.state, 0);
//! assert_eq!(proof.output.result, Some(StackItem::Integer(5)));
//! ```
//!
//! ## Proving with Arguments
//!
//! ```rust,ignore
//! use neo_zkvm_prover::{NeoProver, ProverConfig};
//! use neo_vm_guest::ProofInput;
//! use neo_vm_core::StackItem;
//!
//! let prover = NeoProver::new(ProverConfig::default());
//!
//! // Script that adds two arguments: a + b
//! let script = vec![
//!     0x57, 0x00, 0x02, // INITSLOT 0 locals, 2 args
//!     0x74,             // LDARG0
//!     0x75,             // LDARG1
//!     0x9E,             // ADD
//!     0x40,             // RET
//! ];
//!
//! let input = ProofInput {
//!     script,
//!     arguments: vec![StackItem::Integer(10), StackItem::Integer(20)],
//!     gas_limit: 1_000_000,
//! };
//!
//! let proof = prover.prove(input);
//!
//! assert_eq!(proof.output.state, 0);
//! assert_eq!(proof.output.result, Some(StackItem::Integer(30)));
//! ```
//!
//! ## Mock vs Real Proofs
//!
//! ```rust,ignore
//! use neo_zkvm_prover::{NeoProver, ProverConfig, ProveMode};
//! use neo_vm_guest::ProofInput;
//!
//! // Mock proof (fast, for testing)
//! let mock_prover = NeoProver::new(ProverConfig {
//!     max_cycles: 1_000_000,
//!     prove_mode: ProveMode::Mock,
//! });
//!
//! let input = ProofInput {
//!     script: vec![0x12, 0x13, 0x9E, 0x40],
//!     arguments: vec![],
//!     gas_limit: 1_000_000,
//! };
//!
//! let mock_proof = mock_prover.prove(input);
//! assert!(mock_proof.proof_bytes.is_empty()); // Mock proof has no proof bytes
//!
//! // Note: Real SP1 proofs require the sp1 feature and ELF binary
//! // Real proofs are generated with ProveMode::Sp1 or ProveMode::Sp1Plonk
//! ```

use neo_vm_guest::{execute, ProofInput, ProofOutput};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

/// ELF binary for the SP1 guest program
/// This is embedded at compile time by build.rs after building neo-zkvm-program
/// Falls back to empty if not built (mock mode will be used)
#[cfg(feature = "sp1")]
pub const NEO_ZKVM_ELF: &[u8] = &[];

/// ELF placeholder when SP1 feature is disabled
#[cfg(not(feature = "sp1"))]
pub const NEO_ZKVM_ELF: &[u8] = &[];

/// Check if the SP1 guest program ELF has been built
pub fn is_elf_available() -> bool {
    !NEO_ZKVM_ELF.is_empty()
}

/// Proof generated by the prover
#[derive(Serialize, Deserialize)]
pub struct NeoProof {
    pub output: ProofOutput,
    pub proof_bytes: Vec<u8>,
    pub public_inputs: PublicInputs,
    pub vkey_hash: [u8; 32],
}

/// Public inputs for verification
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PublicInputs {
    pub script_hash: [u8; 32],
    pub input_hash: [u8; 32],
    pub output_hash: [u8; 32],
    pub gas_consumed: u64,
    pub execution_success: bool,
}

/// Prover configuration
#[derive(Clone, Debug)]
pub struct ProverConfig {
    /// Maximum number of cycles for SP1 execution
    pub max_cycles: u64,
    /// Mode for proof generation
    pub prove_mode: ProveMode,
}

/// Guest input for SP1 program
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct GuestInput {
    /// The script bytecode to execute
    pub script: Vec<u8>,
    /// Arguments to pass to the script
    pub arguments: Vec<GuestStackItem>,
    /// Gas limit for execution
    pub gas_limit: u64,
}

/// Proving mode
#[derive(Clone, Copy, Debug)]
pub enum ProveMode {
    /// Execute only, no proof
    Execute,
    /// Generate mock proof (for testing)
    Mock,
    /// Generate real SP1 proof (compressed)
    Sp1,
    /// Generate SP1 PLONK proof (for on-chain verification)
    Sp1Plonk,
}

impl Default for ProverConfig {
    fn default() -> Self {
        Self {
            max_cycles: 1_000_000,
            prove_mode: ProveMode::Mock,
        }
    }
}

/// Simplified stack item for guest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GuestStackItem {
    Null,
    Boolean(bool),
    Integer(i128),
    ByteString(Vec<u8>),
}

/// Neo zkVM Prover
pub struct NeoProver {
    config: ProverConfig,
}

impl NeoProver {
    pub fn new(config: ProverConfig) -> Self {
        Self { config }
    }

    /// Generate proof for script execution
    pub fn prove(&self, input: ProofInput) -> NeoProof {
        let script_hash = Self::hash_data(&input.script);
        let input_bytes = bincode::serialize(&input.arguments).unwrap_or_default();
        let input_hash = Self::hash_data(&input_bytes);

        let output = execute(input.clone());
        let output_hash = Self::hash_data(&output.gas_consumed.to_le_bytes());

        let public_inputs = PublicInputs {
            script_hash,
            input_hash,
            output_hash,
            gas_consumed: output.gas_consumed,
            execution_success: output.state == 0,
        };

        let (proof_bytes, vkey_hash) = match self.config.prove_mode {
            ProveMode::Execute => (vec![], [0u8; 32]),
            ProveMode::Mock => (self.generate_mock_proof(&public_inputs), [0u8; 32]),
            ProveMode::Sp1 => self.generate_sp1_proof(&input),
            ProveMode::Sp1Plonk => self.generate_sp1_plonk_proof(&input),
        };

        NeoProof {
            output,
            proof_bytes,
            public_inputs,
            vkey_hash,
        }
    }

    fn hash_data(data: &[u8]) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(data);
        hasher.finalize().into()
    }

    fn generate_mock_proof(&self, inputs: &PublicInputs) -> Vec<u8> {
        let mock = MockProof {
            public_inputs: inputs.clone(),
            commitment: Self::compute_commitment(inputs),
            signature: vec![0u8; 64],
        };
        bincode::serialize(&mock).unwrap_or_default()
    }

    fn generate_sp1_proof(&self, input: &ProofInput) -> (Vec<u8>, [u8; 32]) {
        use sp1_sdk::{ProverClient, SP1Stdin};

        // Initialize SP1 prover client
        let client = ProverClient::from_env();

        // Prepare stdin with input data
        let mut stdin = SP1Stdin::new();
        let guest_input = GuestInput {
            script: input.script.clone(),
            arguments: input.arguments.iter().map(stack_item_to_guest).collect(),
            gas_limit: input.gas_limit,
        };
        stdin.write(&guest_input);

        // Setup and prove
        let (pk, vk) = client.setup(NEO_ZKVM_ELF);
        let proof = client
            .prove(&pk, &stdin)
            .compressed()
            .run()
            .expect("SP1 proving failed");

        // Verify the proof
        client.verify(&proof, &vk).expect("SP1 verification failed");

        // Serialize proof using SP1's native serialization
        let proof_bytes = proof.bytes().to_vec();
        let vkey_hash = Self::hash_data(&bincode::serialize(&vk).unwrap_or_default());

        (proof_bytes, vkey_hash)
    }

    fn generate_sp1_plonk_proof(&self, input: &ProofInput) -> (Vec<u8>, [u8; 32]) {
        use sp1_sdk::{ProverClient, SP1Stdin};

        let client = ProverClient::from_env();

        let mut stdin = SP1Stdin::new();
        let guest_input = GuestInput {
            script: input.script.clone(),
            arguments: input.arguments.iter().map(stack_item_to_guest).collect(),
            gas_limit: input.gas_limit,
        };
        stdin.write(&guest_input);

        let (pk, vk) = client.setup(NEO_ZKVM_ELF);

        // Generate PLONK proof for on-chain verification
        let proof = client
            .prove(&pk, &stdin)
            .plonk()
            .run()
            .expect("SP1 PLONK proving failed");

        client
            .verify(&proof, &vk)
            .expect("SP1 PLONK verification failed");

        // Serialize proof using SP1's native serialization
        let proof_bytes = proof.bytes().to_vec();
        let vkey_hash = Self::hash_data(&bincode::serialize(&vk).unwrap_or_default());

        (proof_bytes, vkey_hash)
    }

    fn compute_commitment(inputs: &PublicInputs) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(inputs.script_hash);
        hasher.update(inputs.input_hash);
        hasher.update(inputs.output_hash);
        hasher.update(inputs.gas_consumed.to_le_bytes());
        hasher.update([inputs.execution_success as u8]);
        hasher.finalize().into()
    }
}

/// Convert StackItem to GuestStackItem
fn stack_item_to_guest(item: &neo_vm_core::StackItem) -> GuestStackItem {
    match item {
        neo_vm_core::StackItem::Null => GuestStackItem::Null,
        neo_vm_core::StackItem::Boolean(b) => GuestStackItem::Boolean(*b),
        neo_vm_core::StackItem::Integer(i) => GuestStackItem::Integer(*i),
        neo_vm_core::StackItem::ByteString(b) => GuestStackItem::ByteString(b.clone()),
        _ => GuestStackItem::Null,
    }
}

/// Mock proof structure
#[derive(Serialize, Deserialize)]
pub struct MockProof {
    pub public_inputs: PublicInputs,
    pub commitment: [u8; 32],
    pub signature: Vec<u8>,
}
