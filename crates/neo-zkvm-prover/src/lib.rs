//! Neo zkVM Prover with SP1 Integration
//!
//! Production-grade prover using SP1 zkVM for generating zero-knowledge proofs.
//!
//! ## Quick Start
//!
//! ```rust
//! use neo_zkvm_prover::{NeoProver, ProverConfig, ProofMode};
//! use neo_vm_guest::ProofInput;
//!
//! // Create prover with default config
//! let prover = NeoProver::new(ProverConfig::default());
//!
//! // Define input
//! let input = ProofInput {
//!     script: vec![0x12, 0x13, 0x9E, 0x40], // 2 + 3
//!     arguments: vec![],
//!     gas_limit: 1_000_000,
//! };
//!
//! // Generate proof
//! let proof = prover.prove(input);
//! ```

use bincode::Options;
use neo_vm_guest::{execute, ProofInput, ProofOutput};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sp1_sdk::{ProverClient, SP1ProofMode, SP1PublicValues, SP1Stdin};

/// SP1 ELF binary - embedded at compile time
/// This is the compiled guest program that runs inside SP1 zkVM
///
/// Note: If SP1 toolchain is not installed, this will be a dummy value
/// and proof generation will fall back to mock mode.
pub const NEO_ZKVM_ELF: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/elf/riscv32im-succinct-zkvm-elf"));

const BINCODE_LIMIT: u64 = 10 * 1024 * 1024; // 10MB limit

fn bincode_options() -> impl Options {
    bincode::DefaultOptions::new()
        .with_limit(BINCODE_LIMIT)
        .with_fixint_encoding()
}

/// Proof generated by the prover
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct NeoProof {
    /// Execution output
    pub output: ProofOutput,
    /// SP1 proof bytes
    pub proof_bytes: Vec<u8>,
    /// Public inputs for verification
    pub public_inputs: PublicInputs,
    /// Verification key hash
    pub vkey_hash: [u8; 32],
    /// Proof mode used
    pub proof_mode: ProofMode,
}

/// Public inputs for verification
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PublicInputs {
    /// Hash of the executed script
    pub script_hash: [u8; 32],
    /// Hash of input arguments
    pub input_hash: [u8; 32],
    /// Hash of execution output
    pub output_hash: [u8; 32],
    /// Gas consumed during execution
    pub gas_consumed: u64,
    /// Whether execution succeeded
    pub execution_success: bool,
}

/// Prover configuration
#[derive(Clone, Debug)]
pub struct ProverConfig {
    /// Maximum cycles for SP1 execution
    pub max_cycles: u64,
    /// Proof mode (determines proof type and verification cost)
    pub proof_mode: ProofMode,
}

/// Proof mode - determines the type of proof generated
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProofMode {
    /// Execute only, no proof generation (fastest)
    Execute,
    /// Mock proof for testing (fast, not verifiable)
    Mock,
    /// SP1 compressed proof (fast verification, larger proof)
    Sp1,
    /// SP1 PLONK proof (medium verification cost, smaller proof)
    Plonk,
    /// SP1 Groth16 proof (slowest verification, smallest proof, best for Ethereum)
    Groth16,
}

impl Default for ProverConfig {
    fn default() -> Self {
        Self {
            max_cycles: 10_000_000,
            proof_mode: ProofMode::Sp1,
        }
    }
}

/// Neo zkVM Prover
pub struct NeoProver {
    config: ProverConfig,
}

impl NeoProver {
    /// Check if the SP1 ELF is available and valid
    pub fn is_elf_available() -> bool {
        !NEO_ZKVM_ELF.is_empty() && NEO_ZKVM_ELF.len() > 100 &&
        // Check it's not our dummy marker
        !NEO_ZKVM_ELF.starts_with(b"DUMMY")
    }

    /// Create a new prover with the given configuration
    ///
    /// If SP1 is not available, it will fall back to mock mode.
    pub fn new(config: ProverConfig) -> Self {
        Self { config }
    }

    /// Generate a proof for the given input
    ///
    /// The proof mode in the config determines what type of proof is generated.
    /// If SP1 is not available, automatically falls back to mock mode.
    pub fn prove(&self, input: ProofInput) -> NeoProof {
        // Compute hashes for public inputs
        let script_hash = Self::hash_data(&input.script);
        let input_hash = Self::hash_guest_input(&input);

        // Execute to get output (used for all modes)
        let output = execute(input.clone());
        let output_bytes = bincode::serialize(&output).unwrap_or_default();
        let output_hash = Self::hash_data(&output_bytes);

        let mut public_inputs = PublicInputs {
            script_hash,
            input_hash,
            output_hash,
            gas_consumed: output.gas_consumed,
            execution_success: output.state == 0,
        };

        // Check if SP1 is available
        let sp1_available = Self::is_elf_available();

        // Generate proof based on mode (fallback to mock if SP1 not available)
        let (proof_bytes, vkey_hash, actual_mode, sp1_public_inputs) =
            match self.config.proof_mode {
                ProofMode::Execute => (vec![], [0u8; 32], ProofMode::Execute, None),
                ProofMode::Mock => (
                    self.generate_mock_proof(&public_inputs),
                    [0u8; 32],
                    ProofMode::Mock,
                    None,
                ),
            ProofMode::Sp1 if sp1_available => {
                match self.generate_sp1_proof(&input, SP1ProofMode::Compressed) {
                    Ok((bytes, hash, inputs)) => (bytes, hash, ProofMode::Sp1, Some(inputs)),
                    Err(_) => {
                        eprintln!("Warning: SP1 proof generation failed, falling back to mock");
                        (
                            self.generate_mock_proof(&public_inputs),
                            [0u8; 32],
                            ProofMode::Mock,
                            None,
                        )
                    }
                }
            }
            ProofMode::Plonk if sp1_available => {
                match self.generate_sp1_proof(&input, SP1ProofMode::Plonk) {
                    Ok((bytes, hash, inputs)) => (bytes, hash, ProofMode::Plonk, Some(inputs)),
                    Err(_) => {
                        eprintln!("Warning: PLONK proof generation failed, falling back to mock");
                        (
                            self.generate_mock_proof(&public_inputs),
                            [0u8; 32],
                            ProofMode::Mock,
                            None,
                        )
                    }
                }
            }
            ProofMode::Groth16 if sp1_available => {
                match self.generate_sp1_proof(&input, SP1ProofMode::Groth16) {
                    Ok((bytes, hash, inputs)) => (bytes, hash, ProofMode::Groth16, Some(inputs)),
                    Err(_) => {
                        eprintln!("Warning: Groth16 proof generation failed, falling back to mock");
                        (
                            self.generate_mock_proof(&public_inputs),
                            [0u8; 32],
                            ProofMode::Mock,
                            None,
                        )
                    }
                }
            }
            // Fallback to mock for SP1 modes when ELF not available
            _ => {
                eprintln!("Warning: SP1 ELF not available, falling back to mock proof");
                (
                    self.generate_mock_proof(&public_inputs),
                    [0u8; 32],
                    ProofMode::Mock,
                    None,
                )
            }
            };

        if let Some(inputs) = sp1_public_inputs {
            public_inputs = inputs;
        }

        NeoProof {
            output,
            proof_bytes,
            public_inputs,
            vkey_hash,
            proof_mode: actual_mode,
        }
    }

    /// Verify a proof
    ///
    /// Returns true if the proof is valid, false otherwise.
    pub fn verify(&self, proof: &NeoProof) -> bool {
        match proof.proof_mode {
            ProofMode::Execute => true,
            ProofMode::Mock => self.verify_mock_proof(proof),
            ProofMode::Sp1 | ProofMode::Plonk | ProofMode::Groth16 => {
                self.verify_sp1_proof(proof).unwrap_or(false)
            }
        }
    }

    fn hash_data(data: &[u8]) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(data);
        hasher.finalize().into()
    }

    fn hash_guest_input(input: &ProofInput) -> [u8; 32] {
        let guest_input = build_guest_input(input);
        let bytes = bincode::serialize(&guest_input).unwrap_or_default();
        Self::hash_data(&bytes)
    }

    fn generate_mock_proof(&self, inputs: &PublicInputs) -> Vec<u8> {
        let mock = MockProof {
            public_inputs: inputs.clone(),
            commitment: Self::compute_commitment(inputs),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        };
        bincode::serialize(&mock).unwrap_or_default()
    }

    fn verify_mock_proof(&self, proof: &NeoProof) -> bool {
        match bincode::deserialize::<MockProof>(&proof.proof_bytes) {
            Ok(mock) => {
                let expected = Self::compute_commitment(&proof.public_inputs);
                mock.commitment == expected
                    && mock.public_inputs.script_hash == proof.public_inputs.script_hash
            }
            Err(_) => false,
        }
    }

    fn generate_sp1_proof(
        &self,
        input: &ProofInput,
        mode: sp1_sdk::SP1ProofMode,
    ) -> Result<(Vec<u8>, [u8; 32], PublicInputs), Box<dyn std::error::Error>> {
        // Only run if ELF is available
        if !Self::is_elf_available() {
            return Err("SP1 ELF not available".into());
        }

        let prover = ProverClient::from_env();
        let (pk, vk) = prover.setup(NEO_ZKVM_ELF);

        let stdin = self.prepare_stdin(input);

        // Build and run the proof based on mode
        let proof = match mode {
            sp1_sdk::SP1ProofMode::Core => prover.prove(&pk, &stdin).core().run(),
            sp1_sdk::SP1ProofMode::Compressed => prover.prove(&pk, &stdin).compressed().run(),
            sp1_sdk::SP1ProofMode::Plonk => prover.prove(&pk, &stdin).plonk().run(),
            sp1_sdk::SP1ProofMode::Groth16 => prover.prove(&pk, &stdin).groth16().run(),
        }?;

        // Verify immediately to catch any issues
        prover.verify(&proof, &vk)?;

        let public_inputs = decode_public_inputs(&proof.public_values)?;
        let proof_bytes = bincode::serialize(&proof)?;
        let vkey_hash = Self::hash_data(&bincode::serialize(&vk)?);

        Ok((proof_bytes, vkey_hash, public_inputs))
    }

    fn verify_sp1_proof(&self, proof: &NeoProof) -> Result<bool, Box<dyn std::error::Error>> {
        if !Self::is_elf_available() {
            return Ok(false);
        }

        let prover = ProverClient::from_env();
        let (_, vk) = prover.setup(NEO_ZKVM_ELF);

        let sp1_proof: sp1_sdk::SP1ProofWithPublicValues =
            bincode_options().deserialize(&proof.proof_bytes)?;
        let public_inputs = decode_public_inputs(&sp1_proof.public_values)?;
        if !public_inputs_equal(&public_inputs, &proof.public_inputs) {
            return Ok(false);
        }

        match prover.verify(&sp1_proof, &vk) {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }

    fn prepare_stdin(&self, input: &ProofInput) -> SP1Stdin {
        let mut stdin = SP1Stdin::new();

        // Convert to guest-compatible format
        let guest_input = build_guest_input(input);

        stdin.write(&guest_input);
        stdin
    }

    fn compute_commitment(inputs: &PublicInputs) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(inputs.script_hash);
        hasher.update(inputs.input_hash);
        hasher.update(inputs.output_hash);
        hasher.update(inputs.gas_consumed.to_le_bytes());
        hasher.update([inputs.execution_success as u8]);
        hasher.finalize().into()
    }
}

/// Input for the guest program
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct GuestInput {
    pub script: Vec<u8>,
    pub arguments: Vec<GuestStackItem>,
    pub gas_limit: u64,
}

/// Simplified stack item for guest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GuestStackItem {
    Null,
    Boolean(bool),
    Integer(i128),
    ByteString(Vec<u8>),
}

fn decode_public_inputs(
    values: &SP1PublicValues,
) -> Result<PublicInputs, Box<dyn std::error::Error>> {
    Ok(bincode_options().deserialize(values.as_slice())?)
}

fn public_inputs_equal(a: &PublicInputs, b: &PublicInputs) -> bool {
    a.script_hash == b.script_hash
        && a.input_hash == b.input_hash
        && a.output_hash == b.output_hash
        && a.gas_consumed == b.gas_consumed
        && a.execution_success == b.execution_success
}

fn build_guest_input(input: &ProofInput) -> GuestInput {
    GuestInput {
        script: input.script.clone(),
        arguments: input
            .arguments
            .iter()
            .map(|item| match item {
                neo_vm_core::StackItem::Null => GuestStackItem::Null,
                neo_vm_core::StackItem::Boolean(b) => GuestStackItem::Boolean(*b),
                neo_vm_core::StackItem::Integer(i) => GuestStackItem::Integer(*i),
                neo_vm_core::StackItem::ByteString(b) => GuestStackItem::ByteString(b.clone()),
                _ => GuestStackItem::Null,
            })
            .collect(),
        gas_limit: input.gas_limit,
    }
}

/// Mock proof structure for testing
#[derive(Serialize, Deserialize)]
pub struct MockProof {
    pub public_inputs: PublicInputs,
    pub commitment: [u8; 32],
    pub timestamp: u64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use neo_vm_core::StackItem;

    #[test]
    fn test_mock_proof() {
        let prover = NeoProver::new(ProverConfig {
            proof_mode: ProofMode::Mock,
            ..Default::default()
        });

        let input = ProofInput {
            script: vec![0x12, 0x13, 0x9E, 0x40],
            arguments: vec![],
            gas_limit: 1_000_000,
        };

        let proof = prover.prove(input);
        assert!(proof.proof_mode == ProofMode::Mock);
        assert!(prover.verify(&proof));
    }

    #[test]
    fn test_execute_only() {
        let prover = NeoProver::new(ProverConfig {
            proof_mode: ProofMode::Execute,
            ..Default::default()
        });

        let input = ProofInput {
            script: vec![0x12, 0x13, 0x9E, 0x40],
            arguments: vec![],
            gas_limit: 1_000_000,
        };

        let proof = prover.prove(input);
        assert!(proof.proof_mode == ProofMode::Execute);
        assert!(prover.verify(&proof));
    }

    #[test]
    fn test_guest_input_hash_matches_serialized_guest_input() {
        let input = ProofInput {
            script: vec![0x12, 0x13, 0x9E, 0x40],
            arguments: vec![StackItem::Integer(7)],
            gas_limit: 123,
        };

        let guest = build_guest_input(&input);
        let bytes = bincode::serialize(&guest).expect("serialize");
        let hash = NeoProver::hash_data(&bytes);

        assert_eq!(hash, NeoProver::hash_guest_input(&input));
    }
}
