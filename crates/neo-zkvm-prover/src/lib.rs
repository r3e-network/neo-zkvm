//! Neo zkVM Prover with SP1 Integration
//!
//! Production-grade prover using SP1 zkVM for generating zero-knowledge proofs.

use neo_vm_guest::{execute, ProofInput, ProofOutput};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sp1_sdk::SP1Stdin;

/// ELF binary for the SP1 guest program
/// This will be embedded at compile time after building neo-zkvm-program
pub const NEO_ZKVM_ELF: &[u8] = &[];

/// Proof generated by the prover
#[derive(Serialize, Deserialize)]
pub struct NeoProof {
    pub output: ProofOutput,
    pub proof_bytes: Vec<u8>,
    pub public_inputs: PublicInputs,
    pub vkey_hash: [u8; 32],
}

/// Public inputs for verification
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PublicInputs {
    pub script_hash: [u8; 32],
    pub input_hash: [u8; 32],
    pub output_hash: [u8; 32],
    pub gas_consumed: u64,
    pub execution_success: bool,
}

/// Prover configuration
pub struct ProverConfig {
    pub max_cycles: u64,
    pub prove_mode: ProveMode,
}

/// Proving mode
#[derive(Clone, Copy, Debug)]
pub enum ProveMode {
    /// Execute only, no proof
    Execute,
    /// Generate mock proof (for testing)
    Mock,
    /// Generate real SP1 proof (compressed)
    Sp1,
    /// Generate SP1 PLONK proof (for on-chain verification)
    Sp1Plonk,
}

impl Default for ProverConfig {
    fn default() -> Self {
        Self {
            max_cycles: 1_000_000,
            prove_mode: ProveMode::Mock,
        }
    }
}

/// Guest input for SP1 program
#[derive(Serialize, Deserialize, Clone)]
pub struct GuestInput {
    pub script: Vec<u8>,
    pub arguments: Vec<GuestStackItem>,
    pub gas_limit: u64,
}

/// Simplified stack item for guest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum GuestStackItem {
    Null,
    Boolean(bool),
    Integer(i128),
    ByteString(Vec<u8>),
}

/// Neo zkVM Prover
pub struct NeoProver {
    config: ProverConfig,
}

impl NeoProver {
    pub fn new(config: ProverConfig) -> Self {
        Self { config }
    }

    /// Generate proof for script execution
    pub fn prove(&self, input: ProofInput) -> NeoProof {
        let script_hash = Self::hash_data(&input.script);
        let input_bytes = bincode::serialize(&input.arguments).unwrap_or_default();
        let input_hash = Self::hash_data(&input_bytes);
        
        let output = execute(input.clone());
        let output_hash = Self::hash_data(&output.gas_consumed.to_le_bytes());
        
        let public_inputs = PublicInputs {
            script_hash,
            input_hash,
            output_hash,
            gas_consumed: output.gas_consumed,
            execution_success: output.state == 0,
        };

        let (proof_bytes, vkey_hash) = match self.config.prove_mode {
            ProveMode::Execute => (vec![], [0u8; 32]),
            ProveMode::Mock => (self.generate_mock_proof(&public_inputs), [0u8; 32]),
            ProveMode::Sp1 => self.generate_sp1_proof(&input),
            ProveMode::Sp1Plonk => self.generate_sp1_plonk_proof(&input),
        };

        NeoProof { output, proof_bytes, public_inputs, vkey_hash }
    }

    fn hash_data(data: &[u8]) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(data);
        hasher.finalize().into()
    }

    fn generate_mock_proof(&self, inputs: &PublicInputs) -> Vec<u8> {
        let mock = MockProof {
            public_inputs: inputs.clone(),
            commitment: Self::compute_commitment(inputs),
            signature: vec![0u8; 64],
        };
        bincode::serialize(&mock).unwrap_or_default()
    }

    fn generate_sp1_proof(&self, input: &ProofInput) -> (Vec<u8>, [u8; 32]) {
        use sp1_sdk::{ProverClient, SP1Stdin};
        
        // Initialize SP1 prover client
        let client = ProverClient::from_env();
        
        // Prepare stdin with input data
        let mut stdin = SP1Stdin::new();
        let guest_input = GuestInput {
            script: input.script.clone(),
            arguments: input.arguments.iter().map(|a| stack_item_to_guest(a)).collect(),
            gas_limit: input.gas_limit,
        };
        stdin.write(&guest_input);
        
        // Setup and prove
        let (pk, vk) = client.setup(NEO_ZKVM_ELF);
        let proof = client.prove(&pk, &stdin)
            .compressed()
            .run()
            .expect("SP1 proving failed");
        
        // Verify the proof
        client.verify(&proof, &vk).expect("SP1 verification failed");
        
        // Serialize proof
        let proof_bytes = bincode::serialize(&proof).unwrap_or_default();
        let vkey_hash = Self::hash_data(&bincode::serialize(&vk).unwrap_or_default());
        
        (proof_bytes, vkey_hash)
    }

    fn generate_sp1_plonk_proof(&self, input: &ProofInput) -> (Vec<u8>, [u8; 32]) {
        use sp1_sdk::{ProverClient, SP1Stdin};
        
        let client = ProverClient::from_env();
        
        let mut stdin = SP1Stdin::new();
        let guest_input = GuestInput {
            script: input.script.clone(),
            arguments: input.arguments.iter().map(|a| stack_item_to_guest(a)).collect(),
            gas_limit: input.gas_limit,
        };
        stdin.write(&guest_input);
        
        let (pk, vk) = client.setup(NEO_ZKVM_ELF);
        
        // Generate PLONK proof for on-chain verification
        let proof = client.prove(&pk, &stdin)
            .plonk()
            .run()
            .expect("SP1 PLONK proving failed");
        
        client.verify(&proof, &vk).expect("SP1 PLONK verification failed");
        
        let proof_bytes = bincode::serialize(&proof).unwrap_or_default();
        let vkey_hash = Self::hash_data(&bincode::serialize(&vk).unwrap_or_default());
        
        (proof_bytes, vkey_hash)
    }

    fn compute_commitment(inputs: &PublicInputs) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(inputs.script_hash);
        hasher.update(inputs.input_hash);
        hasher.update(inputs.output_hash);
        hasher.update(inputs.gas_consumed.to_le_bytes());
        hasher.update([inputs.execution_success as u8]);
        hasher.finalize().into()
    }
}

/// Convert StackItem to GuestStackItem
fn stack_item_to_guest(item: &neo_vm_core::StackItem) -> GuestStackItem {
    match item {
        neo_vm_core::StackItem::Null => GuestStackItem::Null,
        neo_vm_core::StackItem::Boolean(b) => GuestStackItem::Boolean(*b),
        neo_vm_core::StackItem::Integer(i) => GuestStackItem::Integer(*i),
        neo_vm_core::StackItem::ByteString(b) => GuestStackItem::ByteString(b.clone()),
        _ => GuestStackItem::Null,
    }
}

/// Mock proof structure
#[derive(Serialize, Deserialize)]
pub struct MockProof {
    pub public_inputs: PublicInputs,
    pub commitment: [u8; 32],
    pub signature: Vec<u8>,
}
